
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model user_otp
 * 
 */
export type user_otp = $Result.DefaultSelection<Prisma.$user_otpPayload>
/**
 * Model Monitor_config
 * 
 */
export type Monitor_config = $Result.DefaultSelection<Prisma.$Monitor_configPayload>
/**
 * Model Monitor_HTTP_gPRC_config
 * 
 */
export type Monitor_HTTP_gPRC_config = $Result.DefaultSelection<Prisma.$Monitor_HTTP_gPRC_configPayload>
/**
 * Model Monitor_SSL_config
 * 
 */
export type Monitor_SSL_config = $Result.DefaultSelection<Prisma.$Monitor_SSL_configPayload>
/**
 * Model Monitor_System_components
 * 
 */
export type Monitor_System_components = $Result.DefaultSelection<Prisma.$Monitor_System_componentsPayload>
/**
 * Model WorkSpace
 * 
 */
export type WorkSpace = $Result.DefaultSelection<Prisma.$WorkSpacePayload>
/**
 * Model invited_users
 * 
 */
export type invited_users = $Result.DefaultSelection<Prisma.$invited_usersPayload>
/**
 * Model WorkSpace_users
 * 
 */
export type WorkSpace_users = $Result.DefaultSelection<Prisma.$WorkSpace_usersPayload>
/**
 * Model team
 * 
 */
export type team = $Result.DefaultSelection<Prisma.$teamPayload>
/**
 * Model team_member
 * 
 */
export type team_member = $Result.DefaultSelection<Prisma.$team_memberPayload>
/**
 * Model alert
 * 
 */
export type alert = $Result.DefaultSelection<Prisma.$alertPayload>
/**
 * Model team_escalationpolicy
 * 
 */
export type team_escalationpolicy = $Result.DefaultSelection<Prisma.$team_escalationpolicyPayload>
/**
 * Model escalation_policy_rules
 * 
 */
export type escalation_policy_rules = $Result.DefaultSelection<Prisma.$escalation_policy_rulesPayload>
/**
 * Model team_schedule
 * 
 */
export type team_schedule = $Result.DefaultSelection<Prisma.$team_schedulePayload>
/**
 * Model team_schedule_rotation
 * 
 */
export type team_schedule_rotation = $Result.DefaultSelection<Prisma.$team_schedule_rotationPayload>
/**
 * Model team_schedule_override
 * 
 */
export type team_schedule_override = $Result.DefaultSelection<Prisma.$team_schedule_overridePayload>
/**
 * Model contactUs
 * 
 */
export type contactUs = $Result.DefaultSelection<Prisma.$contactUsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const MonitorTypes: {
  Http_gRPC: 'Http_gRPC',
  SSL: 'SSL',
  Nginx: 'Nginx',
  ErrorCode: 'ErrorCode'
};

export type MonitorTypes = (typeof MonitorTypes)[keyof typeof MonitorTypes]


export const AuthType: {
  JWT: 'JWT',
  Basic: 'Basic'
};

export type AuthType = (typeof AuthType)[keyof typeof AuthType]


export const Role: {
  owner: 'owner',
  admin: 'admin',
  user: 'user',
  stackholder: 'stackholder'
};

export type Role = (typeof Role)[keyof typeof Role]


export const status: {
  verified: 'verified',
  unverified: 'unverified'
};

export type status = (typeof status)[keyof typeof status]


export const notification_type: {
  user: 'user',
  on_call: 'on_call',
  team: 'team',
  members: 'members',
  admin: 'admin',
  notify_users: 'notify_users'
};

export type notification_type = (typeof notification_type)[keyof typeof notification_type]


export const Frequency: {
  daily: 'daily',
  weekly: 'weekly',
  custom: 'custom'
};

export type Frequency = (typeof Frequency)[keyof typeof Frequency]


export const Restriction: {
  time_of_day: 'time_of_day',
  weekday: 'weekday'
};

export type Restriction = (typeof Restriction)[keyof typeof Restriction]

}

export type MonitorTypes = $Enums.MonitorTypes

export const MonitorTypes: typeof $Enums.MonitorTypes

export type AuthType = $Enums.AuthType

export const AuthType: typeof $Enums.AuthType

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type status = $Enums.status

export const status: typeof $Enums.status

export type notification_type = $Enums.notification_type

export const notification_type: typeof $Enums.notification_type

export type Frequency = $Enums.Frequency

export const Frequency: typeof $Enums.Frequency

export type Restriction = $Enums.Restriction

export const Restriction: typeof $Enums.Restriction

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.user_otp`: Exposes CRUD operations for the **user_otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more User_otps
    * const user_otps = await prisma.user_otp.findMany()
    * ```
    */
  get user_otp(): Prisma.user_otpDelegate<ExtArgs>;

  /**
   * `prisma.monitor_config`: Exposes CRUD operations for the **Monitor_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monitor_configs
    * const monitor_configs = await prisma.monitor_config.findMany()
    * ```
    */
  get monitor_config(): Prisma.Monitor_configDelegate<ExtArgs>;

  /**
   * `prisma.monitor_HTTP_gPRC_config`: Exposes CRUD operations for the **Monitor_HTTP_gPRC_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monitor_HTTP_gPRC_configs
    * const monitor_HTTP_gPRC_configs = await prisma.monitor_HTTP_gPRC_config.findMany()
    * ```
    */
  get monitor_HTTP_gPRC_config(): Prisma.Monitor_HTTP_gPRC_configDelegate<ExtArgs>;

  /**
   * `prisma.monitor_SSL_config`: Exposes CRUD operations for the **Monitor_SSL_config** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monitor_SSL_configs
    * const monitor_SSL_configs = await prisma.monitor_SSL_config.findMany()
    * ```
    */
  get monitor_SSL_config(): Prisma.Monitor_SSL_configDelegate<ExtArgs>;

  /**
   * `prisma.monitor_System_components`: Exposes CRUD operations for the **Monitor_System_components** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Monitor_System_components
    * const monitor_System_components = await prisma.monitor_System_components.findMany()
    * ```
    */
  get monitor_System_components(): Prisma.Monitor_System_componentsDelegate<ExtArgs>;

  /**
   * `prisma.workSpace`: Exposes CRUD operations for the **WorkSpace** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkSpaces
    * const workSpaces = await prisma.workSpace.findMany()
    * ```
    */
  get workSpace(): Prisma.WorkSpaceDelegate<ExtArgs>;

  /**
   * `prisma.invited_users`: Exposes CRUD operations for the **invited_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invited_users
    * const invited_users = await prisma.invited_users.findMany()
    * ```
    */
  get invited_users(): Prisma.invited_usersDelegate<ExtArgs>;

  /**
   * `prisma.workSpace_users`: Exposes CRUD operations for the **WorkSpace_users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WorkSpace_users
    * const workSpace_users = await prisma.workSpace_users.findMany()
    * ```
    */
  get workSpace_users(): Prisma.WorkSpace_usersDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.teamDelegate<ExtArgs>;

  /**
   * `prisma.team_member`: Exposes CRUD operations for the **team_member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Team_members
    * const team_members = await prisma.team_member.findMany()
    * ```
    */
  get team_member(): Prisma.team_memberDelegate<ExtArgs>;

  /**
   * `prisma.alert`: Exposes CRUD operations for the **alert** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Alerts
    * const alerts = await prisma.alert.findMany()
    * ```
    */
  get alert(): Prisma.alertDelegate<ExtArgs>;

  /**
   * `prisma.team_escalationpolicy`: Exposes CRUD operations for the **team_escalationpolicy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Team_escalationpolicies
    * const team_escalationpolicies = await prisma.team_escalationpolicy.findMany()
    * ```
    */
  get team_escalationpolicy(): Prisma.team_escalationpolicyDelegate<ExtArgs>;

  /**
   * `prisma.escalation_policy_rules`: Exposes CRUD operations for the **escalation_policy_rules** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Escalation_policy_rules
    * const escalation_policy_rules = await prisma.escalation_policy_rules.findMany()
    * ```
    */
  get escalation_policy_rules(): Prisma.escalation_policy_rulesDelegate<ExtArgs>;

  /**
   * `prisma.team_schedule`: Exposes CRUD operations for the **team_schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Team_schedules
    * const team_schedules = await prisma.team_schedule.findMany()
    * ```
    */
  get team_schedule(): Prisma.team_scheduleDelegate<ExtArgs>;

  /**
   * `prisma.team_schedule_rotation`: Exposes CRUD operations for the **team_schedule_rotation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Team_schedule_rotations
    * const team_schedule_rotations = await prisma.team_schedule_rotation.findMany()
    * ```
    */
  get team_schedule_rotation(): Prisma.team_schedule_rotationDelegate<ExtArgs>;

  /**
   * `prisma.team_schedule_override`: Exposes CRUD operations for the **team_schedule_override** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Team_schedule_overrides
    * const team_schedule_overrides = await prisma.team_schedule_override.findMany()
    * ```
    */
  get team_schedule_override(): Prisma.team_schedule_overrideDelegate<ExtArgs>;

  /**
   * `prisma.contactUs`: Exposes CRUD operations for the **contactUs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contactuses
    * const contactuses = await prisma.contactUs.findMany()
    * ```
    */
  get contactUs(): Prisma.contactUsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.0.0
   * Query Engine version: 5dbef10bdbfb579e07d35cc85fb1518d357cb99e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    user_otp: 'user_otp',
    Monitor_config: 'Monitor_config',
    Monitor_HTTP_gPRC_config: 'Monitor_HTTP_gPRC_config',
    Monitor_SSL_config: 'Monitor_SSL_config',
    Monitor_System_components: 'Monitor_System_components',
    WorkSpace: 'WorkSpace',
    invited_users: 'invited_users',
    WorkSpace_users: 'WorkSpace_users',
    team: 'team',
    team_member: 'team_member',
    alert: 'alert',
    team_escalationpolicy: 'team_escalationpolicy',
    escalation_policy_rules: 'escalation_policy_rules',
    team_schedule: 'team_schedule',
    team_schedule_rotation: 'team_schedule_rotation',
    team_schedule_override: 'team_schedule_override',
    contactUs: 'contactUs'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "user_otp" | "monitor_config" | "monitor_HTTP_gPRC_config" | "monitor_SSL_config" | "monitor_System_components" | "workSpace" | "invited_users" | "workSpace_users" | "team" | "team_member" | "alert" | "team_escalationpolicy" | "escalation_policy_rules" | "team_schedule" | "team_schedule_rotation" | "team_schedule_override" | "contactUs"
      txIsolationLevel: never
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      user_otp: {
        payload: Prisma.$user_otpPayload<ExtArgs>
        fields: Prisma.user_otpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.user_otpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_otpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.user_otpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_otpPayload>
          }
          findFirst: {
            args: Prisma.user_otpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_otpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.user_otpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_otpPayload>
          }
          findMany: {
            args: Prisma.user_otpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_otpPayload>[]
          }
          create: {
            args: Prisma.user_otpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_otpPayload>
          }
          createMany: {
            args: Prisma.user_otpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.user_otpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_otpPayload>
          }
          update: {
            args: Prisma.user_otpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_otpPayload>
          }
          deleteMany: {
            args: Prisma.user_otpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.user_otpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.user_otpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$user_otpPayload>
          }
          aggregate: {
            args: Prisma.User_otpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser_otp>
          }
          groupBy: {
            args: Prisma.user_otpGroupByArgs<ExtArgs>
            result: $Utils.Optional<User_otpGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.user_otpFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.user_otpAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.user_otpCountArgs<ExtArgs>
            result: $Utils.Optional<User_otpCountAggregateOutputType> | number
          }
        }
      }
      Monitor_config: {
        payload: Prisma.$Monitor_configPayload<ExtArgs>
        fields: Prisma.Monitor_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Monitor_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Monitor_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_configPayload>
          }
          findFirst: {
            args: Prisma.Monitor_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Monitor_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_configPayload>
          }
          findMany: {
            args: Prisma.Monitor_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_configPayload>[]
          }
          create: {
            args: Prisma.Monitor_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_configPayload>
          }
          createMany: {
            args: Prisma.Monitor_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Monitor_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_configPayload>
          }
          update: {
            args: Prisma.Monitor_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_configPayload>
          }
          deleteMany: {
            args: Prisma.Monitor_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Monitor_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Monitor_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_configPayload>
          }
          aggregate: {
            args: Prisma.Monitor_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonitor_config>
          }
          groupBy: {
            args: Prisma.Monitor_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<Monitor_configGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Monitor_configFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Monitor_configAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Monitor_configCountArgs<ExtArgs>
            result: $Utils.Optional<Monitor_configCountAggregateOutputType> | number
          }
        }
      }
      Monitor_HTTP_gPRC_config: {
        payload: Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs>
        fields: Prisma.Monitor_HTTP_gPRC_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Monitor_HTTP_gPRC_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_HTTP_gPRC_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Monitor_HTTP_gPRC_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_HTTP_gPRC_configPayload>
          }
          findFirst: {
            args: Prisma.Monitor_HTTP_gPRC_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_HTTP_gPRC_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Monitor_HTTP_gPRC_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_HTTP_gPRC_configPayload>
          }
          findMany: {
            args: Prisma.Monitor_HTTP_gPRC_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_HTTP_gPRC_configPayload>[]
          }
          create: {
            args: Prisma.Monitor_HTTP_gPRC_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_HTTP_gPRC_configPayload>
          }
          createMany: {
            args: Prisma.Monitor_HTTP_gPRC_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Monitor_HTTP_gPRC_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_HTTP_gPRC_configPayload>
          }
          update: {
            args: Prisma.Monitor_HTTP_gPRC_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_HTTP_gPRC_configPayload>
          }
          deleteMany: {
            args: Prisma.Monitor_HTTP_gPRC_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Monitor_HTTP_gPRC_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Monitor_HTTP_gPRC_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_HTTP_gPRC_configPayload>
          }
          aggregate: {
            args: Prisma.Monitor_HTTP_gPRC_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonitor_HTTP_gPRC_config>
          }
          groupBy: {
            args: Prisma.Monitor_HTTP_gPRC_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<Monitor_HTTP_gPRC_configGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Monitor_HTTP_gPRC_configFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Monitor_HTTP_gPRC_configAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Monitor_HTTP_gPRC_configCountArgs<ExtArgs>
            result: $Utils.Optional<Monitor_HTTP_gPRC_configCountAggregateOutputType> | number
          }
        }
      }
      Monitor_SSL_config: {
        payload: Prisma.$Monitor_SSL_configPayload<ExtArgs>
        fields: Prisma.Monitor_SSL_configFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Monitor_SSL_configFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_SSL_configPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Monitor_SSL_configFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_SSL_configPayload>
          }
          findFirst: {
            args: Prisma.Monitor_SSL_configFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_SSL_configPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Monitor_SSL_configFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_SSL_configPayload>
          }
          findMany: {
            args: Prisma.Monitor_SSL_configFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_SSL_configPayload>[]
          }
          create: {
            args: Prisma.Monitor_SSL_configCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_SSL_configPayload>
          }
          createMany: {
            args: Prisma.Monitor_SSL_configCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Monitor_SSL_configDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_SSL_configPayload>
          }
          update: {
            args: Prisma.Monitor_SSL_configUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_SSL_configPayload>
          }
          deleteMany: {
            args: Prisma.Monitor_SSL_configDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Monitor_SSL_configUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Monitor_SSL_configUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_SSL_configPayload>
          }
          aggregate: {
            args: Prisma.Monitor_SSL_configAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonitor_SSL_config>
          }
          groupBy: {
            args: Prisma.Monitor_SSL_configGroupByArgs<ExtArgs>
            result: $Utils.Optional<Monitor_SSL_configGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Monitor_SSL_configFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Monitor_SSL_configAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Monitor_SSL_configCountArgs<ExtArgs>
            result: $Utils.Optional<Monitor_SSL_configCountAggregateOutputType> | number
          }
        }
      }
      Monitor_System_components: {
        payload: Prisma.$Monitor_System_componentsPayload<ExtArgs>
        fields: Prisma.Monitor_System_componentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Monitor_System_componentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_System_componentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Monitor_System_componentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_System_componentsPayload>
          }
          findFirst: {
            args: Prisma.Monitor_System_componentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_System_componentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Monitor_System_componentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_System_componentsPayload>
          }
          findMany: {
            args: Prisma.Monitor_System_componentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_System_componentsPayload>[]
          }
          create: {
            args: Prisma.Monitor_System_componentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_System_componentsPayload>
          }
          createMany: {
            args: Prisma.Monitor_System_componentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.Monitor_System_componentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_System_componentsPayload>
          }
          update: {
            args: Prisma.Monitor_System_componentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_System_componentsPayload>
          }
          deleteMany: {
            args: Prisma.Monitor_System_componentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.Monitor_System_componentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.Monitor_System_componentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$Monitor_System_componentsPayload>
          }
          aggregate: {
            args: Prisma.Monitor_System_componentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMonitor_System_components>
          }
          groupBy: {
            args: Prisma.Monitor_System_componentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Monitor_System_componentsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.Monitor_System_componentsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.Monitor_System_componentsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.Monitor_System_componentsCountArgs<ExtArgs>
            result: $Utils.Optional<Monitor_System_componentsCountAggregateOutputType> | number
          }
        }
      }
      WorkSpace: {
        payload: Prisma.$WorkSpacePayload<ExtArgs>
        fields: Prisma.WorkSpaceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkSpaceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpacePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkSpaceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpacePayload>
          }
          findFirst: {
            args: Prisma.WorkSpaceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpacePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkSpaceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpacePayload>
          }
          findMany: {
            args: Prisma.WorkSpaceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpacePayload>[]
          }
          create: {
            args: Prisma.WorkSpaceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpacePayload>
          }
          createMany: {
            args: Prisma.WorkSpaceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WorkSpaceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpacePayload>
          }
          update: {
            args: Prisma.WorkSpaceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpacePayload>
          }
          deleteMany: {
            args: Prisma.WorkSpaceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkSpaceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkSpaceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpacePayload>
          }
          aggregate: {
            args: Prisma.WorkSpaceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkSpace>
          }
          groupBy: {
            args: Prisma.WorkSpaceGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkSpaceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.WorkSpaceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.WorkSpaceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.WorkSpaceCountArgs<ExtArgs>
            result: $Utils.Optional<WorkSpaceCountAggregateOutputType> | number
          }
        }
      }
      invited_users: {
        payload: Prisma.$invited_usersPayload<ExtArgs>
        fields: Prisma.invited_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.invited_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invited_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.invited_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invited_usersPayload>
          }
          findFirst: {
            args: Prisma.invited_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invited_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.invited_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invited_usersPayload>
          }
          findMany: {
            args: Prisma.invited_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invited_usersPayload>[]
          }
          create: {
            args: Prisma.invited_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invited_usersPayload>
          }
          createMany: {
            args: Prisma.invited_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.invited_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invited_usersPayload>
          }
          update: {
            args: Prisma.invited_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invited_usersPayload>
          }
          deleteMany: {
            args: Prisma.invited_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.invited_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.invited_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$invited_usersPayload>
          }
          aggregate: {
            args: Prisma.Invited_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvited_users>
          }
          groupBy: {
            args: Prisma.invited_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<Invited_usersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.invited_usersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.invited_usersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.invited_usersCountArgs<ExtArgs>
            result: $Utils.Optional<Invited_usersCountAggregateOutputType> | number
          }
        }
      }
      WorkSpace_users: {
        payload: Prisma.$WorkSpace_usersPayload<ExtArgs>
        fields: Prisma.WorkSpace_usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkSpace_usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpace_usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkSpace_usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpace_usersPayload>
          }
          findFirst: {
            args: Prisma.WorkSpace_usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpace_usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkSpace_usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpace_usersPayload>
          }
          findMany: {
            args: Prisma.WorkSpace_usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpace_usersPayload>[]
          }
          create: {
            args: Prisma.WorkSpace_usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpace_usersPayload>
          }
          createMany: {
            args: Prisma.WorkSpace_usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.WorkSpace_usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpace_usersPayload>
          }
          update: {
            args: Prisma.WorkSpace_usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpace_usersPayload>
          }
          deleteMany: {
            args: Prisma.WorkSpace_usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkSpace_usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.WorkSpace_usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkSpace_usersPayload>
          }
          aggregate: {
            args: Prisma.WorkSpace_usersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkSpace_users>
          }
          groupBy: {
            args: Prisma.WorkSpace_usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkSpace_usersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.WorkSpace_usersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.WorkSpace_usersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.WorkSpace_usersCountArgs<ExtArgs>
            result: $Utils.Optional<WorkSpace_usersCountAggregateOutputType> | number
          }
        }
      }
      team: {
        payload: Prisma.$teamPayload<ExtArgs>
        fields: Prisma.teamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.teamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.teamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          findFirst: {
            args: Prisma.teamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.teamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          findMany: {
            args: Prisma.teamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>[]
          }
          create: {
            args: Prisma.teamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          createMany: {
            args: Prisma.teamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.teamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          update: {
            args: Prisma.teamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          deleteMany: {
            args: Prisma.teamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.teamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.teamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$teamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.teamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.teamFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.teamAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.teamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      team_member: {
        payload: Prisma.$team_memberPayload<ExtArgs>
        fields: Prisma.team_memberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.team_memberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_memberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.team_memberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_memberPayload>
          }
          findFirst: {
            args: Prisma.team_memberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_memberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.team_memberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_memberPayload>
          }
          findMany: {
            args: Prisma.team_memberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_memberPayload>[]
          }
          create: {
            args: Prisma.team_memberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_memberPayload>
          }
          createMany: {
            args: Prisma.team_memberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.team_memberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_memberPayload>
          }
          update: {
            args: Prisma.team_memberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_memberPayload>
          }
          deleteMany: {
            args: Prisma.team_memberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.team_memberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.team_memberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_memberPayload>
          }
          aggregate: {
            args: Prisma.Team_memberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam_member>
          }
          groupBy: {
            args: Prisma.team_memberGroupByArgs<ExtArgs>
            result: $Utils.Optional<Team_memberGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.team_memberFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.team_memberAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.team_memberCountArgs<ExtArgs>
            result: $Utils.Optional<Team_memberCountAggregateOutputType> | number
          }
        }
      }
      alert: {
        payload: Prisma.$alertPayload<ExtArgs>
        fields: Prisma.alertFieldRefs
        operations: {
          findUnique: {
            args: Prisma.alertFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.alertFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          findFirst: {
            args: Prisma.alertFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.alertFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          findMany: {
            args: Prisma.alertFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>[]
          }
          create: {
            args: Prisma.alertCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          createMany: {
            args: Prisma.alertCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.alertDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          update: {
            args: Prisma.alertUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          deleteMany: {
            args: Prisma.alertDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.alertUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.alertUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$alertPayload>
          }
          aggregate: {
            args: Prisma.AlertAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAlert>
          }
          groupBy: {
            args: Prisma.alertGroupByArgs<ExtArgs>
            result: $Utils.Optional<AlertGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.alertFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.alertAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.alertCountArgs<ExtArgs>
            result: $Utils.Optional<AlertCountAggregateOutputType> | number
          }
        }
      }
      team_escalationpolicy: {
        payload: Prisma.$team_escalationpolicyPayload<ExtArgs>
        fields: Prisma.team_escalationpolicyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.team_escalationpolicyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_escalationpolicyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.team_escalationpolicyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_escalationpolicyPayload>
          }
          findFirst: {
            args: Prisma.team_escalationpolicyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_escalationpolicyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.team_escalationpolicyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_escalationpolicyPayload>
          }
          findMany: {
            args: Prisma.team_escalationpolicyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_escalationpolicyPayload>[]
          }
          create: {
            args: Prisma.team_escalationpolicyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_escalationpolicyPayload>
          }
          createMany: {
            args: Prisma.team_escalationpolicyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.team_escalationpolicyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_escalationpolicyPayload>
          }
          update: {
            args: Prisma.team_escalationpolicyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_escalationpolicyPayload>
          }
          deleteMany: {
            args: Prisma.team_escalationpolicyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.team_escalationpolicyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.team_escalationpolicyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_escalationpolicyPayload>
          }
          aggregate: {
            args: Prisma.Team_escalationpolicyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam_escalationpolicy>
          }
          groupBy: {
            args: Prisma.team_escalationpolicyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Team_escalationpolicyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.team_escalationpolicyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.team_escalationpolicyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.team_escalationpolicyCountArgs<ExtArgs>
            result: $Utils.Optional<Team_escalationpolicyCountAggregateOutputType> | number
          }
        }
      }
      escalation_policy_rules: {
        payload: Prisma.$escalation_policy_rulesPayload<ExtArgs>
        fields: Prisma.escalation_policy_rulesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.escalation_policy_rulesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escalation_policy_rulesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.escalation_policy_rulesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escalation_policy_rulesPayload>
          }
          findFirst: {
            args: Prisma.escalation_policy_rulesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escalation_policy_rulesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.escalation_policy_rulesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escalation_policy_rulesPayload>
          }
          findMany: {
            args: Prisma.escalation_policy_rulesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escalation_policy_rulesPayload>[]
          }
          create: {
            args: Prisma.escalation_policy_rulesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escalation_policy_rulesPayload>
          }
          createMany: {
            args: Prisma.escalation_policy_rulesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.escalation_policy_rulesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escalation_policy_rulesPayload>
          }
          update: {
            args: Prisma.escalation_policy_rulesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escalation_policy_rulesPayload>
          }
          deleteMany: {
            args: Prisma.escalation_policy_rulesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.escalation_policy_rulesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.escalation_policy_rulesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$escalation_policy_rulesPayload>
          }
          aggregate: {
            args: Prisma.Escalation_policy_rulesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEscalation_policy_rules>
          }
          groupBy: {
            args: Prisma.escalation_policy_rulesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Escalation_policy_rulesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.escalation_policy_rulesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.escalation_policy_rulesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.escalation_policy_rulesCountArgs<ExtArgs>
            result: $Utils.Optional<Escalation_policy_rulesCountAggregateOutputType> | number
          }
        }
      }
      team_schedule: {
        payload: Prisma.$team_schedulePayload<ExtArgs>
        fields: Prisma.team_scheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.team_scheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.team_scheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedulePayload>
          }
          findFirst: {
            args: Prisma.team_scheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.team_scheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedulePayload>
          }
          findMany: {
            args: Prisma.team_scheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedulePayload>[]
          }
          create: {
            args: Prisma.team_scheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedulePayload>
          }
          createMany: {
            args: Prisma.team_scheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.team_scheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedulePayload>
          }
          update: {
            args: Prisma.team_scheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedulePayload>
          }
          deleteMany: {
            args: Prisma.team_scheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.team_scheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.team_scheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedulePayload>
          }
          aggregate: {
            args: Prisma.Team_scheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam_schedule>
          }
          groupBy: {
            args: Prisma.team_scheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<Team_scheduleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.team_scheduleFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.team_scheduleAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.team_scheduleCountArgs<ExtArgs>
            result: $Utils.Optional<Team_scheduleCountAggregateOutputType> | number
          }
        }
      }
      team_schedule_rotation: {
        payload: Prisma.$team_schedule_rotationPayload<ExtArgs>
        fields: Prisma.team_schedule_rotationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.team_schedule_rotationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_rotationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.team_schedule_rotationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_rotationPayload>
          }
          findFirst: {
            args: Prisma.team_schedule_rotationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_rotationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.team_schedule_rotationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_rotationPayload>
          }
          findMany: {
            args: Prisma.team_schedule_rotationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_rotationPayload>[]
          }
          create: {
            args: Prisma.team_schedule_rotationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_rotationPayload>
          }
          createMany: {
            args: Prisma.team_schedule_rotationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.team_schedule_rotationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_rotationPayload>
          }
          update: {
            args: Prisma.team_schedule_rotationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_rotationPayload>
          }
          deleteMany: {
            args: Prisma.team_schedule_rotationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.team_schedule_rotationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.team_schedule_rotationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_rotationPayload>
          }
          aggregate: {
            args: Prisma.Team_schedule_rotationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam_schedule_rotation>
          }
          groupBy: {
            args: Prisma.team_schedule_rotationGroupByArgs<ExtArgs>
            result: $Utils.Optional<Team_schedule_rotationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.team_schedule_rotationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.team_schedule_rotationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.team_schedule_rotationCountArgs<ExtArgs>
            result: $Utils.Optional<Team_schedule_rotationCountAggregateOutputType> | number
          }
        }
      }
      team_schedule_override: {
        payload: Prisma.$team_schedule_overridePayload<ExtArgs>
        fields: Prisma.team_schedule_overrideFieldRefs
        operations: {
          findUnique: {
            args: Prisma.team_schedule_overrideFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_overridePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.team_schedule_overrideFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_overridePayload>
          }
          findFirst: {
            args: Prisma.team_schedule_overrideFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_overridePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.team_schedule_overrideFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_overridePayload>
          }
          findMany: {
            args: Prisma.team_schedule_overrideFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_overridePayload>[]
          }
          create: {
            args: Prisma.team_schedule_overrideCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_overridePayload>
          }
          createMany: {
            args: Prisma.team_schedule_overrideCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.team_schedule_overrideDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_overridePayload>
          }
          update: {
            args: Prisma.team_schedule_overrideUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_overridePayload>
          }
          deleteMany: {
            args: Prisma.team_schedule_overrideDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.team_schedule_overrideUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.team_schedule_overrideUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$team_schedule_overridePayload>
          }
          aggregate: {
            args: Prisma.Team_schedule_overrideAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam_schedule_override>
          }
          groupBy: {
            args: Prisma.team_schedule_overrideGroupByArgs<ExtArgs>
            result: $Utils.Optional<Team_schedule_overrideGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.team_schedule_overrideFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.team_schedule_overrideAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.team_schedule_overrideCountArgs<ExtArgs>
            result: $Utils.Optional<Team_schedule_overrideCountAggregateOutputType> | number
          }
        }
      }
      contactUs: {
        payload: Prisma.$contactUsPayload<ExtArgs>
        fields: Prisma.contactUsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.contactUsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactUsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.contactUsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactUsPayload>
          }
          findFirst: {
            args: Prisma.contactUsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactUsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.contactUsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactUsPayload>
          }
          findMany: {
            args: Prisma.contactUsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactUsPayload>[]
          }
          create: {
            args: Prisma.contactUsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactUsPayload>
          }
          createMany: {
            args: Prisma.contactUsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.contactUsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactUsPayload>
          }
          update: {
            args: Prisma.contactUsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactUsPayload>
          }
          deleteMany: {
            args: Prisma.contactUsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.contactUsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.contactUsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$contactUsPayload>
          }
          aggregate: {
            args: Prisma.ContactUsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContactUs>
          }
          groupBy: {
            args: Prisma.contactUsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContactUsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.contactUsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.contactUsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.contactUsCountArgs<ExtArgs>
            result: $Utils.Optional<ContactUsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    Monitor_config: number
    workspace: number
    workspace_users: number
    teams: number
    alert: number
    escalation_policy_rules: number
    user_otp: number
    team_schedule_rotation: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Monitor_config?: boolean | UserCountOutputTypeCountMonitor_configArgs
    workspace?: boolean | UserCountOutputTypeCountWorkspaceArgs
    workspace_users?: boolean | UserCountOutputTypeCountWorkspace_usersArgs
    teams?: boolean | UserCountOutputTypeCountTeamsArgs
    alert?: boolean | UserCountOutputTypeCountAlertArgs
    escalation_policy_rules?: boolean | UserCountOutputTypeCountEscalation_policy_rulesArgs
    user_otp?: boolean | UserCountOutputTypeCountUser_otpArgs
    team_schedule_rotation?: boolean | UserCountOutputTypeCountTeam_schedule_rotationArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMonitor_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Monitor_configWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkSpaceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountWorkspace_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkSpace_usersWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEscalation_policy_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: escalation_policy_rulesWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountUser_otpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_otpWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeam_schedule_rotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_schedule_rotationWhereInput
  }


  /**
   * Count Type Monitor_configCountOutputType
   */

  export type Monitor_configCountOutputType = {
    alert: number
  }

  export type Monitor_configCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    alert?: boolean | Monitor_configCountOutputTypeCountAlertArgs
  }

  // Custom InputTypes
  /**
   * Monitor_configCountOutputType without action
   */
  export type Monitor_configCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_configCountOutputType
     */
    select?: Monitor_configCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Monitor_configCountOutputType without action
   */
  export type Monitor_configCountOutputTypeCountAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertWhereInput
  }


  /**
   * Count Type WorkSpaceCountOutputType
   */

  export type WorkSpaceCountOutputType = {
    monitor_config: number
    workspace_users: number
    invited_users: number
    team: number
    team_member: number
    alert: number
  }

  export type WorkSpaceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monitor_config?: boolean | WorkSpaceCountOutputTypeCountMonitor_configArgs
    workspace_users?: boolean | WorkSpaceCountOutputTypeCountWorkspace_usersArgs
    invited_users?: boolean | WorkSpaceCountOutputTypeCountInvited_usersArgs
    team?: boolean | WorkSpaceCountOutputTypeCountTeamArgs
    team_member?: boolean | WorkSpaceCountOutputTypeCountTeam_memberArgs
    alert?: boolean | WorkSpaceCountOutputTypeCountAlertArgs
  }

  // Custom InputTypes
  /**
   * WorkSpaceCountOutputType without action
   */
  export type WorkSpaceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpaceCountOutputType
     */
    select?: WorkSpaceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkSpaceCountOutputType without action
   */
  export type WorkSpaceCountOutputTypeCountMonitor_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Monitor_configWhereInput
  }

  /**
   * WorkSpaceCountOutputType without action
   */
  export type WorkSpaceCountOutputTypeCountWorkspace_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkSpace_usersWhereInput
  }

  /**
   * WorkSpaceCountOutputType without action
   */
  export type WorkSpaceCountOutputTypeCountInvited_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invited_usersWhereInput
  }

  /**
   * WorkSpaceCountOutputType without action
   */
  export type WorkSpaceCountOutputTypeCountTeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
  }

  /**
   * WorkSpaceCountOutputType without action
   */
  export type WorkSpaceCountOutputTypeCountTeam_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_memberWhereInput
  }

  /**
   * WorkSpaceCountOutputType without action
   */
  export type WorkSpaceCountOutputTypeCountAlertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertWhereInput
  }


  /**
   * Count Type WorkSpace_usersCountOutputType
   */

  export type WorkSpace_usersCountOutputType = {
    team_member: number
  }

  export type WorkSpace_usersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team_member?: boolean | WorkSpace_usersCountOutputTypeCountTeam_memberArgs
  }

  // Custom InputTypes
  /**
   * WorkSpace_usersCountOutputType without action
   */
  export type WorkSpace_usersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_usersCountOutputType
     */
    select?: WorkSpace_usersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * WorkSpace_usersCountOutputType without action
   */
  export type WorkSpace_usersCountOutputTypeCountTeam_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_memberWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    team_member: number
    monitor_config: number
    team_escalationpolicy: number
    escalation_policy_rules: number
    team_schedule: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team_member?: boolean | TeamCountOutputTypeCountTeam_memberArgs
    monitor_config?: boolean | TeamCountOutputTypeCountMonitor_configArgs
    team_escalationpolicy?: boolean | TeamCountOutputTypeCountTeam_escalationpolicyArgs
    escalation_policy_rules?: boolean | TeamCountOutputTypeCountEscalation_policy_rulesArgs
    team_schedule?: boolean | TeamCountOutputTypeCountTeam_scheduleArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeam_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_memberWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMonitor_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Monitor_configWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeam_escalationpolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_escalationpolicyWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountEscalation_policy_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: escalation_policy_rulesWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountTeam_scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_scheduleWhereInput
  }


  /**
   * Count Type Team_escalationpolicyCountOutputType
   */

  export type Team_escalationpolicyCountOutputType = {
    escalation_policy_rules: number
  }

  export type Team_escalationpolicyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    escalation_policy_rules?: boolean | Team_escalationpolicyCountOutputTypeCountEscalation_policy_rulesArgs
  }

  // Custom InputTypes
  /**
   * Team_escalationpolicyCountOutputType without action
   */
  export type Team_escalationpolicyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team_escalationpolicyCountOutputType
     */
    select?: Team_escalationpolicyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Team_escalationpolicyCountOutputType without action
   */
  export type Team_escalationpolicyCountOutputTypeCountEscalation_policy_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: escalation_policy_rulesWhereInput
  }


  /**
   * Count Type Team_scheduleCountOutputType
   */

  export type Team_scheduleCountOutputType = {
    team_schedule_rotation: number
    team_schedule_override: number
  }

  export type Team_scheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team_schedule_rotation?: boolean | Team_scheduleCountOutputTypeCountTeam_schedule_rotationArgs
    team_schedule_override?: boolean | Team_scheduleCountOutputTypeCountTeam_schedule_overrideArgs
  }

  // Custom InputTypes
  /**
   * Team_scheduleCountOutputType without action
   */
  export type Team_scheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team_scheduleCountOutputType
     */
    select?: Team_scheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Team_scheduleCountOutputType without action
   */
  export type Team_scheduleCountOutputTypeCountTeam_schedule_rotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_schedule_rotationWhereInput
  }

  /**
   * Team_scheduleCountOutputType without action
   */
  export type Team_scheduleCountOutputTypeCountTeam_schedule_overrideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_schedule_overrideWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    supaId: string | null
    name: string | null
    email: string | null
    number: string | null
    photo: string | null
    is_phone_number_verified: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    supaId: string | null
    name: string | null
    email: string | null
    number: string | null
    photo: string | null
    is_phone_number_verified: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    supaId: number
    name: number
    email: number
    number: number
    photo: number
    is_phone_number_verified: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    supaId?: true
    name?: true
    email?: true
    number?: true
    photo?: true
    is_phone_number_verified?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    supaId?: true
    name?: true
    email?: true
    number?: true
    photo?: true
    is_phone_number_verified?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    supaId?: true
    name?: true
    email?: true
    number?: true
    photo?: true
    is_phone_number_verified?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    supaId: string
    name: string
    email: string
    number: string | null
    photo: string | null
    is_phone_number_verified: boolean
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supaId?: boolean
    name?: boolean
    email?: boolean
    number?: boolean
    photo?: boolean
    is_phone_number_verified?: boolean
    Monitor_config?: boolean | User$Monitor_configArgs<ExtArgs>
    workspace?: boolean | User$workspaceArgs<ExtArgs>
    workspace_users?: boolean | User$workspace_usersArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    alert?: boolean | User$alertArgs<ExtArgs>
    escalation_policy_rules?: boolean | User$escalation_policy_rulesArgs<ExtArgs>
    user_otp?: boolean | User$user_otpArgs<ExtArgs>
    team_schedule_rotation?: boolean | User$team_schedule_rotationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    supaId?: boolean
    name?: boolean
    email?: boolean
    number?: boolean
    photo?: boolean
    is_phone_number_verified?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Monitor_config?: boolean | User$Monitor_configArgs<ExtArgs>
    workspace?: boolean | User$workspaceArgs<ExtArgs>
    workspace_users?: boolean | User$workspace_usersArgs<ExtArgs>
    teams?: boolean | User$teamsArgs<ExtArgs>
    alert?: boolean | User$alertArgs<ExtArgs>
    escalation_policy_rules?: boolean | User$escalation_policy_rulesArgs<ExtArgs>
    user_otp?: boolean | User$user_otpArgs<ExtArgs>
    team_schedule_rotation?: boolean | User$team_schedule_rotationArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      Monitor_config: Prisma.$Monitor_configPayload<ExtArgs>[]
      workspace: Prisma.$WorkSpacePayload<ExtArgs>[]
      workspace_users: Prisma.$WorkSpace_usersPayload<ExtArgs>[]
      teams: Prisma.$teamPayload<ExtArgs>[]
      alert: Prisma.$alertPayload<ExtArgs>[]
      escalation_policy_rules: Prisma.$escalation_policy_rulesPayload<ExtArgs>[]
      user_otp: Prisma.$user_otpPayload<ExtArgs>[]
      team_schedule_rotation: Prisma.$team_schedule_rotationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      supaId: string
      name: string
      email: string
      number: string | null
      photo: string | null
      is_phone_number_verified: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Monitor_config<T extends User$Monitor_configArgs<ExtArgs> = {}>(args?: Subset<T, User$Monitor_configArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findMany"> | Null>
    workspace<T extends User$workspaceArgs<ExtArgs> = {}>(args?: Subset<T, User$workspaceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findMany"> | Null>
    workspace_users<T extends User$workspace_usersArgs<ExtArgs> = {}>(args?: Subset<T, User$workspace_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "findMany"> | Null>
    teams<T extends User$teamsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findMany"> | Null>
    alert<T extends User$alertArgs<ExtArgs> = {}>(args?: Subset<T, User$alertArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findMany"> | Null>
    escalation_policy_rules<T extends User$escalation_policy_rulesArgs<ExtArgs> = {}>(args?: Subset<T, User$escalation_policy_rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "findMany"> | Null>
    user_otp<T extends User$user_otpArgs<ExtArgs> = {}>(args?: Subset<T, User$user_otpArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_otpPayload<ExtArgs>, T, "findMany"> | Null>
    team_schedule_rotation<T extends User$team_schedule_rotationArgs<ExtArgs> = {}>(args?: Subset<T, User$team_schedule_rotationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_schedule_rotationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly supaId: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly number: FieldRef<"User", 'String'>
    readonly photo: FieldRef<"User", 'String'>
    readonly is_phone_number_verified: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.Monitor_config
   */
  export type User$Monitor_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    where?: Monitor_configWhereInput
    orderBy?: Monitor_configOrderByWithRelationInput | Monitor_configOrderByWithRelationInput[]
    cursor?: Monitor_configWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Monitor_configScalarFieldEnum | Monitor_configScalarFieldEnum[]
  }

  /**
   * User.workspace
   */
  export type User$workspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
    where?: WorkSpaceWhereInput
    orderBy?: WorkSpaceOrderByWithRelationInput | WorkSpaceOrderByWithRelationInput[]
    cursor?: WorkSpaceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkSpaceScalarFieldEnum | WorkSpaceScalarFieldEnum[]
  }

  /**
   * User.workspace_users
   */
  export type User$workspace_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
    where?: WorkSpace_usersWhereInput
    orderBy?: WorkSpace_usersOrderByWithRelationInput | WorkSpace_usersOrderByWithRelationInput[]
    cursor?: WorkSpace_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkSpace_usersScalarFieldEnum | WorkSpace_usersScalarFieldEnum[]
  }

  /**
   * User.teams
   */
  export type User$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    cursor?: teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.alert
   */
  export type User$alertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    where?: alertWhereInput
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    cursor?: alertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * User.escalation_policy_rules
   */
  export type User$escalation_policy_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    where?: escalation_policy_rulesWhereInput
    orderBy?: escalation_policy_rulesOrderByWithRelationInput | escalation_policy_rulesOrderByWithRelationInput[]
    cursor?: escalation_policy_rulesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Escalation_policy_rulesScalarFieldEnum | Escalation_policy_rulesScalarFieldEnum[]
  }

  /**
   * User.user_otp
   */
  export type User$user_otpArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_otp
     */
    select?: user_otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_otpInclude<ExtArgs> | null
    where?: user_otpWhereInput
    orderBy?: user_otpOrderByWithRelationInput | user_otpOrderByWithRelationInput[]
    cursor?: user_otpWhereUniqueInput
    take?: number
    skip?: number
    distinct?: User_otpScalarFieldEnum | User_otpScalarFieldEnum[]
  }

  /**
   * User.team_schedule_rotation
   */
  export type User$team_schedule_rotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
    where?: team_schedule_rotationWhereInput
    orderBy?: team_schedule_rotationOrderByWithRelationInput | team_schedule_rotationOrderByWithRelationInput[]
    cursor?: team_schedule_rotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_schedule_rotationScalarFieldEnum | Team_schedule_rotationScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model user_otp
   */

  export type AggregateUser_otp = {
    _count: User_otpCountAggregateOutputType | null
    _avg: User_otpAvgAggregateOutputType | null
    _sum: User_otpSumAggregateOutputType | null
    _min: User_otpMinAggregateOutputType | null
    _max: User_otpMaxAggregateOutputType | null
  }

  export type User_otpAvgAggregateOutputType = {
    expiresAt: number | null
  }

  export type User_otpSumAggregateOutputType = {
    expiresAt: number | null
  }

  export type User_otpMinAggregateOutputType = {
    id: string | null
    userId: string | null
    otp: string | null
    invalid: boolean | null
    expiresAt: number | null
    createdAt: Date | null
  }

  export type User_otpMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    otp: string | null
    invalid: boolean | null
    expiresAt: number | null
    createdAt: Date | null
  }

  export type User_otpCountAggregateOutputType = {
    id: number
    userId: number
    otp: number
    invalid: number
    expiresAt: number
    createdAt: number
    _all: number
  }


  export type User_otpAvgAggregateInputType = {
    expiresAt?: true
  }

  export type User_otpSumAggregateInputType = {
    expiresAt?: true
  }

  export type User_otpMinAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    invalid?: true
    expiresAt?: true
    createdAt?: true
  }

  export type User_otpMaxAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    invalid?: true
    expiresAt?: true
    createdAt?: true
  }

  export type User_otpCountAggregateInputType = {
    id?: true
    userId?: true
    otp?: true
    invalid?: true
    expiresAt?: true
    createdAt?: true
    _all?: true
  }

  export type User_otpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_otp to aggregate.
     */
    where?: user_otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_otps to fetch.
     */
    orderBy?: user_otpOrderByWithRelationInput | user_otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: user_otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned user_otps
    **/
    _count?: true | User_otpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: User_otpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: User_otpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: User_otpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: User_otpMaxAggregateInputType
  }

  export type GetUser_otpAggregateType<T extends User_otpAggregateArgs> = {
        [P in keyof T & keyof AggregateUser_otp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser_otp[P]>
      : GetScalarType<T[P], AggregateUser_otp[P]>
  }




  export type user_otpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: user_otpWhereInput
    orderBy?: user_otpOrderByWithAggregationInput | user_otpOrderByWithAggregationInput[]
    by: User_otpScalarFieldEnum[] | User_otpScalarFieldEnum
    having?: user_otpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: User_otpCountAggregateInputType | true
    _avg?: User_otpAvgAggregateInputType
    _sum?: User_otpSumAggregateInputType
    _min?: User_otpMinAggregateInputType
    _max?: User_otpMaxAggregateInputType
  }

  export type User_otpGroupByOutputType = {
    id: string
    userId: string
    otp: string
    invalid: boolean
    expiresAt: number
    createdAt: Date
    _count: User_otpCountAggregateOutputType | null
    _avg: User_otpAvgAggregateOutputType | null
    _sum: User_otpSumAggregateOutputType | null
    _min: User_otpMinAggregateOutputType | null
    _max: User_otpMaxAggregateOutputType | null
  }

  type GetUser_otpGroupByPayload<T extends user_otpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<User_otpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof User_otpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], User_otpGroupByOutputType[P]>
            : GetScalarType<T[P], User_otpGroupByOutputType[P]>
        }
      >
    >


  export type user_otpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    otp?: boolean
    invalid?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user_otp"]>


  export type user_otpSelectScalar = {
    id?: boolean
    userId?: boolean
    otp?: boolean
    invalid?: boolean
    expiresAt?: boolean
    createdAt?: boolean
  }

  export type user_otpInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $user_otpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "user_otp"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      otp: string
      invalid: boolean
      expiresAt: number
      createdAt: Date
    }, ExtArgs["result"]["user_otp"]>
    composites: {}
  }

  type user_otpGetPayload<S extends boolean | null | undefined | user_otpDefaultArgs> = $Result.GetResult<Prisma.$user_otpPayload, S>

  type user_otpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<user_otpFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: User_otpCountAggregateInputType | true
    }

  export interface user_otpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['user_otp'], meta: { name: 'user_otp' } }
    /**
     * Find zero or one User_otp that matches the filter.
     * @param {user_otpFindUniqueArgs} args - Arguments to find a User_otp
     * @example
     * // Get one User_otp
     * const user_otp = await prisma.user_otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends user_otpFindUniqueArgs>(args: SelectSubset<T, user_otpFindUniqueArgs<ExtArgs>>): Prisma__user_otpClient<$Result.GetResult<Prisma.$user_otpPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User_otp that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {user_otpFindUniqueOrThrowArgs} args - Arguments to find a User_otp
     * @example
     * // Get one User_otp
     * const user_otp = await prisma.user_otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends user_otpFindUniqueOrThrowArgs>(args: SelectSubset<T, user_otpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__user_otpClient<$Result.GetResult<Prisma.$user_otpPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User_otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_otpFindFirstArgs} args - Arguments to find a User_otp
     * @example
     * // Get one User_otp
     * const user_otp = await prisma.user_otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends user_otpFindFirstArgs>(args?: SelectSubset<T, user_otpFindFirstArgs<ExtArgs>>): Prisma__user_otpClient<$Result.GetResult<Prisma.$user_otpPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User_otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_otpFindFirstOrThrowArgs} args - Arguments to find a User_otp
     * @example
     * // Get one User_otp
     * const user_otp = await prisma.user_otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends user_otpFindFirstOrThrowArgs>(args?: SelectSubset<T, user_otpFindFirstOrThrowArgs<ExtArgs>>): Prisma__user_otpClient<$Result.GetResult<Prisma.$user_otpPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more User_otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_otpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all User_otps
     * const user_otps = await prisma.user_otp.findMany()
     * 
     * // Get first 10 User_otps
     * const user_otps = await prisma.user_otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const user_otpWithIdOnly = await prisma.user_otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends user_otpFindManyArgs>(args?: SelectSubset<T, user_otpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$user_otpPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User_otp.
     * @param {user_otpCreateArgs} args - Arguments to create a User_otp.
     * @example
     * // Create one User_otp
     * const User_otp = await prisma.user_otp.create({
     *   data: {
     *     // ... data to create a User_otp
     *   }
     * })
     * 
     */
    create<T extends user_otpCreateArgs>(args: SelectSubset<T, user_otpCreateArgs<ExtArgs>>): Prisma__user_otpClient<$Result.GetResult<Prisma.$user_otpPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many User_otps.
     * @param {user_otpCreateManyArgs} args - Arguments to create many User_otps.
     * @example
     * // Create many User_otps
     * const user_otp = await prisma.user_otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends user_otpCreateManyArgs>(args?: SelectSubset<T, user_otpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User_otp.
     * @param {user_otpDeleteArgs} args - Arguments to delete one User_otp.
     * @example
     * // Delete one User_otp
     * const User_otp = await prisma.user_otp.delete({
     *   where: {
     *     // ... filter to delete one User_otp
     *   }
     * })
     * 
     */
    delete<T extends user_otpDeleteArgs>(args: SelectSubset<T, user_otpDeleteArgs<ExtArgs>>): Prisma__user_otpClient<$Result.GetResult<Prisma.$user_otpPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User_otp.
     * @param {user_otpUpdateArgs} args - Arguments to update one User_otp.
     * @example
     * // Update one User_otp
     * const user_otp = await prisma.user_otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends user_otpUpdateArgs>(args: SelectSubset<T, user_otpUpdateArgs<ExtArgs>>): Prisma__user_otpClient<$Result.GetResult<Prisma.$user_otpPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more User_otps.
     * @param {user_otpDeleteManyArgs} args - Arguments to filter User_otps to delete.
     * @example
     * // Delete a few User_otps
     * const { count } = await prisma.user_otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends user_otpDeleteManyArgs>(args?: SelectSubset<T, user_otpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more User_otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_otpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many User_otps
     * const user_otp = await prisma.user_otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends user_otpUpdateManyArgs>(args: SelectSubset<T, user_otpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User_otp.
     * @param {user_otpUpsertArgs} args - Arguments to update or create a User_otp.
     * @example
     * // Update or create a User_otp
     * const user_otp = await prisma.user_otp.upsert({
     *   create: {
     *     // ... data to create a User_otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User_otp we want to update
     *   }
     * })
     */
    upsert<T extends user_otpUpsertArgs>(args: SelectSubset<T, user_otpUpsertArgs<ExtArgs>>): Prisma__user_otpClient<$Result.GetResult<Prisma.$user_otpPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more User_otps that matches the filter.
     * @param {user_otpFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user_otp = await prisma.user_otp.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: user_otpFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User_otp.
     * @param {user_otpAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user_otp = await prisma.user_otp.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: user_otpAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of User_otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_otpCountArgs} args - Arguments to filter User_otps to count.
     * @example
     * // Count the number of User_otps
     * const count = await prisma.user_otp.count({
     *   where: {
     *     // ... the filter for the User_otps we want to count
     *   }
     * })
    **/
    count<T extends user_otpCountArgs>(
      args?: Subset<T, user_otpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], User_otpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User_otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {User_otpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends User_otpAggregateArgs>(args: Subset<T, User_otpAggregateArgs>): Prisma.PrismaPromise<GetUser_otpAggregateType<T>>

    /**
     * Group by User_otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {user_otpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends user_otpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: user_otpGroupByArgs['orderBy'] }
        : { orderBy?: user_otpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, user_otpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUser_otpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the user_otp model
   */
  readonly fields: user_otpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for user_otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__user_otpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the user_otp model
   */ 
  interface user_otpFieldRefs {
    readonly id: FieldRef<"user_otp", 'String'>
    readonly userId: FieldRef<"user_otp", 'String'>
    readonly otp: FieldRef<"user_otp", 'String'>
    readonly invalid: FieldRef<"user_otp", 'Boolean'>
    readonly expiresAt: FieldRef<"user_otp", 'Int'>
    readonly createdAt: FieldRef<"user_otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * user_otp findUnique
   */
  export type user_otpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_otp
     */
    select?: user_otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_otpInclude<ExtArgs> | null
    /**
     * Filter, which user_otp to fetch.
     */
    where: user_otpWhereUniqueInput
  }

  /**
   * user_otp findUniqueOrThrow
   */
  export type user_otpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_otp
     */
    select?: user_otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_otpInclude<ExtArgs> | null
    /**
     * Filter, which user_otp to fetch.
     */
    where: user_otpWhereUniqueInput
  }

  /**
   * user_otp findFirst
   */
  export type user_otpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_otp
     */
    select?: user_otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_otpInclude<ExtArgs> | null
    /**
     * Filter, which user_otp to fetch.
     */
    where?: user_otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_otps to fetch.
     */
    orderBy?: user_otpOrderByWithRelationInput | user_otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_otps.
     */
    cursor?: user_otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_otps.
     */
    distinct?: User_otpScalarFieldEnum | User_otpScalarFieldEnum[]
  }

  /**
   * user_otp findFirstOrThrow
   */
  export type user_otpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_otp
     */
    select?: user_otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_otpInclude<ExtArgs> | null
    /**
     * Filter, which user_otp to fetch.
     */
    where?: user_otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_otps to fetch.
     */
    orderBy?: user_otpOrderByWithRelationInput | user_otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for user_otps.
     */
    cursor?: user_otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of user_otps.
     */
    distinct?: User_otpScalarFieldEnum | User_otpScalarFieldEnum[]
  }

  /**
   * user_otp findMany
   */
  export type user_otpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_otp
     */
    select?: user_otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_otpInclude<ExtArgs> | null
    /**
     * Filter, which user_otps to fetch.
     */
    where?: user_otpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of user_otps to fetch.
     */
    orderBy?: user_otpOrderByWithRelationInput | user_otpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing user_otps.
     */
    cursor?: user_otpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` user_otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` user_otps.
     */
    skip?: number
    distinct?: User_otpScalarFieldEnum | User_otpScalarFieldEnum[]
  }

  /**
   * user_otp create
   */
  export type user_otpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_otp
     */
    select?: user_otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_otpInclude<ExtArgs> | null
    /**
     * The data needed to create a user_otp.
     */
    data: XOR<user_otpCreateInput, user_otpUncheckedCreateInput>
  }

  /**
   * user_otp createMany
   */
  export type user_otpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many user_otps.
     */
    data: user_otpCreateManyInput | user_otpCreateManyInput[]
  }

  /**
   * user_otp update
   */
  export type user_otpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_otp
     */
    select?: user_otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_otpInclude<ExtArgs> | null
    /**
     * The data needed to update a user_otp.
     */
    data: XOR<user_otpUpdateInput, user_otpUncheckedUpdateInput>
    /**
     * Choose, which user_otp to update.
     */
    where: user_otpWhereUniqueInput
  }

  /**
   * user_otp updateMany
   */
  export type user_otpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update user_otps.
     */
    data: XOR<user_otpUpdateManyMutationInput, user_otpUncheckedUpdateManyInput>
    /**
     * Filter which user_otps to update
     */
    where?: user_otpWhereInput
  }

  /**
   * user_otp upsert
   */
  export type user_otpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_otp
     */
    select?: user_otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_otpInclude<ExtArgs> | null
    /**
     * The filter to search for the user_otp to update in case it exists.
     */
    where: user_otpWhereUniqueInput
    /**
     * In case the user_otp found by the `where` argument doesn't exist, create a new user_otp with this data.
     */
    create: XOR<user_otpCreateInput, user_otpUncheckedCreateInput>
    /**
     * In case the user_otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<user_otpUpdateInput, user_otpUncheckedUpdateInput>
  }

  /**
   * user_otp delete
   */
  export type user_otpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_otp
     */
    select?: user_otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_otpInclude<ExtArgs> | null
    /**
     * Filter which user_otp to delete.
     */
    where: user_otpWhereUniqueInput
  }

  /**
   * user_otp deleteMany
   */
  export type user_otpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which user_otps to delete
     */
    where?: user_otpWhereInput
  }

  /**
   * user_otp findRaw
   */
  export type user_otpFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * user_otp aggregateRaw
   */
  export type user_otpAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * user_otp without action
   */
  export type user_otpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the user_otp
     */
    select?: user_otpSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: user_otpInclude<ExtArgs> | null
  }


  /**
   * Model Monitor_config
   */

  export type AggregateMonitor_config = {
    _count: Monitor_configCountAggregateOutputType | null
    _min: Monitor_configMinAggregateOutputType | null
    _max: Monitor_configMaxAggregateOutputType | null
  }

  export type Monitor_configMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    monitorType: string | null
    is_active: boolean | null
    workspaceId: string | null
    teamId: string | null
    createdAt: Date | null
  }

  export type Monitor_configMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    monitorType: string | null
    is_active: boolean | null
    workspaceId: string | null
    teamId: string | null
    createdAt: Date | null
  }

  export type Monitor_configCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    monitorType: number
    is_active: number
    workspaceId: number
    teamId: number
    createdAt: number
    _all: number
  }


  export type Monitor_configMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    monitorType?: true
    is_active?: true
    workspaceId?: true
    teamId?: true
    createdAt?: true
  }

  export type Monitor_configMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    monitorType?: true
    is_active?: true
    workspaceId?: true
    teamId?: true
    createdAt?: true
  }

  export type Monitor_configCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    monitorType?: true
    is_active?: true
    workspaceId?: true
    teamId?: true
    createdAt?: true
    _all?: true
  }

  export type Monitor_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitor_config to aggregate.
     */
    where?: Monitor_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_configs to fetch.
     */
    orderBy?: Monitor_configOrderByWithRelationInput | Monitor_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Monitor_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Monitor_configs
    **/
    _count?: true | Monitor_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monitor_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monitor_configMaxAggregateInputType
  }

  export type GetMonitor_configAggregateType<T extends Monitor_configAggregateArgs> = {
        [P in keyof T & keyof AggregateMonitor_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonitor_config[P]>
      : GetScalarType<T[P], AggregateMonitor_config[P]>
  }




  export type Monitor_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Monitor_configWhereInput
    orderBy?: Monitor_configOrderByWithAggregationInput | Monitor_configOrderByWithAggregationInput[]
    by: Monitor_configScalarFieldEnum[] | Monitor_configScalarFieldEnum
    having?: Monitor_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monitor_configCountAggregateInputType | true
    _min?: Monitor_configMinAggregateInputType
    _max?: Monitor_configMaxAggregateInputType
  }

  export type Monitor_configGroupByOutputType = {
    id: string
    userId: string
    name: string | null
    monitorType: string
    is_active: boolean
    workspaceId: string | null
    teamId: string | null
    createdAt: Date
    _count: Monitor_configCountAggregateOutputType | null
    _min: Monitor_configMinAggregateOutputType | null
    _max: Monitor_configMaxAggregateOutputType | null
  }

  type GetMonitor_configGroupByPayload<T extends Monitor_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monitor_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monitor_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monitor_configGroupByOutputType[P]>
            : GetScalarType<T[P], Monitor_configGroupByOutputType[P]>
        }
      >
    >


  export type Monitor_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    monitorType?: boolean
    is_active?: boolean
    workspaceId?: boolean
    teamId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | Monitor_config$workspaceArgs<ExtArgs>
    Monitor_HTTP_gPRC_config?: boolean | Monitor_config$Monitor_HTTP_gPRC_configArgs<ExtArgs>
    Monitor_SSL_config?: boolean | Monitor_config$Monitor_SSL_configArgs<ExtArgs>
    Monitor_System_components?: boolean | Monitor_config$Monitor_System_componentsArgs<ExtArgs>
    team?: boolean | Monitor_config$teamArgs<ExtArgs>
    alert?: boolean | Monitor_config$alertArgs<ExtArgs>
    _count?: boolean | Monitor_configCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitor_config"]>


  export type Monitor_configSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    monitorType?: boolean
    is_active?: boolean
    workspaceId?: boolean
    teamId?: boolean
    createdAt?: boolean
  }

  export type Monitor_configInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | Monitor_config$workspaceArgs<ExtArgs>
    Monitor_HTTP_gPRC_config?: boolean | Monitor_config$Monitor_HTTP_gPRC_configArgs<ExtArgs>
    Monitor_SSL_config?: boolean | Monitor_config$Monitor_SSL_configArgs<ExtArgs>
    Monitor_System_components?: boolean | Monitor_config$Monitor_System_componentsArgs<ExtArgs>
    team?: boolean | Monitor_config$teamArgs<ExtArgs>
    alert?: boolean | Monitor_config$alertArgs<ExtArgs>
    _count?: boolean | Monitor_configCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $Monitor_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Monitor_config"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkSpacePayload<ExtArgs> | null
      Monitor_HTTP_gPRC_config: Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs> | null
      Monitor_SSL_config: Prisma.$Monitor_SSL_configPayload<ExtArgs> | null
      Monitor_System_components: Prisma.$Monitor_System_componentsPayload<ExtArgs> | null
      team: Prisma.$teamPayload<ExtArgs> | null
      alert: Prisma.$alertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string | null
      monitorType: string
      is_active: boolean
      workspaceId: string | null
      teamId: string | null
      createdAt: Date
    }, ExtArgs["result"]["monitor_config"]>
    composites: {}
  }

  type Monitor_configGetPayload<S extends boolean | null | undefined | Monitor_configDefaultArgs> = $Result.GetResult<Prisma.$Monitor_configPayload, S>

  type Monitor_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Monitor_configFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monitor_configCountAggregateInputType | true
    }

  export interface Monitor_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Monitor_config'], meta: { name: 'Monitor_config' } }
    /**
     * Find zero or one Monitor_config that matches the filter.
     * @param {Monitor_configFindUniqueArgs} args - Arguments to find a Monitor_config
     * @example
     * // Get one Monitor_config
     * const monitor_config = await prisma.monitor_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Monitor_configFindUniqueArgs>(args: SelectSubset<T, Monitor_configFindUniqueArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monitor_config that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Monitor_configFindUniqueOrThrowArgs} args - Arguments to find a Monitor_config
     * @example
     * // Get one Monitor_config
     * const monitor_config = await prisma.monitor_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Monitor_configFindUniqueOrThrowArgs>(args: SelectSubset<T, Monitor_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monitor_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_configFindFirstArgs} args - Arguments to find a Monitor_config
     * @example
     * // Get one Monitor_config
     * const monitor_config = await prisma.monitor_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Monitor_configFindFirstArgs>(args?: SelectSubset<T, Monitor_configFindFirstArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monitor_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_configFindFirstOrThrowArgs} args - Arguments to find a Monitor_config
     * @example
     * // Get one Monitor_config
     * const monitor_config = await prisma.monitor_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Monitor_configFindFirstOrThrowArgs>(args?: SelectSubset<T, Monitor_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monitor_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monitor_configs
     * const monitor_configs = await prisma.monitor_config.findMany()
     * 
     * // Get first 10 Monitor_configs
     * const monitor_configs = await prisma.monitor_config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monitor_configWithIdOnly = await prisma.monitor_config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Monitor_configFindManyArgs>(args?: SelectSubset<T, Monitor_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monitor_config.
     * @param {Monitor_configCreateArgs} args - Arguments to create a Monitor_config.
     * @example
     * // Create one Monitor_config
     * const Monitor_config = await prisma.monitor_config.create({
     *   data: {
     *     // ... data to create a Monitor_config
     *   }
     * })
     * 
     */
    create<T extends Monitor_configCreateArgs>(args: SelectSubset<T, Monitor_configCreateArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monitor_configs.
     * @param {Monitor_configCreateManyArgs} args - Arguments to create many Monitor_configs.
     * @example
     * // Create many Monitor_configs
     * const monitor_config = await prisma.monitor_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Monitor_configCreateManyArgs>(args?: SelectSubset<T, Monitor_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monitor_config.
     * @param {Monitor_configDeleteArgs} args - Arguments to delete one Monitor_config.
     * @example
     * // Delete one Monitor_config
     * const Monitor_config = await prisma.monitor_config.delete({
     *   where: {
     *     // ... filter to delete one Monitor_config
     *   }
     * })
     * 
     */
    delete<T extends Monitor_configDeleteArgs>(args: SelectSubset<T, Monitor_configDeleteArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monitor_config.
     * @param {Monitor_configUpdateArgs} args - Arguments to update one Monitor_config.
     * @example
     * // Update one Monitor_config
     * const monitor_config = await prisma.monitor_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Monitor_configUpdateArgs>(args: SelectSubset<T, Monitor_configUpdateArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monitor_configs.
     * @param {Monitor_configDeleteManyArgs} args - Arguments to filter Monitor_configs to delete.
     * @example
     * // Delete a few Monitor_configs
     * const { count } = await prisma.monitor_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Monitor_configDeleteManyArgs>(args?: SelectSubset<T, Monitor_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monitor_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monitor_configs
     * const monitor_config = await prisma.monitor_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Monitor_configUpdateManyArgs>(args: SelectSubset<T, Monitor_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monitor_config.
     * @param {Monitor_configUpsertArgs} args - Arguments to update or create a Monitor_config.
     * @example
     * // Update or create a Monitor_config
     * const monitor_config = await prisma.monitor_config.upsert({
     *   create: {
     *     // ... data to create a Monitor_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monitor_config we want to update
     *   }
     * })
     */
    upsert<T extends Monitor_configUpsertArgs>(args: SelectSubset<T, Monitor_configUpsertArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Monitor_configs that matches the filter.
     * @param {Monitor_configFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const monitor_config = await prisma.monitor_config.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: Monitor_configFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Monitor_config.
     * @param {Monitor_configAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const monitor_config = await prisma.monitor_config.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Monitor_configAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Monitor_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_configCountArgs} args - Arguments to filter Monitor_configs to count.
     * @example
     * // Count the number of Monitor_configs
     * const count = await prisma.monitor_config.count({
     *   where: {
     *     // ... the filter for the Monitor_configs we want to count
     *   }
     * })
    **/
    count<T extends Monitor_configCountArgs>(
      args?: Subset<T, Monitor_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monitor_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monitor_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monitor_configAggregateArgs>(args: Subset<T, Monitor_configAggregateArgs>): Prisma.PrismaPromise<GetMonitor_configAggregateType<T>>

    /**
     * Group by Monitor_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Monitor_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Monitor_configGroupByArgs['orderBy'] }
        : { orderBy?: Monitor_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Monitor_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonitor_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Monitor_config model
   */
  readonly fields: Monitor_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Monitor_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Monitor_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workspace<T extends Monitor_config$workspaceArgs<ExtArgs> = {}>(args?: Subset<T, Monitor_config$workspaceArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Monitor_HTTP_gPRC_config<T extends Monitor_config$Monitor_HTTP_gPRC_configArgs<ExtArgs> = {}>(args?: Subset<T, Monitor_config$Monitor_HTTP_gPRC_configArgs<ExtArgs>>): Prisma__Monitor_HTTP_gPRC_configClient<$Result.GetResult<Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Monitor_SSL_config<T extends Monitor_config$Monitor_SSL_configArgs<ExtArgs> = {}>(args?: Subset<T, Monitor_config$Monitor_SSL_configArgs<ExtArgs>>): Prisma__Monitor_SSL_configClient<$Result.GetResult<Prisma.$Monitor_SSL_configPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Monitor_System_components<T extends Monitor_config$Monitor_System_componentsArgs<ExtArgs> = {}>(args?: Subset<T, Monitor_config$Monitor_System_componentsArgs<ExtArgs>>): Prisma__Monitor_System_componentsClient<$Result.GetResult<Prisma.$Monitor_System_componentsPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    team<T extends Monitor_config$teamArgs<ExtArgs> = {}>(args?: Subset<T, Monitor_config$teamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    alert<T extends Monitor_config$alertArgs<ExtArgs> = {}>(args?: Subset<T, Monitor_config$alertArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Monitor_config model
   */ 
  interface Monitor_configFieldRefs {
    readonly id: FieldRef<"Monitor_config", 'String'>
    readonly userId: FieldRef<"Monitor_config", 'String'>
    readonly name: FieldRef<"Monitor_config", 'String'>
    readonly monitorType: FieldRef<"Monitor_config", 'String'>
    readonly is_active: FieldRef<"Monitor_config", 'Boolean'>
    readonly workspaceId: FieldRef<"Monitor_config", 'String'>
    readonly teamId: FieldRef<"Monitor_config", 'String'>
    readonly createdAt: FieldRef<"Monitor_config", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Monitor_config findUnique
   */
  export type Monitor_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_config to fetch.
     */
    where: Monitor_configWhereUniqueInput
  }

  /**
   * Monitor_config findUniqueOrThrow
   */
  export type Monitor_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_config to fetch.
     */
    where: Monitor_configWhereUniqueInput
  }

  /**
   * Monitor_config findFirst
   */
  export type Monitor_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_config to fetch.
     */
    where?: Monitor_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_configs to fetch.
     */
    orderBy?: Monitor_configOrderByWithRelationInput | Monitor_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitor_configs.
     */
    cursor?: Monitor_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitor_configs.
     */
    distinct?: Monitor_configScalarFieldEnum | Monitor_configScalarFieldEnum[]
  }

  /**
   * Monitor_config findFirstOrThrow
   */
  export type Monitor_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_config to fetch.
     */
    where?: Monitor_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_configs to fetch.
     */
    orderBy?: Monitor_configOrderByWithRelationInput | Monitor_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitor_configs.
     */
    cursor?: Monitor_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitor_configs.
     */
    distinct?: Monitor_configScalarFieldEnum | Monitor_configScalarFieldEnum[]
  }

  /**
   * Monitor_config findMany
   */
  export type Monitor_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_configs to fetch.
     */
    where?: Monitor_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_configs to fetch.
     */
    orderBy?: Monitor_configOrderByWithRelationInput | Monitor_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Monitor_configs.
     */
    cursor?: Monitor_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_configs.
     */
    skip?: number
    distinct?: Monitor_configScalarFieldEnum | Monitor_configScalarFieldEnum[]
  }

  /**
   * Monitor_config create
   */
  export type Monitor_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    /**
     * The data needed to create a Monitor_config.
     */
    data: XOR<Monitor_configCreateInput, Monitor_configUncheckedCreateInput>
  }

  /**
   * Monitor_config createMany
   */
  export type Monitor_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Monitor_configs.
     */
    data: Monitor_configCreateManyInput | Monitor_configCreateManyInput[]
  }

  /**
   * Monitor_config update
   */
  export type Monitor_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    /**
     * The data needed to update a Monitor_config.
     */
    data: XOR<Monitor_configUpdateInput, Monitor_configUncheckedUpdateInput>
    /**
     * Choose, which Monitor_config to update.
     */
    where: Monitor_configWhereUniqueInput
  }

  /**
   * Monitor_config updateMany
   */
  export type Monitor_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Monitor_configs.
     */
    data: XOR<Monitor_configUpdateManyMutationInput, Monitor_configUncheckedUpdateManyInput>
    /**
     * Filter which Monitor_configs to update
     */
    where?: Monitor_configWhereInput
  }

  /**
   * Monitor_config upsert
   */
  export type Monitor_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    /**
     * The filter to search for the Monitor_config to update in case it exists.
     */
    where: Monitor_configWhereUniqueInput
    /**
     * In case the Monitor_config found by the `where` argument doesn't exist, create a new Monitor_config with this data.
     */
    create: XOR<Monitor_configCreateInput, Monitor_configUncheckedCreateInput>
    /**
     * In case the Monitor_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Monitor_configUpdateInput, Monitor_configUncheckedUpdateInput>
  }

  /**
   * Monitor_config delete
   */
  export type Monitor_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    /**
     * Filter which Monitor_config to delete.
     */
    where: Monitor_configWhereUniqueInput
  }

  /**
   * Monitor_config deleteMany
   */
  export type Monitor_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitor_configs to delete
     */
    where?: Monitor_configWhereInput
  }

  /**
   * Monitor_config findRaw
   */
  export type Monitor_configFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Monitor_config aggregateRaw
   */
  export type Monitor_configAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Monitor_config.workspace
   */
  export type Monitor_config$workspaceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
    where?: WorkSpaceWhereInput
  }

  /**
   * Monitor_config.Monitor_HTTP_gPRC_config
   */
  export type Monitor_config$Monitor_HTTP_gPRC_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_HTTP_gPRC_config
     */
    select?: Monitor_HTTP_gPRC_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_HTTP_gPRC_configInclude<ExtArgs> | null
    where?: Monitor_HTTP_gPRC_configWhereInput
  }

  /**
   * Monitor_config.Monitor_SSL_config
   */
  export type Monitor_config$Monitor_SSL_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_SSL_config
     */
    select?: Monitor_SSL_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_SSL_configInclude<ExtArgs> | null
    where?: Monitor_SSL_configWhereInput
  }

  /**
   * Monitor_config.Monitor_System_components
   */
  export type Monitor_config$Monitor_System_componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_System_components
     */
    select?: Monitor_System_componentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_System_componentsInclude<ExtArgs> | null
    where?: Monitor_System_componentsWhereInput
  }

  /**
   * Monitor_config.team
   */
  export type Monitor_config$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }

  /**
   * Monitor_config.alert
   */
  export type Monitor_config$alertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    where?: alertWhereInput
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    cursor?: alertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * Monitor_config without action
   */
  export type Monitor_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
  }


  /**
   * Model Monitor_HTTP_gPRC_config
   */

  export type AggregateMonitor_HTTP_gPRC_config = {
    _count: Monitor_HTTP_gPRC_configCountAggregateOutputType | null
    _min: Monitor_HTTP_gPRC_configMinAggregateOutputType | null
    _max: Monitor_HTTP_gPRC_configMaxAggregateOutputType | null
  }

  export type Monitor_HTTP_gPRC_configMinAggregateOutputType = {
    id: string | null
    monitor_configId: string | null
    authType: string | null
    interval_check: string | null
    userName: string | null
    password: string | null
    inital_token: string | null
    refresh_token: string | null
    header_key: string | null
    header_value: string | null
    endpoint_url: string | null
    failure_count: string | null
    success_count: string | null
    success_response_code: string | null
  }

  export type Monitor_HTTP_gPRC_configMaxAggregateOutputType = {
    id: string | null
    monitor_configId: string | null
    authType: string | null
    interval_check: string | null
    userName: string | null
    password: string | null
    inital_token: string | null
    refresh_token: string | null
    header_key: string | null
    header_value: string | null
    endpoint_url: string | null
    failure_count: string | null
    success_count: string | null
    success_response_code: string | null
  }

  export type Monitor_HTTP_gPRC_configCountAggregateOutputType = {
    id: number
    monitor_configId: number
    authType: number
    interval_check: number
    userName: number
    password: number
    inital_token: number
    refresh_token: number
    header_key: number
    header_value: number
    endpoint_url: number
    failure_count: number
    success_count: number
    success_response_code: number
    _all: number
  }


  export type Monitor_HTTP_gPRC_configMinAggregateInputType = {
    id?: true
    monitor_configId?: true
    authType?: true
    interval_check?: true
    userName?: true
    password?: true
    inital_token?: true
    refresh_token?: true
    header_key?: true
    header_value?: true
    endpoint_url?: true
    failure_count?: true
    success_count?: true
    success_response_code?: true
  }

  export type Monitor_HTTP_gPRC_configMaxAggregateInputType = {
    id?: true
    monitor_configId?: true
    authType?: true
    interval_check?: true
    userName?: true
    password?: true
    inital_token?: true
    refresh_token?: true
    header_key?: true
    header_value?: true
    endpoint_url?: true
    failure_count?: true
    success_count?: true
    success_response_code?: true
  }

  export type Monitor_HTTP_gPRC_configCountAggregateInputType = {
    id?: true
    monitor_configId?: true
    authType?: true
    interval_check?: true
    userName?: true
    password?: true
    inital_token?: true
    refresh_token?: true
    header_key?: true
    header_value?: true
    endpoint_url?: true
    failure_count?: true
    success_count?: true
    success_response_code?: true
    _all?: true
  }

  export type Monitor_HTTP_gPRC_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitor_HTTP_gPRC_config to aggregate.
     */
    where?: Monitor_HTTP_gPRC_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_HTTP_gPRC_configs to fetch.
     */
    orderBy?: Monitor_HTTP_gPRC_configOrderByWithRelationInput | Monitor_HTTP_gPRC_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Monitor_HTTP_gPRC_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_HTTP_gPRC_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_HTTP_gPRC_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Monitor_HTTP_gPRC_configs
    **/
    _count?: true | Monitor_HTTP_gPRC_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monitor_HTTP_gPRC_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monitor_HTTP_gPRC_configMaxAggregateInputType
  }

  export type GetMonitor_HTTP_gPRC_configAggregateType<T extends Monitor_HTTP_gPRC_configAggregateArgs> = {
        [P in keyof T & keyof AggregateMonitor_HTTP_gPRC_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonitor_HTTP_gPRC_config[P]>
      : GetScalarType<T[P], AggregateMonitor_HTTP_gPRC_config[P]>
  }




  export type Monitor_HTTP_gPRC_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Monitor_HTTP_gPRC_configWhereInput
    orderBy?: Monitor_HTTP_gPRC_configOrderByWithAggregationInput | Monitor_HTTP_gPRC_configOrderByWithAggregationInput[]
    by: Monitor_HTTP_gPRC_configScalarFieldEnum[] | Monitor_HTTP_gPRC_configScalarFieldEnum
    having?: Monitor_HTTP_gPRC_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monitor_HTTP_gPRC_configCountAggregateInputType | true
    _min?: Monitor_HTTP_gPRC_configMinAggregateInputType
    _max?: Monitor_HTTP_gPRC_configMaxAggregateInputType
  }

  export type Monitor_HTTP_gPRC_configGroupByOutputType = {
    id: string
    monitor_configId: string
    authType: string
    interval_check: string | null
    userName: string | null
    password: string | null
    inital_token: string | null
    refresh_token: string | null
    header_key: string | null
    header_value: string | null
    endpoint_url: string | null
    failure_count: string | null
    success_count: string | null
    success_response_code: string | null
    _count: Monitor_HTTP_gPRC_configCountAggregateOutputType | null
    _min: Monitor_HTTP_gPRC_configMinAggregateOutputType | null
    _max: Monitor_HTTP_gPRC_configMaxAggregateOutputType | null
  }

  type GetMonitor_HTTP_gPRC_configGroupByPayload<T extends Monitor_HTTP_gPRC_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monitor_HTTP_gPRC_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monitor_HTTP_gPRC_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monitor_HTTP_gPRC_configGroupByOutputType[P]>
            : GetScalarType<T[P], Monitor_HTTP_gPRC_configGroupByOutputType[P]>
        }
      >
    >


  export type Monitor_HTTP_gPRC_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monitor_configId?: boolean
    authType?: boolean
    interval_check?: boolean
    userName?: boolean
    password?: boolean
    inital_token?: boolean
    refresh_token?: boolean
    header_key?: boolean
    header_value?: boolean
    endpoint_url?: boolean
    failure_count?: boolean
    success_count?: boolean
    success_response_code?: boolean
    monitor_config?: boolean | Monitor_configDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitor_HTTP_gPRC_config"]>


  export type Monitor_HTTP_gPRC_configSelectScalar = {
    id?: boolean
    monitor_configId?: boolean
    authType?: boolean
    interval_check?: boolean
    userName?: boolean
    password?: boolean
    inital_token?: boolean
    refresh_token?: boolean
    header_key?: boolean
    header_value?: boolean
    endpoint_url?: boolean
    failure_count?: boolean
    success_count?: boolean
    success_response_code?: boolean
  }

  export type Monitor_HTTP_gPRC_configInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monitor_config?: boolean | Monitor_configDefaultArgs<ExtArgs>
  }

  export type $Monitor_HTTP_gPRC_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Monitor_HTTP_gPRC_config"
    objects: {
      monitor_config: Prisma.$Monitor_configPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      monitor_configId: string
      authType: string
      interval_check: string | null
      userName: string | null
      password: string | null
      inital_token: string | null
      refresh_token: string | null
      header_key: string | null
      header_value: string | null
      endpoint_url: string | null
      failure_count: string | null
      success_count: string | null
      success_response_code: string | null
    }, ExtArgs["result"]["monitor_HTTP_gPRC_config"]>
    composites: {}
  }

  type Monitor_HTTP_gPRC_configGetPayload<S extends boolean | null | undefined | Monitor_HTTP_gPRC_configDefaultArgs> = $Result.GetResult<Prisma.$Monitor_HTTP_gPRC_configPayload, S>

  type Monitor_HTTP_gPRC_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Monitor_HTTP_gPRC_configFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monitor_HTTP_gPRC_configCountAggregateInputType | true
    }

  export interface Monitor_HTTP_gPRC_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Monitor_HTTP_gPRC_config'], meta: { name: 'Monitor_HTTP_gPRC_config' } }
    /**
     * Find zero or one Monitor_HTTP_gPRC_config that matches the filter.
     * @param {Monitor_HTTP_gPRC_configFindUniqueArgs} args - Arguments to find a Monitor_HTTP_gPRC_config
     * @example
     * // Get one Monitor_HTTP_gPRC_config
     * const monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Monitor_HTTP_gPRC_configFindUniqueArgs>(args: SelectSubset<T, Monitor_HTTP_gPRC_configFindUniqueArgs<ExtArgs>>): Prisma__Monitor_HTTP_gPRC_configClient<$Result.GetResult<Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monitor_HTTP_gPRC_config that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Monitor_HTTP_gPRC_configFindUniqueOrThrowArgs} args - Arguments to find a Monitor_HTTP_gPRC_config
     * @example
     * // Get one Monitor_HTTP_gPRC_config
     * const monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Monitor_HTTP_gPRC_configFindUniqueOrThrowArgs>(args: SelectSubset<T, Monitor_HTTP_gPRC_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Monitor_HTTP_gPRC_configClient<$Result.GetResult<Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monitor_HTTP_gPRC_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_HTTP_gPRC_configFindFirstArgs} args - Arguments to find a Monitor_HTTP_gPRC_config
     * @example
     * // Get one Monitor_HTTP_gPRC_config
     * const monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Monitor_HTTP_gPRC_configFindFirstArgs>(args?: SelectSubset<T, Monitor_HTTP_gPRC_configFindFirstArgs<ExtArgs>>): Prisma__Monitor_HTTP_gPRC_configClient<$Result.GetResult<Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monitor_HTTP_gPRC_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_HTTP_gPRC_configFindFirstOrThrowArgs} args - Arguments to find a Monitor_HTTP_gPRC_config
     * @example
     * // Get one Monitor_HTTP_gPRC_config
     * const monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Monitor_HTTP_gPRC_configFindFirstOrThrowArgs>(args?: SelectSubset<T, Monitor_HTTP_gPRC_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__Monitor_HTTP_gPRC_configClient<$Result.GetResult<Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monitor_HTTP_gPRC_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_HTTP_gPRC_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monitor_HTTP_gPRC_configs
     * const monitor_HTTP_gPRC_configs = await prisma.monitor_HTTP_gPRC_config.findMany()
     * 
     * // Get first 10 Monitor_HTTP_gPRC_configs
     * const monitor_HTTP_gPRC_configs = await prisma.monitor_HTTP_gPRC_config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monitor_HTTP_gPRC_configWithIdOnly = await prisma.monitor_HTTP_gPRC_config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Monitor_HTTP_gPRC_configFindManyArgs>(args?: SelectSubset<T, Monitor_HTTP_gPRC_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monitor_HTTP_gPRC_config.
     * @param {Monitor_HTTP_gPRC_configCreateArgs} args - Arguments to create a Monitor_HTTP_gPRC_config.
     * @example
     * // Create one Monitor_HTTP_gPRC_config
     * const Monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.create({
     *   data: {
     *     // ... data to create a Monitor_HTTP_gPRC_config
     *   }
     * })
     * 
     */
    create<T extends Monitor_HTTP_gPRC_configCreateArgs>(args: SelectSubset<T, Monitor_HTTP_gPRC_configCreateArgs<ExtArgs>>): Prisma__Monitor_HTTP_gPRC_configClient<$Result.GetResult<Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monitor_HTTP_gPRC_configs.
     * @param {Monitor_HTTP_gPRC_configCreateManyArgs} args - Arguments to create many Monitor_HTTP_gPRC_configs.
     * @example
     * // Create many Monitor_HTTP_gPRC_configs
     * const monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Monitor_HTTP_gPRC_configCreateManyArgs>(args?: SelectSubset<T, Monitor_HTTP_gPRC_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monitor_HTTP_gPRC_config.
     * @param {Monitor_HTTP_gPRC_configDeleteArgs} args - Arguments to delete one Monitor_HTTP_gPRC_config.
     * @example
     * // Delete one Monitor_HTTP_gPRC_config
     * const Monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.delete({
     *   where: {
     *     // ... filter to delete one Monitor_HTTP_gPRC_config
     *   }
     * })
     * 
     */
    delete<T extends Monitor_HTTP_gPRC_configDeleteArgs>(args: SelectSubset<T, Monitor_HTTP_gPRC_configDeleteArgs<ExtArgs>>): Prisma__Monitor_HTTP_gPRC_configClient<$Result.GetResult<Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monitor_HTTP_gPRC_config.
     * @param {Monitor_HTTP_gPRC_configUpdateArgs} args - Arguments to update one Monitor_HTTP_gPRC_config.
     * @example
     * // Update one Monitor_HTTP_gPRC_config
     * const monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Monitor_HTTP_gPRC_configUpdateArgs>(args: SelectSubset<T, Monitor_HTTP_gPRC_configUpdateArgs<ExtArgs>>): Prisma__Monitor_HTTP_gPRC_configClient<$Result.GetResult<Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monitor_HTTP_gPRC_configs.
     * @param {Monitor_HTTP_gPRC_configDeleteManyArgs} args - Arguments to filter Monitor_HTTP_gPRC_configs to delete.
     * @example
     * // Delete a few Monitor_HTTP_gPRC_configs
     * const { count } = await prisma.monitor_HTTP_gPRC_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Monitor_HTTP_gPRC_configDeleteManyArgs>(args?: SelectSubset<T, Monitor_HTTP_gPRC_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monitor_HTTP_gPRC_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_HTTP_gPRC_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monitor_HTTP_gPRC_configs
     * const monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Monitor_HTTP_gPRC_configUpdateManyArgs>(args: SelectSubset<T, Monitor_HTTP_gPRC_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monitor_HTTP_gPRC_config.
     * @param {Monitor_HTTP_gPRC_configUpsertArgs} args - Arguments to update or create a Monitor_HTTP_gPRC_config.
     * @example
     * // Update or create a Monitor_HTTP_gPRC_config
     * const monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.upsert({
     *   create: {
     *     // ... data to create a Monitor_HTTP_gPRC_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monitor_HTTP_gPRC_config we want to update
     *   }
     * })
     */
    upsert<T extends Monitor_HTTP_gPRC_configUpsertArgs>(args: SelectSubset<T, Monitor_HTTP_gPRC_configUpsertArgs<ExtArgs>>): Prisma__Monitor_HTTP_gPRC_configClient<$Result.GetResult<Prisma.$Monitor_HTTP_gPRC_configPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Monitor_HTTP_gPRC_configs that matches the filter.
     * @param {Monitor_HTTP_gPRC_configFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: Monitor_HTTP_gPRC_configFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Monitor_HTTP_gPRC_config.
     * @param {Monitor_HTTP_gPRC_configAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const monitor_HTTP_gPRC_config = await prisma.monitor_HTTP_gPRC_config.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Monitor_HTTP_gPRC_configAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Monitor_HTTP_gPRC_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_HTTP_gPRC_configCountArgs} args - Arguments to filter Monitor_HTTP_gPRC_configs to count.
     * @example
     * // Count the number of Monitor_HTTP_gPRC_configs
     * const count = await prisma.monitor_HTTP_gPRC_config.count({
     *   where: {
     *     // ... the filter for the Monitor_HTTP_gPRC_configs we want to count
     *   }
     * })
    **/
    count<T extends Monitor_HTTP_gPRC_configCountArgs>(
      args?: Subset<T, Monitor_HTTP_gPRC_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monitor_HTTP_gPRC_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monitor_HTTP_gPRC_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_HTTP_gPRC_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monitor_HTTP_gPRC_configAggregateArgs>(args: Subset<T, Monitor_HTTP_gPRC_configAggregateArgs>): Prisma.PrismaPromise<GetMonitor_HTTP_gPRC_configAggregateType<T>>

    /**
     * Group by Monitor_HTTP_gPRC_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_HTTP_gPRC_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Monitor_HTTP_gPRC_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Monitor_HTTP_gPRC_configGroupByArgs['orderBy'] }
        : { orderBy?: Monitor_HTTP_gPRC_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Monitor_HTTP_gPRC_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonitor_HTTP_gPRC_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Monitor_HTTP_gPRC_config model
   */
  readonly fields: Monitor_HTTP_gPRC_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Monitor_HTTP_gPRC_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Monitor_HTTP_gPRC_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monitor_config<T extends Monitor_configDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Monitor_configDefaultArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Monitor_HTTP_gPRC_config model
   */ 
  interface Monitor_HTTP_gPRC_configFieldRefs {
    readonly id: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly monitor_configId: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly authType: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly interval_check: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly userName: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly password: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly inital_token: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly refresh_token: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly header_key: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly header_value: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly endpoint_url: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly failure_count: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly success_count: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
    readonly success_response_code: FieldRef<"Monitor_HTTP_gPRC_config", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Monitor_HTTP_gPRC_config findUnique
   */
  export type Monitor_HTTP_gPRC_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_HTTP_gPRC_config
     */
    select?: Monitor_HTTP_gPRC_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_HTTP_gPRC_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_HTTP_gPRC_config to fetch.
     */
    where: Monitor_HTTP_gPRC_configWhereUniqueInput
  }

  /**
   * Monitor_HTTP_gPRC_config findUniqueOrThrow
   */
  export type Monitor_HTTP_gPRC_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_HTTP_gPRC_config
     */
    select?: Monitor_HTTP_gPRC_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_HTTP_gPRC_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_HTTP_gPRC_config to fetch.
     */
    where: Monitor_HTTP_gPRC_configWhereUniqueInput
  }

  /**
   * Monitor_HTTP_gPRC_config findFirst
   */
  export type Monitor_HTTP_gPRC_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_HTTP_gPRC_config
     */
    select?: Monitor_HTTP_gPRC_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_HTTP_gPRC_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_HTTP_gPRC_config to fetch.
     */
    where?: Monitor_HTTP_gPRC_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_HTTP_gPRC_configs to fetch.
     */
    orderBy?: Monitor_HTTP_gPRC_configOrderByWithRelationInput | Monitor_HTTP_gPRC_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitor_HTTP_gPRC_configs.
     */
    cursor?: Monitor_HTTP_gPRC_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_HTTP_gPRC_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_HTTP_gPRC_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitor_HTTP_gPRC_configs.
     */
    distinct?: Monitor_HTTP_gPRC_configScalarFieldEnum | Monitor_HTTP_gPRC_configScalarFieldEnum[]
  }

  /**
   * Monitor_HTTP_gPRC_config findFirstOrThrow
   */
  export type Monitor_HTTP_gPRC_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_HTTP_gPRC_config
     */
    select?: Monitor_HTTP_gPRC_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_HTTP_gPRC_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_HTTP_gPRC_config to fetch.
     */
    where?: Monitor_HTTP_gPRC_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_HTTP_gPRC_configs to fetch.
     */
    orderBy?: Monitor_HTTP_gPRC_configOrderByWithRelationInput | Monitor_HTTP_gPRC_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitor_HTTP_gPRC_configs.
     */
    cursor?: Monitor_HTTP_gPRC_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_HTTP_gPRC_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_HTTP_gPRC_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitor_HTTP_gPRC_configs.
     */
    distinct?: Monitor_HTTP_gPRC_configScalarFieldEnum | Monitor_HTTP_gPRC_configScalarFieldEnum[]
  }

  /**
   * Monitor_HTTP_gPRC_config findMany
   */
  export type Monitor_HTTP_gPRC_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_HTTP_gPRC_config
     */
    select?: Monitor_HTTP_gPRC_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_HTTP_gPRC_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_HTTP_gPRC_configs to fetch.
     */
    where?: Monitor_HTTP_gPRC_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_HTTP_gPRC_configs to fetch.
     */
    orderBy?: Monitor_HTTP_gPRC_configOrderByWithRelationInput | Monitor_HTTP_gPRC_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Monitor_HTTP_gPRC_configs.
     */
    cursor?: Monitor_HTTP_gPRC_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_HTTP_gPRC_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_HTTP_gPRC_configs.
     */
    skip?: number
    distinct?: Monitor_HTTP_gPRC_configScalarFieldEnum | Monitor_HTTP_gPRC_configScalarFieldEnum[]
  }

  /**
   * Monitor_HTTP_gPRC_config create
   */
  export type Monitor_HTTP_gPRC_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_HTTP_gPRC_config
     */
    select?: Monitor_HTTP_gPRC_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_HTTP_gPRC_configInclude<ExtArgs> | null
    /**
     * The data needed to create a Monitor_HTTP_gPRC_config.
     */
    data: XOR<Monitor_HTTP_gPRC_configCreateInput, Monitor_HTTP_gPRC_configUncheckedCreateInput>
  }

  /**
   * Monitor_HTTP_gPRC_config createMany
   */
  export type Monitor_HTTP_gPRC_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Monitor_HTTP_gPRC_configs.
     */
    data: Monitor_HTTP_gPRC_configCreateManyInput | Monitor_HTTP_gPRC_configCreateManyInput[]
  }

  /**
   * Monitor_HTTP_gPRC_config update
   */
  export type Monitor_HTTP_gPRC_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_HTTP_gPRC_config
     */
    select?: Monitor_HTTP_gPRC_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_HTTP_gPRC_configInclude<ExtArgs> | null
    /**
     * The data needed to update a Monitor_HTTP_gPRC_config.
     */
    data: XOR<Monitor_HTTP_gPRC_configUpdateInput, Monitor_HTTP_gPRC_configUncheckedUpdateInput>
    /**
     * Choose, which Monitor_HTTP_gPRC_config to update.
     */
    where: Monitor_HTTP_gPRC_configWhereUniqueInput
  }

  /**
   * Monitor_HTTP_gPRC_config updateMany
   */
  export type Monitor_HTTP_gPRC_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Monitor_HTTP_gPRC_configs.
     */
    data: XOR<Monitor_HTTP_gPRC_configUpdateManyMutationInput, Monitor_HTTP_gPRC_configUncheckedUpdateManyInput>
    /**
     * Filter which Monitor_HTTP_gPRC_configs to update
     */
    where?: Monitor_HTTP_gPRC_configWhereInput
  }

  /**
   * Monitor_HTTP_gPRC_config upsert
   */
  export type Monitor_HTTP_gPRC_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_HTTP_gPRC_config
     */
    select?: Monitor_HTTP_gPRC_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_HTTP_gPRC_configInclude<ExtArgs> | null
    /**
     * The filter to search for the Monitor_HTTP_gPRC_config to update in case it exists.
     */
    where: Monitor_HTTP_gPRC_configWhereUniqueInput
    /**
     * In case the Monitor_HTTP_gPRC_config found by the `where` argument doesn't exist, create a new Monitor_HTTP_gPRC_config with this data.
     */
    create: XOR<Monitor_HTTP_gPRC_configCreateInput, Monitor_HTTP_gPRC_configUncheckedCreateInput>
    /**
     * In case the Monitor_HTTP_gPRC_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Monitor_HTTP_gPRC_configUpdateInput, Monitor_HTTP_gPRC_configUncheckedUpdateInput>
  }

  /**
   * Monitor_HTTP_gPRC_config delete
   */
  export type Monitor_HTTP_gPRC_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_HTTP_gPRC_config
     */
    select?: Monitor_HTTP_gPRC_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_HTTP_gPRC_configInclude<ExtArgs> | null
    /**
     * Filter which Monitor_HTTP_gPRC_config to delete.
     */
    where: Monitor_HTTP_gPRC_configWhereUniqueInput
  }

  /**
   * Monitor_HTTP_gPRC_config deleteMany
   */
  export type Monitor_HTTP_gPRC_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitor_HTTP_gPRC_configs to delete
     */
    where?: Monitor_HTTP_gPRC_configWhereInput
  }

  /**
   * Monitor_HTTP_gPRC_config findRaw
   */
  export type Monitor_HTTP_gPRC_configFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Monitor_HTTP_gPRC_config aggregateRaw
   */
  export type Monitor_HTTP_gPRC_configAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Monitor_HTTP_gPRC_config without action
   */
  export type Monitor_HTTP_gPRC_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_HTTP_gPRC_config
     */
    select?: Monitor_HTTP_gPRC_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_HTTP_gPRC_configInclude<ExtArgs> | null
  }


  /**
   * Model Monitor_SSL_config
   */

  export type AggregateMonitor_SSL_config = {
    _count: Monitor_SSL_configCountAggregateOutputType | null
    _min: Monitor_SSL_configMinAggregateOutputType | null
    _max: Monitor_SSL_configMaxAggregateOutputType | null
  }

  export type Monitor_SSL_configMinAggregateOutputType = {
    id: string | null
    monitor_configId: string | null
    endpoint_url: string | null
    alt_names: string | null
    is_wildcard: boolean | null
    wildcard_url: string | null
    certifcate_issue: Date | null
    certificate_tenure: string | null
    expiry_reminder: string | null
  }

  export type Monitor_SSL_configMaxAggregateOutputType = {
    id: string | null
    monitor_configId: string | null
    endpoint_url: string | null
    alt_names: string | null
    is_wildcard: boolean | null
    wildcard_url: string | null
    certifcate_issue: Date | null
    certificate_tenure: string | null
    expiry_reminder: string | null
  }

  export type Monitor_SSL_configCountAggregateOutputType = {
    id: number
    monitor_configId: number
    endpoint_url: number
    alt_names: number
    is_wildcard: number
    wildcard_url: number
    certifcate_issue: number
    certificate_tenure: number
    expiry_reminder: number
    _all: number
  }


  export type Monitor_SSL_configMinAggregateInputType = {
    id?: true
    monitor_configId?: true
    endpoint_url?: true
    alt_names?: true
    is_wildcard?: true
    wildcard_url?: true
    certifcate_issue?: true
    certificate_tenure?: true
    expiry_reminder?: true
  }

  export type Monitor_SSL_configMaxAggregateInputType = {
    id?: true
    monitor_configId?: true
    endpoint_url?: true
    alt_names?: true
    is_wildcard?: true
    wildcard_url?: true
    certifcate_issue?: true
    certificate_tenure?: true
    expiry_reminder?: true
  }

  export type Monitor_SSL_configCountAggregateInputType = {
    id?: true
    monitor_configId?: true
    endpoint_url?: true
    alt_names?: true
    is_wildcard?: true
    wildcard_url?: true
    certifcate_issue?: true
    certificate_tenure?: true
    expiry_reminder?: true
    _all?: true
  }

  export type Monitor_SSL_configAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitor_SSL_config to aggregate.
     */
    where?: Monitor_SSL_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_SSL_configs to fetch.
     */
    orderBy?: Monitor_SSL_configOrderByWithRelationInput | Monitor_SSL_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Monitor_SSL_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_SSL_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_SSL_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Monitor_SSL_configs
    **/
    _count?: true | Monitor_SSL_configCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monitor_SSL_configMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monitor_SSL_configMaxAggregateInputType
  }

  export type GetMonitor_SSL_configAggregateType<T extends Monitor_SSL_configAggregateArgs> = {
        [P in keyof T & keyof AggregateMonitor_SSL_config]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonitor_SSL_config[P]>
      : GetScalarType<T[P], AggregateMonitor_SSL_config[P]>
  }




  export type Monitor_SSL_configGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Monitor_SSL_configWhereInput
    orderBy?: Monitor_SSL_configOrderByWithAggregationInput | Monitor_SSL_configOrderByWithAggregationInput[]
    by: Monitor_SSL_configScalarFieldEnum[] | Monitor_SSL_configScalarFieldEnum
    having?: Monitor_SSL_configScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monitor_SSL_configCountAggregateInputType | true
    _min?: Monitor_SSL_configMinAggregateInputType
    _max?: Monitor_SSL_configMaxAggregateInputType
  }

  export type Monitor_SSL_configGroupByOutputType = {
    id: string
    monitor_configId: string
    endpoint_url: string | null
    alt_names: string | null
    is_wildcard: boolean
    wildcard_url: string | null
    certifcate_issue: Date | null
    certificate_tenure: string | null
    expiry_reminder: string | null
    _count: Monitor_SSL_configCountAggregateOutputType | null
    _min: Monitor_SSL_configMinAggregateOutputType | null
    _max: Monitor_SSL_configMaxAggregateOutputType | null
  }

  type GetMonitor_SSL_configGroupByPayload<T extends Monitor_SSL_configGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monitor_SSL_configGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monitor_SSL_configGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monitor_SSL_configGroupByOutputType[P]>
            : GetScalarType<T[P], Monitor_SSL_configGroupByOutputType[P]>
        }
      >
    >


  export type Monitor_SSL_configSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monitor_configId?: boolean
    endpoint_url?: boolean
    alt_names?: boolean
    is_wildcard?: boolean
    wildcard_url?: boolean
    certifcate_issue?: boolean
    certificate_tenure?: boolean
    expiry_reminder?: boolean
    monitor_config?: boolean | Monitor_configDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitor_SSL_config"]>


  export type Monitor_SSL_configSelectScalar = {
    id?: boolean
    monitor_configId?: boolean
    endpoint_url?: boolean
    alt_names?: boolean
    is_wildcard?: boolean
    wildcard_url?: boolean
    certifcate_issue?: boolean
    certificate_tenure?: boolean
    expiry_reminder?: boolean
  }

  export type Monitor_SSL_configInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monitor_config?: boolean | Monitor_configDefaultArgs<ExtArgs>
  }

  export type $Monitor_SSL_configPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Monitor_SSL_config"
    objects: {
      monitor_config: Prisma.$Monitor_configPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      monitor_configId: string
      endpoint_url: string | null
      alt_names: string | null
      is_wildcard: boolean
      wildcard_url: string | null
      certifcate_issue: Date | null
      certificate_tenure: string | null
      expiry_reminder: string | null
    }, ExtArgs["result"]["monitor_SSL_config"]>
    composites: {}
  }

  type Monitor_SSL_configGetPayload<S extends boolean | null | undefined | Monitor_SSL_configDefaultArgs> = $Result.GetResult<Prisma.$Monitor_SSL_configPayload, S>

  type Monitor_SSL_configCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Monitor_SSL_configFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monitor_SSL_configCountAggregateInputType | true
    }

  export interface Monitor_SSL_configDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Monitor_SSL_config'], meta: { name: 'Monitor_SSL_config' } }
    /**
     * Find zero or one Monitor_SSL_config that matches the filter.
     * @param {Monitor_SSL_configFindUniqueArgs} args - Arguments to find a Monitor_SSL_config
     * @example
     * // Get one Monitor_SSL_config
     * const monitor_SSL_config = await prisma.monitor_SSL_config.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Monitor_SSL_configFindUniqueArgs>(args: SelectSubset<T, Monitor_SSL_configFindUniqueArgs<ExtArgs>>): Prisma__Monitor_SSL_configClient<$Result.GetResult<Prisma.$Monitor_SSL_configPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monitor_SSL_config that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Monitor_SSL_configFindUniqueOrThrowArgs} args - Arguments to find a Monitor_SSL_config
     * @example
     * // Get one Monitor_SSL_config
     * const monitor_SSL_config = await prisma.monitor_SSL_config.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Monitor_SSL_configFindUniqueOrThrowArgs>(args: SelectSubset<T, Monitor_SSL_configFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Monitor_SSL_configClient<$Result.GetResult<Prisma.$Monitor_SSL_configPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monitor_SSL_config that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_SSL_configFindFirstArgs} args - Arguments to find a Monitor_SSL_config
     * @example
     * // Get one Monitor_SSL_config
     * const monitor_SSL_config = await prisma.monitor_SSL_config.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Monitor_SSL_configFindFirstArgs>(args?: SelectSubset<T, Monitor_SSL_configFindFirstArgs<ExtArgs>>): Prisma__Monitor_SSL_configClient<$Result.GetResult<Prisma.$Monitor_SSL_configPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monitor_SSL_config that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_SSL_configFindFirstOrThrowArgs} args - Arguments to find a Monitor_SSL_config
     * @example
     * // Get one Monitor_SSL_config
     * const monitor_SSL_config = await prisma.monitor_SSL_config.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Monitor_SSL_configFindFirstOrThrowArgs>(args?: SelectSubset<T, Monitor_SSL_configFindFirstOrThrowArgs<ExtArgs>>): Prisma__Monitor_SSL_configClient<$Result.GetResult<Prisma.$Monitor_SSL_configPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monitor_SSL_configs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_SSL_configFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monitor_SSL_configs
     * const monitor_SSL_configs = await prisma.monitor_SSL_config.findMany()
     * 
     * // Get first 10 Monitor_SSL_configs
     * const monitor_SSL_configs = await prisma.monitor_SSL_config.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monitor_SSL_configWithIdOnly = await prisma.monitor_SSL_config.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Monitor_SSL_configFindManyArgs>(args?: SelectSubset<T, Monitor_SSL_configFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Monitor_SSL_configPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monitor_SSL_config.
     * @param {Monitor_SSL_configCreateArgs} args - Arguments to create a Monitor_SSL_config.
     * @example
     * // Create one Monitor_SSL_config
     * const Monitor_SSL_config = await prisma.monitor_SSL_config.create({
     *   data: {
     *     // ... data to create a Monitor_SSL_config
     *   }
     * })
     * 
     */
    create<T extends Monitor_SSL_configCreateArgs>(args: SelectSubset<T, Monitor_SSL_configCreateArgs<ExtArgs>>): Prisma__Monitor_SSL_configClient<$Result.GetResult<Prisma.$Monitor_SSL_configPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monitor_SSL_configs.
     * @param {Monitor_SSL_configCreateManyArgs} args - Arguments to create many Monitor_SSL_configs.
     * @example
     * // Create many Monitor_SSL_configs
     * const monitor_SSL_config = await prisma.monitor_SSL_config.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Monitor_SSL_configCreateManyArgs>(args?: SelectSubset<T, Monitor_SSL_configCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monitor_SSL_config.
     * @param {Monitor_SSL_configDeleteArgs} args - Arguments to delete one Monitor_SSL_config.
     * @example
     * // Delete one Monitor_SSL_config
     * const Monitor_SSL_config = await prisma.monitor_SSL_config.delete({
     *   where: {
     *     // ... filter to delete one Monitor_SSL_config
     *   }
     * })
     * 
     */
    delete<T extends Monitor_SSL_configDeleteArgs>(args: SelectSubset<T, Monitor_SSL_configDeleteArgs<ExtArgs>>): Prisma__Monitor_SSL_configClient<$Result.GetResult<Prisma.$Monitor_SSL_configPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monitor_SSL_config.
     * @param {Monitor_SSL_configUpdateArgs} args - Arguments to update one Monitor_SSL_config.
     * @example
     * // Update one Monitor_SSL_config
     * const monitor_SSL_config = await prisma.monitor_SSL_config.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Monitor_SSL_configUpdateArgs>(args: SelectSubset<T, Monitor_SSL_configUpdateArgs<ExtArgs>>): Prisma__Monitor_SSL_configClient<$Result.GetResult<Prisma.$Monitor_SSL_configPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monitor_SSL_configs.
     * @param {Monitor_SSL_configDeleteManyArgs} args - Arguments to filter Monitor_SSL_configs to delete.
     * @example
     * // Delete a few Monitor_SSL_configs
     * const { count } = await prisma.monitor_SSL_config.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Monitor_SSL_configDeleteManyArgs>(args?: SelectSubset<T, Monitor_SSL_configDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monitor_SSL_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_SSL_configUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monitor_SSL_configs
     * const monitor_SSL_config = await prisma.monitor_SSL_config.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Monitor_SSL_configUpdateManyArgs>(args: SelectSubset<T, Monitor_SSL_configUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monitor_SSL_config.
     * @param {Monitor_SSL_configUpsertArgs} args - Arguments to update or create a Monitor_SSL_config.
     * @example
     * // Update or create a Monitor_SSL_config
     * const monitor_SSL_config = await prisma.monitor_SSL_config.upsert({
     *   create: {
     *     // ... data to create a Monitor_SSL_config
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monitor_SSL_config we want to update
     *   }
     * })
     */
    upsert<T extends Monitor_SSL_configUpsertArgs>(args: SelectSubset<T, Monitor_SSL_configUpsertArgs<ExtArgs>>): Prisma__Monitor_SSL_configClient<$Result.GetResult<Prisma.$Monitor_SSL_configPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Monitor_SSL_configs that matches the filter.
     * @param {Monitor_SSL_configFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const monitor_SSL_config = await prisma.monitor_SSL_config.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: Monitor_SSL_configFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Monitor_SSL_config.
     * @param {Monitor_SSL_configAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const monitor_SSL_config = await prisma.monitor_SSL_config.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Monitor_SSL_configAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Monitor_SSL_configs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_SSL_configCountArgs} args - Arguments to filter Monitor_SSL_configs to count.
     * @example
     * // Count the number of Monitor_SSL_configs
     * const count = await prisma.monitor_SSL_config.count({
     *   where: {
     *     // ... the filter for the Monitor_SSL_configs we want to count
     *   }
     * })
    **/
    count<T extends Monitor_SSL_configCountArgs>(
      args?: Subset<T, Monitor_SSL_configCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monitor_SSL_configCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monitor_SSL_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_SSL_configAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monitor_SSL_configAggregateArgs>(args: Subset<T, Monitor_SSL_configAggregateArgs>): Prisma.PrismaPromise<GetMonitor_SSL_configAggregateType<T>>

    /**
     * Group by Monitor_SSL_config.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_SSL_configGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Monitor_SSL_configGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Monitor_SSL_configGroupByArgs['orderBy'] }
        : { orderBy?: Monitor_SSL_configGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Monitor_SSL_configGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonitor_SSL_configGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Monitor_SSL_config model
   */
  readonly fields: Monitor_SSL_configFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Monitor_SSL_config.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Monitor_SSL_configClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monitor_config<T extends Monitor_configDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Monitor_configDefaultArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Monitor_SSL_config model
   */ 
  interface Monitor_SSL_configFieldRefs {
    readonly id: FieldRef<"Monitor_SSL_config", 'String'>
    readonly monitor_configId: FieldRef<"Monitor_SSL_config", 'String'>
    readonly endpoint_url: FieldRef<"Monitor_SSL_config", 'String'>
    readonly alt_names: FieldRef<"Monitor_SSL_config", 'String'>
    readonly is_wildcard: FieldRef<"Monitor_SSL_config", 'Boolean'>
    readonly wildcard_url: FieldRef<"Monitor_SSL_config", 'String'>
    readonly certifcate_issue: FieldRef<"Monitor_SSL_config", 'DateTime'>
    readonly certificate_tenure: FieldRef<"Monitor_SSL_config", 'String'>
    readonly expiry_reminder: FieldRef<"Monitor_SSL_config", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Monitor_SSL_config findUnique
   */
  export type Monitor_SSL_configFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_SSL_config
     */
    select?: Monitor_SSL_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_SSL_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_SSL_config to fetch.
     */
    where: Monitor_SSL_configWhereUniqueInput
  }

  /**
   * Monitor_SSL_config findUniqueOrThrow
   */
  export type Monitor_SSL_configFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_SSL_config
     */
    select?: Monitor_SSL_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_SSL_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_SSL_config to fetch.
     */
    where: Monitor_SSL_configWhereUniqueInput
  }

  /**
   * Monitor_SSL_config findFirst
   */
  export type Monitor_SSL_configFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_SSL_config
     */
    select?: Monitor_SSL_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_SSL_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_SSL_config to fetch.
     */
    where?: Monitor_SSL_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_SSL_configs to fetch.
     */
    orderBy?: Monitor_SSL_configOrderByWithRelationInput | Monitor_SSL_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitor_SSL_configs.
     */
    cursor?: Monitor_SSL_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_SSL_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_SSL_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitor_SSL_configs.
     */
    distinct?: Monitor_SSL_configScalarFieldEnum | Monitor_SSL_configScalarFieldEnum[]
  }

  /**
   * Monitor_SSL_config findFirstOrThrow
   */
  export type Monitor_SSL_configFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_SSL_config
     */
    select?: Monitor_SSL_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_SSL_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_SSL_config to fetch.
     */
    where?: Monitor_SSL_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_SSL_configs to fetch.
     */
    orderBy?: Monitor_SSL_configOrderByWithRelationInput | Monitor_SSL_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitor_SSL_configs.
     */
    cursor?: Monitor_SSL_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_SSL_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_SSL_configs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitor_SSL_configs.
     */
    distinct?: Monitor_SSL_configScalarFieldEnum | Monitor_SSL_configScalarFieldEnum[]
  }

  /**
   * Monitor_SSL_config findMany
   */
  export type Monitor_SSL_configFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_SSL_config
     */
    select?: Monitor_SSL_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_SSL_configInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_SSL_configs to fetch.
     */
    where?: Monitor_SSL_configWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_SSL_configs to fetch.
     */
    orderBy?: Monitor_SSL_configOrderByWithRelationInput | Monitor_SSL_configOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Monitor_SSL_configs.
     */
    cursor?: Monitor_SSL_configWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_SSL_configs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_SSL_configs.
     */
    skip?: number
    distinct?: Monitor_SSL_configScalarFieldEnum | Monitor_SSL_configScalarFieldEnum[]
  }

  /**
   * Monitor_SSL_config create
   */
  export type Monitor_SSL_configCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_SSL_config
     */
    select?: Monitor_SSL_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_SSL_configInclude<ExtArgs> | null
    /**
     * The data needed to create a Monitor_SSL_config.
     */
    data: XOR<Monitor_SSL_configCreateInput, Monitor_SSL_configUncheckedCreateInput>
  }

  /**
   * Monitor_SSL_config createMany
   */
  export type Monitor_SSL_configCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Monitor_SSL_configs.
     */
    data: Monitor_SSL_configCreateManyInput | Monitor_SSL_configCreateManyInput[]
  }

  /**
   * Monitor_SSL_config update
   */
  export type Monitor_SSL_configUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_SSL_config
     */
    select?: Monitor_SSL_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_SSL_configInclude<ExtArgs> | null
    /**
     * The data needed to update a Monitor_SSL_config.
     */
    data: XOR<Monitor_SSL_configUpdateInput, Monitor_SSL_configUncheckedUpdateInput>
    /**
     * Choose, which Monitor_SSL_config to update.
     */
    where: Monitor_SSL_configWhereUniqueInput
  }

  /**
   * Monitor_SSL_config updateMany
   */
  export type Monitor_SSL_configUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Monitor_SSL_configs.
     */
    data: XOR<Monitor_SSL_configUpdateManyMutationInput, Monitor_SSL_configUncheckedUpdateManyInput>
    /**
     * Filter which Monitor_SSL_configs to update
     */
    where?: Monitor_SSL_configWhereInput
  }

  /**
   * Monitor_SSL_config upsert
   */
  export type Monitor_SSL_configUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_SSL_config
     */
    select?: Monitor_SSL_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_SSL_configInclude<ExtArgs> | null
    /**
     * The filter to search for the Monitor_SSL_config to update in case it exists.
     */
    where: Monitor_SSL_configWhereUniqueInput
    /**
     * In case the Monitor_SSL_config found by the `where` argument doesn't exist, create a new Monitor_SSL_config with this data.
     */
    create: XOR<Monitor_SSL_configCreateInput, Monitor_SSL_configUncheckedCreateInput>
    /**
     * In case the Monitor_SSL_config was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Monitor_SSL_configUpdateInput, Monitor_SSL_configUncheckedUpdateInput>
  }

  /**
   * Monitor_SSL_config delete
   */
  export type Monitor_SSL_configDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_SSL_config
     */
    select?: Monitor_SSL_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_SSL_configInclude<ExtArgs> | null
    /**
     * Filter which Monitor_SSL_config to delete.
     */
    where: Monitor_SSL_configWhereUniqueInput
  }

  /**
   * Monitor_SSL_config deleteMany
   */
  export type Monitor_SSL_configDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitor_SSL_configs to delete
     */
    where?: Monitor_SSL_configWhereInput
  }

  /**
   * Monitor_SSL_config findRaw
   */
  export type Monitor_SSL_configFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Monitor_SSL_config aggregateRaw
   */
  export type Monitor_SSL_configAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Monitor_SSL_config without action
   */
  export type Monitor_SSL_configDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_SSL_config
     */
    select?: Monitor_SSL_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_SSL_configInclude<ExtArgs> | null
  }


  /**
   * Model Monitor_System_components
   */

  export type AggregateMonitor_System_components = {
    _count: Monitor_System_componentsCountAggregateOutputType | null
    _min: Monitor_System_componentsMinAggregateOutputType | null
    _max: Monitor_System_componentsMaxAggregateOutputType | null
  }

  export type Monitor_System_componentsMinAggregateOutputType = {
    id: string | null
    monitor_configId: string | null
    is_cloud: boolean | null
    cloud_service_url: string | null
    cloud_userName: string | null
    cloud_password: string | null
    cloud_downloadUrl: string | null
  }

  export type Monitor_System_componentsMaxAggregateOutputType = {
    id: string | null
    monitor_configId: string | null
    is_cloud: boolean | null
    cloud_service_url: string | null
    cloud_userName: string | null
    cloud_password: string | null
    cloud_downloadUrl: string | null
  }

  export type Monitor_System_componentsCountAggregateOutputType = {
    id: number
    monitor_configId: number
    components_lists: number
    is_cloud: number
    cloud_service_url: number
    cloud_userName: number
    cloud_password: number
    cloud_downloadUrl: number
    _all: number
  }


  export type Monitor_System_componentsMinAggregateInputType = {
    id?: true
    monitor_configId?: true
    is_cloud?: true
    cloud_service_url?: true
    cloud_userName?: true
    cloud_password?: true
    cloud_downloadUrl?: true
  }

  export type Monitor_System_componentsMaxAggregateInputType = {
    id?: true
    monitor_configId?: true
    is_cloud?: true
    cloud_service_url?: true
    cloud_userName?: true
    cloud_password?: true
    cloud_downloadUrl?: true
  }

  export type Monitor_System_componentsCountAggregateInputType = {
    id?: true
    monitor_configId?: true
    components_lists?: true
    is_cloud?: true
    cloud_service_url?: true
    cloud_userName?: true
    cloud_password?: true
    cloud_downloadUrl?: true
    _all?: true
  }

  export type Monitor_System_componentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitor_System_components to aggregate.
     */
    where?: Monitor_System_componentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_System_components to fetch.
     */
    orderBy?: Monitor_System_componentsOrderByWithRelationInput | Monitor_System_componentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Monitor_System_componentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_System_components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_System_components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Monitor_System_components
    **/
    _count?: true | Monitor_System_componentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Monitor_System_componentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Monitor_System_componentsMaxAggregateInputType
  }

  export type GetMonitor_System_componentsAggregateType<T extends Monitor_System_componentsAggregateArgs> = {
        [P in keyof T & keyof AggregateMonitor_System_components]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonitor_System_components[P]>
      : GetScalarType<T[P], AggregateMonitor_System_components[P]>
  }




  export type Monitor_System_componentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: Monitor_System_componentsWhereInput
    orderBy?: Monitor_System_componentsOrderByWithAggregationInput | Monitor_System_componentsOrderByWithAggregationInput[]
    by: Monitor_System_componentsScalarFieldEnum[] | Monitor_System_componentsScalarFieldEnum
    having?: Monitor_System_componentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Monitor_System_componentsCountAggregateInputType | true
    _min?: Monitor_System_componentsMinAggregateInputType
    _max?: Monitor_System_componentsMaxAggregateInputType
  }

  export type Monitor_System_componentsGroupByOutputType = {
    id: string
    monitor_configId: string
    components_lists: string[]
    is_cloud: boolean
    cloud_service_url: string | null
    cloud_userName: string | null
    cloud_password: string | null
    cloud_downloadUrl: string | null
    _count: Monitor_System_componentsCountAggregateOutputType | null
    _min: Monitor_System_componentsMinAggregateOutputType | null
    _max: Monitor_System_componentsMaxAggregateOutputType | null
  }

  type GetMonitor_System_componentsGroupByPayload<T extends Monitor_System_componentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Monitor_System_componentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Monitor_System_componentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Monitor_System_componentsGroupByOutputType[P]>
            : GetScalarType<T[P], Monitor_System_componentsGroupByOutputType[P]>
        }
      >
    >


  export type Monitor_System_componentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    monitor_configId?: boolean
    components_lists?: boolean
    is_cloud?: boolean
    cloud_service_url?: boolean
    cloud_userName?: boolean
    cloud_password?: boolean
    cloud_downloadUrl?: boolean
    monitor_config?: boolean | Monitor_configDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["monitor_System_components"]>


  export type Monitor_System_componentsSelectScalar = {
    id?: boolean
    monitor_configId?: boolean
    components_lists?: boolean
    is_cloud?: boolean
    cloud_service_url?: boolean
    cloud_userName?: boolean
    cloud_password?: boolean
    cloud_downloadUrl?: boolean
  }

  export type Monitor_System_componentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monitor_config?: boolean | Monitor_configDefaultArgs<ExtArgs>
  }

  export type $Monitor_System_componentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Monitor_System_components"
    objects: {
      monitor_config: Prisma.$Monitor_configPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      monitor_configId: string
      components_lists: string[]
      is_cloud: boolean
      cloud_service_url: string | null
      cloud_userName: string | null
      cloud_password: string | null
      cloud_downloadUrl: string | null
    }, ExtArgs["result"]["monitor_System_components"]>
    composites: {}
  }

  type Monitor_System_componentsGetPayload<S extends boolean | null | undefined | Monitor_System_componentsDefaultArgs> = $Result.GetResult<Prisma.$Monitor_System_componentsPayload, S>

  type Monitor_System_componentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<Monitor_System_componentsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Monitor_System_componentsCountAggregateInputType | true
    }

  export interface Monitor_System_componentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Monitor_System_components'], meta: { name: 'Monitor_System_components' } }
    /**
     * Find zero or one Monitor_System_components that matches the filter.
     * @param {Monitor_System_componentsFindUniqueArgs} args - Arguments to find a Monitor_System_components
     * @example
     * // Get one Monitor_System_components
     * const monitor_System_components = await prisma.monitor_System_components.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends Monitor_System_componentsFindUniqueArgs>(args: SelectSubset<T, Monitor_System_componentsFindUniqueArgs<ExtArgs>>): Prisma__Monitor_System_componentsClient<$Result.GetResult<Prisma.$Monitor_System_componentsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Monitor_System_components that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {Monitor_System_componentsFindUniqueOrThrowArgs} args - Arguments to find a Monitor_System_components
     * @example
     * // Get one Monitor_System_components
     * const monitor_System_components = await prisma.monitor_System_components.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends Monitor_System_componentsFindUniqueOrThrowArgs>(args: SelectSubset<T, Monitor_System_componentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__Monitor_System_componentsClient<$Result.GetResult<Prisma.$Monitor_System_componentsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Monitor_System_components that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_System_componentsFindFirstArgs} args - Arguments to find a Monitor_System_components
     * @example
     * // Get one Monitor_System_components
     * const monitor_System_components = await prisma.monitor_System_components.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends Monitor_System_componentsFindFirstArgs>(args?: SelectSubset<T, Monitor_System_componentsFindFirstArgs<ExtArgs>>): Prisma__Monitor_System_componentsClient<$Result.GetResult<Prisma.$Monitor_System_componentsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Monitor_System_components that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_System_componentsFindFirstOrThrowArgs} args - Arguments to find a Monitor_System_components
     * @example
     * // Get one Monitor_System_components
     * const monitor_System_components = await prisma.monitor_System_components.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends Monitor_System_componentsFindFirstOrThrowArgs>(args?: SelectSubset<T, Monitor_System_componentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__Monitor_System_componentsClient<$Result.GetResult<Prisma.$Monitor_System_componentsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Monitor_System_components that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_System_componentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Monitor_System_components
     * const monitor_System_components = await prisma.monitor_System_components.findMany()
     * 
     * // Get first 10 Monitor_System_components
     * const monitor_System_components = await prisma.monitor_System_components.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monitor_System_componentsWithIdOnly = await prisma.monitor_System_components.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends Monitor_System_componentsFindManyArgs>(args?: SelectSubset<T, Monitor_System_componentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Monitor_System_componentsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Monitor_System_components.
     * @param {Monitor_System_componentsCreateArgs} args - Arguments to create a Monitor_System_components.
     * @example
     * // Create one Monitor_System_components
     * const Monitor_System_components = await prisma.monitor_System_components.create({
     *   data: {
     *     // ... data to create a Monitor_System_components
     *   }
     * })
     * 
     */
    create<T extends Monitor_System_componentsCreateArgs>(args: SelectSubset<T, Monitor_System_componentsCreateArgs<ExtArgs>>): Prisma__Monitor_System_componentsClient<$Result.GetResult<Prisma.$Monitor_System_componentsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Monitor_System_components.
     * @param {Monitor_System_componentsCreateManyArgs} args - Arguments to create many Monitor_System_components.
     * @example
     * // Create many Monitor_System_components
     * const monitor_System_components = await prisma.monitor_System_components.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends Monitor_System_componentsCreateManyArgs>(args?: SelectSubset<T, Monitor_System_componentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Monitor_System_components.
     * @param {Monitor_System_componentsDeleteArgs} args - Arguments to delete one Monitor_System_components.
     * @example
     * // Delete one Monitor_System_components
     * const Monitor_System_components = await prisma.monitor_System_components.delete({
     *   where: {
     *     // ... filter to delete one Monitor_System_components
     *   }
     * })
     * 
     */
    delete<T extends Monitor_System_componentsDeleteArgs>(args: SelectSubset<T, Monitor_System_componentsDeleteArgs<ExtArgs>>): Prisma__Monitor_System_componentsClient<$Result.GetResult<Prisma.$Monitor_System_componentsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Monitor_System_components.
     * @param {Monitor_System_componentsUpdateArgs} args - Arguments to update one Monitor_System_components.
     * @example
     * // Update one Monitor_System_components
     * const monitor_System_components = await prisma.monitor_System_components.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends Monitor_System_componentsUpdateArgs>(args: SelectSubset<T, Monitor_System_componentsUpdateArgs<ExtArgs>>): Prisma__Monitor_System_componentsClient<$Result.GetResult<Prisma.$Monitor_System_componentsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Monitor_System_components.
     * @param {Monitor_System_componentsDeleteManyArgs} args - Arguments to filter Monitor_System_components to delete.
     * @example
     * // Delete a few Monitor_System_components
     * const { count } = await prisma.monitor_System_components.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends Monitor_System_componentsDeleteManyArgs>(args?: SelectSubset<T, Monitor_System_componentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Monitor_System_components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_System_componentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Monitor_System_components
     * const monitor_System_components = await prisma.monitor_System_components.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends Monitor_System_componentsUpdateManyArgs>(args: SelectSubset<T, Monitor_System_componentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Monitor_System_components.
     * @param {Monitor_System_componentsUpsertArgs} args - Arguments to update or create a Monitor_System_components.
     * @example
     * // Update or create a Monitor_System_components
     * const monitor_System_components = await prisma.monitor_System_components.upsert({
     *   create: {
     *     // ... data to create a Monitor_System_components
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Monitor_System_components we want to update
     *   }
     * })
     */
    upsert<T extends Monitor_System_componentsUpsertArgs>(args: SelectSubset<T, Monitor_System_componentsUpsertArgs<ExtArgs>>): Prisma__Monitor_System_componentsClient<$Result.GetResult<Prisma.$Monitor_System_componentsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Monitor_System_components that matches the filter.
     * @param {Monitor_System_componentsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const monitor_System_components = await prisma.monitor_System_components.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: Monitor_System_componentsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Monitor_System_components.
     * @param {Monitor_System_componentsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const monitor_System_components = await prisma.monitor_System_components.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: Monitor_System_componentsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Monitor_System_components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_System_componentsCountArgs} args - Arguments to filter Monitor_System_components to count.
     * @example
     * // Count the number of Monitor_System_components
     * const count = await prisma.monitor_System_components.count({
     *   where: {
     *     // ... the filter for the Monitor_System_components we want to count
     *   }
     * })
    **/
    count<T extends Monitor_System_componentsCountArgs>(
      args?: Subset<T, Monitor_System_componentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Monitor_System_componentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Monitor_System_components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_System_componentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Monitor_System_componentsAggregateArgs>(args: Subset<T, Monitor_System_componentsAggregateArgs>): Prisma.PrismaPromise<GetMonitor_System_componentsAggregateType<T>>

    /**
     * Group by Monitor_System_components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Monitor_System_componentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Monitor_System_componentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Monitor_System_componentsGroupByArgs['orderBy'] }
        : { orderBy?: Monitor_System_componentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Monitor_System_componentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonitor_System_componentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Monitor_System_components model
   */
  readonly fields: Monitor_System_componentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Monitor_System_components.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__Monitor_System_componentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monitor_config<T extends Monitor_configDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Monitor_configDefaultArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Monitor_System_components model
   */ 
  interface Monitor_System_componentsFieldRefs {
    readonly id: FieldRef<"Monitor_System_components", 'String'>
    readonly monitor_configId: FieldRef<"Monitor_System_components", 'String'>
    readonly components_lists: FieldRef<"Monitor_System_components", 'String[]'>
    readonly is_cloud: FieldRef<"Monitor_System_components", 'Boolean'>
    readonly cloud_service_url: FieldRef<"Monitor_System_components", 'String'>
    readonly cloud_userName: FieldRef<"Monitor_System_components", 'String'>
    readonly cloud_password: FieldRef<"Monitor_System_components", 'String'>
    readonly cloud_downloadUrl: FieldRef<"Monitor_System_components", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Monitor_System_components findUnique
   */
  export type Monitor_System_componentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_System_components
     */
    select?: Monitor_System_componentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_System_componentsInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_System_components to fetch.
     */
    where: Monitor_System_componentsWhereUniqueInput
  }

  /**
   * Monitor_System_components findUniqueOrThrow
   */
  export type Monitor_System_componentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_System_components
     */
    select?: Monitor_System_componentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_System_componentsInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_System_components to fetch.
     */
    where: Monitor_System_componentsWhereUniqueInput
  }

  /**
   * Monitor_System_components findFirst
   */
  export type Monitor_System_componentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_System_components
     */
    select?: Monitor_System_componentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_System_componentsInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_System_components to fetch.
     */
    where?: Monitor_System_componentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_System_components to fetch.
     */
    orderBy?: Monitor_System_componentsOrderByWithRelationInput | Monitor_System_componentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitor_System_components.
     */
    cursor?: Monitor_System_componentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_System_components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_System_components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitor_System_components.
     */
    distinct?: Monitor_System_componentsScalarFieldEnum | Monitor_System_componentsScalarFieldEnum[]
  }

  /**
   * Monitor_System_components findFirstOrThrow
   */
  export type Monitor_System_componentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_System_components
     */
    select?: Monitor_System_componentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_System_componentsInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_System_components to fetch.
     */
    where?: Monitor_System_componentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_System_components to fetch.
     */
    orderBy?: Monitor_System_componentsOrderByWithRelationInput | Monitor_System_componentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Monitor_System_components.
     */
    cursor?: Monitor_System_componentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_System_components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_System_components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Monitor_System_components.
     */
    distinct?: Monitor_System_componentsScalarFieldEnum | Monitor_System_componentsScalarFieldEnum[]
  }

  /**
   * Monitor_System_components findMany
   */
  export type Monitor_System_componentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_System_components
     */
    select?: Monitor_System_componentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_System_componentsInclude<ExtArgs> | null
    /**
     * Filter, which Monitor_System_components to fetch.
     */
    where?: Monitor_System_componentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Monitor_System_components to fetch.
     */
    orderBy?: Monitor_System_componentsOrderByWithRelationInput | Monitor_System_componentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Monitor_System_components.
     */
    cursor?: Monitor_System_componentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Monitor_System_components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Monitor_System_components.
     */
    skip?: number
    distinct?: Monitor_System_componentsScalarFieldEnum | Monitor_System_componentsScalarFieldEnum[]
  }

  /**
   * Monitor_System_components create
   */
  export type Monitor_System_componentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_System_components
     */
    select?: Monitor_System_componentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_System_componentsInclude<ExtArgs> | null
    /**
     * The data needed to create a Monitor_System_components.
     */
    data: XOR<Monitor_System_componentsCreateInput, Monitor_System_componentsUncheckedCreateInput>
  }

  /**
   * Monitor_System_components createMany
   */
  export type Monitor_System_componentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Monitor_System_components.
     */
    data: Monitor_System_componentsCreateManyInput | Monitor_System_componentsCreateManyInput[]
  }

  /**
   * Monitor_System_components update
   */
  export type Monitor_System_componentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_System_components
     */
    select?: Monitor_System_componentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_System_componentsInclude<ExtArgs> | null
    /**
     * The data needed to update a Monitor_System_components.
     */
    data: XOR<Monitor_System_componentsUpdateInput, Monitor_System_componentsUncheckedUpdateInput>
    /**
     * Choose, which Monitor_System_components to update.
     */
    where: Monitor_System_componentsWhereUniqueInput
  }

  /**
   * Monitor_System_components updateMany
   */
  export type Monitor_System_componentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Monitor_System_components.
     */
    data: XOR<Monitor_System_componentsUpdateManyMutationInput, Monitor_System_componentsUncheckedUpdateManyInput>
    /**
     * Filter which Monitor_System_components to update
     */
    where?: Monitor_System_componentsWhereInput
  }

  /**
   * Monitor_System_components upsert
   */
  export type Monitor_System_componentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_System_components
     */
    select?: Monitor_System_componentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_System_componentsInclude<ExtArgs> | null
    /**
     * The filter to search for the Monitor_System_components to update in case it exists.
     */
    where: Monitor_System_componentsWhereUniqueInput
    /**
     * In case the Monitor_System_components found by the `where` argument doesn't exist, create a new Monitor_System_components with this data.
     */
    create: XOR<Monitor_System_componentsCreateInput, Monitor_System_componentsUncheckedCreateInput>
    /**
     * In case the Monitor_System_components was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Monitor_System_componentsUpdateInput, Monitor_System_componentsUncheckedUpdateInput>
  }

  /**
   * Monitor_System_components delete
   */
  export type Monitor_System_componentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_System_components
     */
    select?: Monitor_System_componentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_System_componentsInclude<ExtArgs> | null
    /**
     * Filter which Monitor_System_components to delete.
     */
    where: Monitor_System_componentsWhereUniqueInput
  }

  /**
   * Monitor_System_components deleteMany
   */
  export type Monitor_System_componentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Monitor_System_components to delete
     */
    where?: Monitor_System_componentsWhereInput
  }

  /**
   * Monitor_System_components findRaw
   */
  export type Monitor_System_componentsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Monitor_System_components aggregateRaw
   */
  export type Monitor_System_componentsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Monitor_System_components without action
   */
  export type Monitor_System_componentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_System_components
     */
    select?: Monitor_System_componentsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_System_componentsInclude<ExtArgs> | null
  }


  /**
   * Model WorkSpace
   */

  export type AggregateWorkSpace = {
    _count: WorkSpaceCountAggregateOutputType | null
    _min: WorkSpaceMinAggregateOutputType | null
    _max: WorkSpaceMaxAggregateOutputType | null
  }

  export type WorkSpaceMinAggregateOutputType = {
    id: string | null
    ownerId: string | null
    workspace_name: string | null
    trial_startDate: Date | null
    trial_endDate: Date | null
    subscription_start: Date | null
    subscription_end: Date | null
  }

  export type WorkSpaceMaxAggregateOutputType = {
    id: string | null
    ownerId: string | null
    workspace_name: string | null
    trial_startDate: Date | null
    trial_endDate: Date | null
    subscription_start: Date | null
    subscription_end: Date | null
  }

  export type WorkSpaceCountAggregateOutputType = {
    id: number
    ownerId: number
    workspace_name: number
    trial_startDate: number
    trial_endDate: number
    subscription_start: number
    subscription_end: number
    _all: number
  }


  export type WorkSpaceMinAggregateInputType = {
    id?: true
    ownerId?: true
    workspace_name?: true
    trial_startDate?: true
    trial_endDate?: true
    subscription_start?: true
    subscription_end?: true
  }

  export type WorkSpaceMaxAggregateInputType = {
    id?: true
    ownerId?: true
    workspace_name?: true
    trial_startDate?: true
    trial_endDate?: true
    subscription_start?: true
    subscription_end?: true
  }

  export type WorkSpaceCountAggregateInputType = {
    id?: true
    ownerId?: true
    workspace_name?: true
    trial_startDate?: true
    trial_endDate?: true
    subscription_start?: true
    subscription_end?: true
    _all?: true
  }

  export type WorkSpaceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkSpace to aggregate.
     */
    where?: WorkSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSpaces to fetch.
     */
    orderBy?: WorkSpaceOrderByWithRelationInput | WorkSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkSpaces
    **/
    _count?: true | WorkSpaceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkSpaceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkSpaceMaxAggregateInputType
  }

  export type GetWorkSpaceAggregateType<T extends WorkSpaceAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkSpace]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkSpace[P]>
      : GetScalarType<T[P], AggregateWorkSpace[P]>
  }




  export type WorkSpaceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkSpaceWhereInput
    orderBy?: WorkSpaceOrderByWithAggregationInput | WorkSpaceOrderByWithAggregationInput[]
    by: WorkSpaceScalarFieldEnum[] | WorkSpaceScalarFieldEnum
    having?: WorkSpaceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkSpaceCountAggregateInputType | true
    _min?: WorkSpaceMinAggregateInputType
    _max?: WorkSpaceMaxAggregateInputType
  }

  export type WorkSpaceGroupByOutputType = {
    id: string
    ownerId: string
    workspace_name: string
    trial_startDate: Date
    trial_endDate: Date
    subscription_start: Date | null
    subscription_end: Date | null
    _count: WorkSpaceCountAggregateOutputType | null
    _min: WorkSpaceMinAggregateOutputType | null
    _max: WorkSpaceMaxAggregateOutputType | null
  }

  type GetWorkSpaceGroupByPayload<T extends WorkSpaceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkSpaceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkSpaceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkSpaceGroupByOutputType[P]>
            : GetScalarType<T[P], WorkSpaceGroupByOutputType[P]>
        }
      >
    >


  export type WorkSpaceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ownerId?: boolean
    workspace_name?: boolean
    trial_startDate?: boolean
    trial_endDate?: boolean
    subscription_start?: boolean
    subscription_end?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    monitor_config?: boolean | WorkSpace$monitor_configArgs<ExtArgs>
    workspace_users?: boolean | WorkSpace$workspace_usersArgs<ExtArgs>
    invited_users?: boolean | WorkSpace$invited_usersArgs<ExtArgs>
    team?: boolean | WorkSpace$teamArgs<ExtArgs>
    team_member?: boolean | WorkSpace$team_memberArgs<ExtArgs>
    alert?: boolean | WorkSpace$alertArgs<ExtArgs>
    _count?: boolean | WorkSpaceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workSpace"]>


  export type WorkSpaceSelectScalar = {
    id?: boolean
    ownerId?: boolean
    workspace_name?: boolean
    trial_startDate?: boolean
    trial_endDate?: boolean
    subscription_start?: boolean
    subscription_end?: boolean
  }

  export type WorkSpaceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    monitor_config?: boolean | WorkSpace$monitor_configArgs<ExtArgs>
    workspace_users?: boolean | WorkSpace$workspace_usersArgs<ExtArgs>
    invited_users?: boolean | WorkSpace$invited_usersArgs<ExtArgs>
    team?: boolean | WorkSpace$teamArgs<ExtArgs>
    team_member?: boolean | WorkSpace$team_memberArgs<ExtArgs>
    alert?: boolean | WorkSpace$alertArgs<ExtArgs>
    _count?: boolean | WorkSpaceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WorkSpacePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkSpace"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      monitor_config: Prisma.$Monitor_configPayload<ExtArgs>[]
      workspace_users: Prisma.$WorkSpace_usersPayload<ExtArgs>[]
      invited_users: Prisma.$invited_usersPayload<ExtArgs>[]
      team: Prisma.$teamPayload<ExtArgs>[]
      team_member: Prisma.$team_memberPayload<ExtArgs>[]
      alert: Prisma.$alertPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      ownerId: string
      workspace_name: string
      trial_startDate: Date
      trial_endDate: Date
      subscription_start: Date | null
      subscription_end: Date | null
    }, ExtArgs["result"]["workSpace"]>
    composites: {}
  }

  type WorkSpaceGetPayload<S extends boolean | null | undefined | WorkSpaceDefaultArgs> = $Result.GetResult<Prisma.$WorkSpacePayload, S>

  type WorkSpaceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkSpaceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkSpaceCountAggregateInputType | true
    }

  export interface WorkSpaceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkSpace'], meta: { name: 'WorkSpace' } }
    /**
     * Find zero or one WorkSpace that matches the filter.
     * @param {WorkSpaceFindUniqueArgs} args - Arguments to find a WorkSpace
     * @example
     * // Get one WorkSpace
     * const workSpace = await prisma.workSpace.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkSpaceFindUniqueArgs>(args: SelectSubset<T, WorkSpaceFindUniqueArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkSpace that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkSpaceFindUniqueOrThrowArgs} args - Arguments to find a WorkSpace
     * @example
     * // Get one WorkSpace
     * const workSpace = await prisma.workSpace.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkSpaceFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkSpaceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkSpace that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpaceFindFirstArgs} args - Arguments to find a WorkSpace
     * @example
     * // Get one WorkSpace
     * const workSpace = await prisma.workSpace.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkSpaceFindFirstArgs>(args?: SelectSubset<T, WorkSpaceFindFirstArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkSpace that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpaceFindFirstOrThrowArgs} args - Arguments to find a WorkSpace
     * @example
     * // Get one WorkSpace
     * const workSpace = await prisma.workSpace.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkSpaceFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkSpaceFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkSpaces that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpaceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkSpaces
     * const workSpaces = await prisma.workSpace.findMany()
     * 
     * // Get first 10 WorkSpaces
     * const workSpaces = await prisma.workSpace.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workSpaceWithIdOnly = await prisma.workSpace.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkSpaceFindManyArgs>(args?: SelectSubset<T, WorkSpaceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkSpace.
     * @param {WorkSpaceCreateArgs} args - Arguments to create a WorkSpace.
     * @example
     * // Create one WorkSpace
     * const WorkSpace = await prisma.workSpace.create({
     *   data: {
     *     // ... data to create a WorkSpace
     *   }
     * })
     * 
     */
    create<T extends WorkSpaceCreateArgs>(args: SelectSubset<T, WorkSpaceCreateArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkSpaces.
     * @param {WorkSpaceCreateManyArgs} args - Arguments to create many WorkSpaces.
     * @example
     * // Create many WorkSpaces
     * const workSpace = await prisma.workSpace.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkSpaceCreateManyArgs>(args?: SelectSubset<T, WorkSpaceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkSpace.
     * @param {WorkSpaceDeleteArgs} args - Arguments to delete one WorkSpace.
     * @example
     * // Delete one WorkSpace
     * const WorkSpace = await prisma.workSpace.delete({
     *   where: {
     *     // ... filter to delete one WorkSpace
     *   }
     * })
     * 
     */
    delete<T extends WorkSpaceDeleteArgs>(args: SelectSubset<T, WorkSpaceDeleteArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkSpace.
     * @param {WorkSpaceUpdateArgs} args - Arguments to update one WorkSpace.
     * @example
     * // Update one WorkSpace
     * const workSpace = await prisma.workSpace.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkSpaceUpdateArgs>(args: SelectSubset<T, WorkSpaceUpdateArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkSpaces.
     * @param {WorkSpaceDeleteManyArgs} args - Arguments to filter WorkSpaces to delete.
     * @example
     * // Delete a few WorkSpaces
     * const { count } = await prisma.workSpace.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkSpaceDeleteManyArgs>(args?: SelectSubset<T, WorkSpaceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkSpaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpaceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkSpaces
     * const workSpace = await prisma.workSpace.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkSpaceUpdateManyArgs>(args: SelectSubset<T, WorkSpaceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkSpace.
     * @param {WorkSpaceUpsertArgs} args - Arguments to update or create a WorkSpace.
     * @example
     * // Update or create a WorkSpace
     * const workSpace = await prisma.workSpace.upsert({
     *   create: {
     *     // ... data to create a WorkSpace
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkSpace we want to update
     *   }
     * })
     */
    upsert<T extends WorkSpaceUpsertArgs>(args: SelectSubset<T, WorkSpaceUpsertArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more WorkSpaces that matches the filter.
     * @param {WorkSpaceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const workSpace = await prisma.workSpace.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: WorkSpaceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a WorkSpace.
     * @param {WorkSpaceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const workSpace = await prisma.workSpace.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: WorkSpaceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of WorkSpaces.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpaceCountArgs} args - Arguments to filter WorkSpaces to count.
     * @example
     * // Count the number of WorkSpaces
     * const count = await prisma.workSpace.count({
     *   where: {
     *     // ... the filter for the WorkSpaces we want to count
     *   }
     * })
    **/
    count<T extends WorkSpaceCountArgs>(
      args?: Subset<T, WorkSpaceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkSpaceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkSpace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpaceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkSpaceAggregateArgs>(args: Subset<T, WorkSpaceAggregateArgs>): Prisma.PrismaPromise<GetWorkSpaceAggregateType<T>>

    /**
     * Group by WorkSpace.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpaceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkSpaceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkSpaceGroupByArgs['orderBy'] }
        : { orderBy?: WorkSpaceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkSpaceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkSpaceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkSpace model
   */
  readonly fields: WorkSpaceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkSpace.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkSpaceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    monitor_config<T extends WorkSpace$monitor_configArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpace$monitor_configArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findMany"> | Null>
    workspace_users<T extends WorkSpace$workspace_usersArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpace$workspace_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "findMany"> | Null>
    invited_users<T extends WorkSpace$invited_usersArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpace$invited_usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invited_usersPayload<ExtArgs>, T, "findMany"> | Null>
    team<T extends WorkSpace$teamArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpace$teamArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findMany"> | Null>
    team_member<T extends WorkSpace$team_memberArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpace$team_memberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "findMany"> | Null>
    alert<T extends WorkSpace$alertArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpace$alertArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkSpace model
   */ 
  interface WorkSpaceFieldRefs {
    readonly id: FieldRef<"WorkSpace", 'String'>
    readonly ownerId: FieldRef<"WorkSpace", 'String'>
    readonly workspace_name: FieldRef<"WorkSpace", 'String'>
    readonly trial_startDate: FieldRef<"WorkSpace", 'DateTime'>
    readonly trial_endDate: FieldRef<"WorkSpace", 'DateTime'>
    readonly subscription_start: FieldRef<"WorkSpace", 'DateTime'>
    readonly subscription_end: FieldRef<"WorkSpace", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkSpace findUnique
   */
  export type WorkSpaceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
    /**
     * Filter, which WorkSpace to fetch.
     */
    where: WorkSpaceWhereUniqueInput
  }

  /**
   * WorkSpace findUniqueOrThrow
   */
  export type WorkSpaceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
    /**
     * Filter, which WorkSpace to fetch.
     */
    where: WorkSpaceWhereUniqueInput
  }

  /**
   * WorkSpace findFirst
   */
  export type WorkSpaceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
    /**
     * Filter, which WorkSpace to fetch.
     */
    where?: WorkSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSpaces to fetch.
     */
    orderBy?: WorkSpaceOrderByWithRelationInput | WorkSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkSpaces.
     */
    cursor?: WorkSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkSpaces.
     */
    distinct?: WorkSpaceScalarFieldEnum | WorkSpaceScalarFieldEnum[]
  }

  /**
   * WorkSpace findFirstOrThrow
   */
  export type WorkSpaceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
    /**
     * Filter, which WorkSpace to fetch.
     */
    where?: WorkSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSpaces to fetch.
     */
    orderBy?: WorkSpaceOrderByWithRelationInput | WorkSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkSpaces.
     */
    cursor?: WorkSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSpaces.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkSpaces.
     */
    distinct?: WorkSpaceScalarFieldEnum | WorkSpaceScalarFieldEnum[]
  }

  /**
   * WorkSpace findMany
   */
  export type WorkSpaceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
    /**
     * Filter, which WorkSpaces to fetch.
     */
    where?: WorkSpaceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSpaces to fetch.
     */
    orderBy?: WorkSpaceOrderByWithRelationInput | WorkSpaceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkSpaces.
     */
    cursor?: WorkSpaceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSpaces from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSpaces.
     */
    skip?: number
    distinct?: WorkSpaceScalarFieldEnum | WorkSpaceScalarFieldEnum[]
  }

  /**
   * WorkSpace create
   */
  export type WorkSpaceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkSpace.
     */
    data: XOR<WorkSpaceCreateInput, WorkSpaceUncheckedCreateInput>
  }

  /**
   * WorkSpace createMany
   */
  export type WorkSpaceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkSpaces.
     */
    data: WorkSpaceCreateManyInput | WorkSpaceCreateManyInput[]
  }

  /**
   * WorkSpace update
   */
  export type WorkSpaceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkSpace.
     */
    data: XOR<WorkSpaceUpdateInput, WorkSpaceUncheckedUpdateInput>
    /**
     * Choose, which WorkSpace to update.
     */
    where: WorkSpaceWhereUniqueInput
  }

  /**
   * WorkSpace updateMany
   */
  export type WorkSpaceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkSpaces.
     */
    data: XOR<WorkSpaceUpdateManyMutationInput, WorkSpaceUncheckedUpdateManyInput>
    /**
     * Filter which WorkSpaces to update
     */
    where?: WorkSpaceWhereInput
  }

  /**
   * WorkSpace upsert
   */
  export type WorkSpaceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkSpace to update in case it exists.
     */
    where: WorkSpaceWhereUniqueInput
    /**
     * In case the WorkSpace found by the `where` argument doesn't exist, create a new WorkSpace with this data.
     */
    create: XOR<WorkSpaceCreateInput, WorkSpaceUncheckedCreateInput>
    /**
     * In case the WorkSpace was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkSpaceUpdateInput, WorkSpaceUncheckedUpdateInput>
  }

  /**
   * WorkSpace delete
   */
  export type WorkSpaceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
    /**
     * Filter which WorkSpace to delete.
     */
    where: WorkSpaceWhereUniqueInput
  }

  /**
   * WorkSpace deleteMany
   */
  export type WorkSpaceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkSpaces to delete
     */
    where?: WorkSpaceWhereInput
  }

  /**
   * WorkSpace findRaw
   */
  export type WorkSpaceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WorkSpace aggregateRaw
   */
  export type WorkSpaceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WorkSpace.monitor_config
   */
  export type WorkSpace$monitor_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    where?: Monitor_configWhereInput
    orderBy?: Monitor_configOrderByWithRelationInput | Monitor_configOrderByWithRelationInput[]
    cursor?: Monitor_configWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Monitor_configScalarFieldEnum | Monitor_configScalarFieldEnum[]
  }

  /**
   * WorkSpace.workspace_users
   */
  export type WorkSpace$workspace_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
    where?: WorkSpace_usersWhereInput
    orderBy?: WorkSpace_usersOrderByWithRelationInput | WorkSpace_usersOrderByWithRelationInput[]
    cursor?: WorkSpace_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkSpace_usersScalarFieldEnum | WorkSpace_usersScalarFieldEnum[]
  }

  /**
   * WorkSpace.invited_users
   */
  export type WorkSpace$invited_usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invited_users
     */
    select?: invited_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invited_usersInclude<ExtArgs> | null
    where?: invited_usersWhereInput
    orderBy?: invited_usersOrderByWithRelationInput | invited_usersOrderByWithRelationInput[]
    cursor?: invited_usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Invited_usersScalarFieldEnum | Invited_usersScalarFieldEnum[]
  }

  /**
   * WorkSpace.team
   */
  export type WorkSpace$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    cursor?: teamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * WorkSpace.team_member
   */
  export type WorkSpace$team_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    where?: team_memberWhereInput
    orderBy?: team_memberOrderByWithRelationInput | team_memberOrderByWithRelationInput[]
    cursor?: team_memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_memberScalarFieldEnum | Team_memberScalarFieldEnum[]
  }

  /**
   * WorkSpace.alert
   */
  export type WorkSpace$alertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    where?: alertWhereInput
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    cursor?: alertWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * WorkSpace without action
   */
  export type WorkSpaceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace
     */
    select?: WorkSpaceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpaceInclude<ExtArgs> | null
  }


  /**
   * Model invited_users
   */

  export type AggregateInvited_users = {
    _count: Invited_usersCountAggregateOutputType | null
    _min: Invited_usersMinAggregateOutputType | null
    _max: Invited_usersMaxAggregateOutputType | null
  }

  export type Invited_usersMinAggregateOutputType = {
    id: string | null
    invited_user_name: string | null
    invited_user_email_id: string | null
    invited_by: string | null
    workspaceId: string | null
    role: $Enums.Role | null
    status: $Enums.status | null
    invited_on: Date | null
  }

  export type Invited_usersMaxAggregateOutputType = {
    id: string | null
    invited_user_name: string | null
    invited_user_email_id: string | null
    invited_by: string | null
    workspaceId: string | null
    role: $Enums.Role | null
    status: $Enums.status | null
    invited_on: Date | null
  }

  export type Invited_usersCountAggregateOutputType = {
    id: number
    invited_user_name: number
    invited_user_email_id: number
    invited_by: number
    workspaceId: number
    role: number
    status: number
    invited_on: number
    _all: number
  }


  export type Invited_usersMinAggregateInputType = {
    id?: true
    invited_user_name?: true
    invited_user_email_id?: true
    invited_by?: true
    workspaceId?: true
    role?: true
    status?: true
    invited_on?: true
  }

  export type Invited_usersMaxAggregateInputType = {
    id?: true
    invited_user_name?: true
    invited_user_email_id?: true
    invited_by?: true
    workspaceId?: true
    role?: true
    status?: true
    invited_on?: true
  }

  export type Invited_usersCountAggregateInputType = {
    id?: true
    invited_user_name?: true
    invited_user_email_id?: true
    invited_by?: true
    workspaceId?: true
    role?: true
    status?: true
    invited_on?: true
    _all?: true
  }

  export type Invited_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invited_users to aggregate.
     */
    where?: invited_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invited_users to fetch.
     */
    orderBy?: invited_usersOrderByWithRelationInput | invited_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: invited_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invited_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invited_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned invited_users
    **/
    _count?: true | Invited_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Invited_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Invited_usersMaxAggregateInputType
  }

  export type GetInvited_usersAggregateType<T extends Invited_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateInvited_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvited_users[P]>
      : GetScalarType<T[P], AggregateInvited_users[P]>
  }




  export type invited_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: invited_usersWhereInput
    orderBy?: invited_usersOrderByWithAggregationInput | invited_usersOrderByWithAggregationInput[]
    by: Invited_usersScalarFieldEnum[] | Invited_usersScalarFieldEnum
    having?: invited_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Invited_usersCountAggregateInputType | true
    _min?: Invited_usersMinAggregateInputType
    _max?: Invited_usersMaxAggregateInputType
  }

  export type Invited_usersGroupByOutputType = {
    id: string
    invited_user_name: string
    invited_user_email_id: string
    invited_by: string
    workspaceId: string
    role: $Enums.Role
    status: $Enums.status
    invited_on: Date
    _count: Invited_usersCountAggregateOutputType | null
    _min: Invited_usersMinAggregateOutputType | null
    _max: Invited_usersMaxAggregateOutputType | null
  }

  type GetInvited_usersGroupByPayload<T extends invited_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Invited_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Invited_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Invited_usersGroupByOutputType[P]>
            : GetScalarType<T[P], Invited_usersGroupByOutputType[P]>
        }
      >
    >


  export type invited_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invited_user_name?: boolean
    invited_user_email_id?: boolean
    invited_by?: boolean
    workspaceId?: boolean
    role?: boolean
    status?: boolean
    invited_on?: boolean
    wokspace?: boolean | WorkSpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invited_users"]>


  export type invited_usersSelectScalar = {
    id?: boolean
    invited_user_name?: boolean
    invited_user_email_id?: boolean
    invited_by?: boolean
    workspaceId?: boolean
    role?: boolean
    status?: boolean
    invited_on?: boolean
  }

  export type invited_usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    wokspace?: boolean | WorkSpaceDefaultArgs<ExtArgs>
  }

  export type $invited_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "invited_users"
    objects: {
      wokspace: Prisma.$WorkSpacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invited_user_name: string
      invited_user_email_id: string
      invited_by: string
      workspaceId: string
      role: $Enums.Role
      status: $Enums.status
      invited_on: Date
    }, ExtArgs["result"]["invited_users"]>
    composites: {}
  }

  type invited_usersGetPayload<S extends boolean | null | undefined | invited_usersDefaultArgs> = $Result.GetResult<Prisma.$invited_usersPayload, S>

  type invited_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<invited_usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Invited_usersCountAggregateInputType | true
    }

  export interface invited_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['invited_users'], meta: { name: 'invited_users' } }
    /**
     * Find zero or one Invited_users that matches the filter.
     * @param {invited_usersFindUniqueArgs} args - Arguments to find a Invited_users
     * @example
     * // Get one Invited_users
     * const invited_users = await prisma.invited_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends invited_usersFindUniqueArgs>(args: SelectSubset<T, invited_usersFindUniqueArgs<ExtArgs>>): Prisma__invited_usersClient<$Result.GetResult<Prisma.$invited_usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Invited_users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {invited_usersFindUniqueOrThrowArgs} args - Arguments to find a Invited_users
     * @example
     * // Get one Invited_users
     * const invited_users = await prisma.invited_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends invited_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, invited_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__invited_usersClient<$Result.GetResult<Prisma.$invited_usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Invited_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invited_usersFindFirstArgs} args - Arguments to find a Invited_users
     * @example
     * // Get one Invited_users
     * const invited_users = await prisma.invited_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends invited_usersFindFirstArgs>(args?: SelectSubset<T, invited_usersFindFirstArgs<ExtArgs>>): Prisma__invited_usersClient<$Result.GetResult<Prisma.$invited_usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Invited_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invited_usersFindFirstOrThrowArgs} args - Arguments to find a Invited_users
     * @example
     * // Get one Invited_users
     * const invited_users = await prisma.invited_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends invited_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, invited_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__invited_usersClient<$Result.GetResult<Prisma.$invited_usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Invited_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invited_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invited_users
     * const invited_users = await prisma.invited_users.findMany()
     * 
     * // Get first 10 Invited_users
     * const invited_users = await prisma.invited_users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invited_usersWithIdOnly = await prisma.invited_users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends invited_usersFindManyArgs>(args?: SelectSubset<T, invited_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$invited_usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Invited_users.
     * @param {invited_usersCreateArgs} args - Arguments to create a Invited_users.
     * @example
     * // Create one Invited_users
     * const Invited_users = await prisma.invited_users.create({
     *   data: {
     *     // ... data to create a Invited_users
     *   }
     * })
     * 
     */
    create<T extends invited_usersCreateArgs>(args: SelectSubset<T, invited_usersCreateArgs<ExtArgs>>): Prisma__invited_usersClient<$Result.GetResult<Prisma.$invited_usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Invited_users.
     * @param {invited_usersCreateManyArgs} args - Arguments to create many Invited_users.
     * @example
     * // Create many Invited_users
     * const invited_users = await prisma.invited_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends invited_usersCreateManyArgs>(args?: SelectSubset<T, invited_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Invited_users.
     * @param {invited_usersDeleteArgs} args - Arguments to delete one Invited_users.
     * @example
     * // Delete one Invited_users
     * const Invited_users = await prisma.invited_users.delete({
     *   where: {
     *     // ... filter to delete one Invited_users
     *   }
     * })
     * 
     */
    delete<T extends invited_usersDeleteArgs>(args: SelectSubset<T, invited_usersDeleteArgs<ExtArgs>>): Prisma__invited_usersClient<$Result.GetResult<Prisma.$invited_usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Invited_users.
     * @param {invited_usersUpdateArgs} args - Arguments to update one Invited_users.
     * @example
     * // Update one Invited_users
     * const invited_users = await prisma.invited_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends invited_usersUpdateArgs>(args: SelectSubset<T, invited_usersUpdateArgs<ExtArgs>>): Prisma__invited_usersClient<$Result.GetResult<Prisma.$invited_usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Invited_users.
     * @param {invited_usersDeleteManyArgs} args - Arguments to filter Invited_users to delete.
     * @example
     * // Delete a few Invited_users
     * const { count } = await prisma.invited_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends invited_usersDeleteManyArgs>(args?: SelectSubset<T, invited_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invited_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invited_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invited_users
     * const invited_users = await prisma.invited_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends invited_usersUpdateManyArgs>(args: SelectSubset<T, invited_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Invited_users.
     * @param {invited_usersUpsertArgs} args - Arguments to update or create a Invited_users.
     * @example
     * // Update or create a Invited_users
     * const invited_users = await prisma.invited_users.upsert({
     *   create: {
     *     // ... data to create a Invited_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invited_users we want to update
     *   }
     * })
     */
    upsert<T extends invited_usersUpsertArgs>(args: SelectSubset<T, invited_usersUpsertArgs<ExtArgs>>): Prisma__invited_usersClient<$Result.GetResult<Prisma.$invited_usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Invited_users that matches the filter.
     * @param {invited_usersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const invited_users = await prisma.invited_users.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: invited_usersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Invited_users.
     * @param {invited_usersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const invited_users = await prisma.invited_users.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: invited_usersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Invited_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invited_usersCountArgs} args - Arguments to filter Invited_users to count.
     * @example
     * // Count the number of Invited_users
     * const count = await prisma.invited_users.count({
     *   where: {
     *     // ... the filter for the Invited_users we want to count
     *   }
     * })
    **/
    count<T extends invited_usersCountArgs>(
      args?: Subset<T, invited_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Invited_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invited_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Invited_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Invited_usersAggregateArgs>(args: Subset<T, Invited_usersAggregateArgs>): Prisma.PrismaPromise<GetInvited_usersAggregateType<T>>

    /**
     * Group by Invited_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {invited_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends invited_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: invited_usersGroupByArgs['orderBy'] }
        : { orderBy?: invited_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, invited_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvited_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the invited_users model
   */
  readonly fields: invited_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for invited_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__invited_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    wokspace<T extends WorkSpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpaceDefaultArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the invited_users model
   */ 
  interface invited_usersFieldRefs {
    readonly id: FieldRef<"invited_users", 'String'>
    readonly invited_user_name: FieldRef<"invited_users", 'String'>
    readonly invited_user_email_id: FieldRef<"invited_users", 'String'>
    readonly invited_by: FieldRef<"invited_users", 'String'>
    readonly workspaceId: FieldRef<"invited_users", 'String'>
    readonly role: FieldRef<"invited_users", 'Role'>
    readonly status: FieldRef<"invited_users", 'status'>
    readonly invited_on: FieldRef<"invited_users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * invited_users findUnique
   */
  export type invited_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invited_users
     */
    select?: invited_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invited_usersInclude<ExtArgs> | null
    /**
     * Filter, which invited_users to fetch.
     */
    where: invited_usersWhereUniqueInput
  }

  /**
   * invited_users findUniqueOrThrow
   */
  export type invited_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invited_users
     */
    select?: invited_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invited_usersInclude<ExtArgs> | null
    /**
     * Filter, which invited_users to fetch.
     */
    where: invited_usersWhereUniqueInput
  }

  /**
   * invited_users findFirst
   */
  export type invited_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invited_users
     */
    select?: invited_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invited_usersInclude<ExtArgs> | null
    /**
     * Filter, which invited_users to fetch.
     */
    where?: invited_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invited_users to fetch.
     */
    orderBy?: invited_usersOrderByWithRelationInput | invited_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invited_users.
     */
    cursor?: invited_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invited_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invited_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invited_users.
     */
    distinct?: Invited_usersScalarFieldEnum | Invited_usersScalarFieldEnum[]
  }

  /**
   * invited_users findFirstOrThrow
   */
  export type invited_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invited_users
     */
    select?: invited_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invited_usersInclude<ExtArgs> | null
    /**
     * Filter, which invited_users to fetch.
     */
    where?: invited_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invited_users to fetch.
     */
    orderBy?: invited_usersOrderByWithRelationInput | invited_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for invited_users.
     */
    cursor?: invited_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invited_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invited_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of invited_users.
     */
    distinct?: Invited_usersScalarFieldEnum | Invited_usersScalarFieldEnum[]
  }

  /**
   * invited_users findMany
   */
  export type invited_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invited_users
     */
    select?: invited_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invited_usersInclude<ExtArgs> | null
    /**
     * Filter, which invited_users to fetch.
     */
    where?: invited_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of invited_users to fetch.
     */
    orderBy?: invited_usersOrderByWithRelationInput | invited_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing invited_users.
     */
    cursor?: invited_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` invited_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` invited_users.
     */
    skip?: number
    distinct?: Invited_usersScalarFieldEnum | Invited_usersScalarFieldEnum[]
  }

  /**
   * invited_users create
   */
  export type invited_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invited_users
     */
    select?: invited_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invited_usersInclude<ExtArgs> | null
    /**
     * The data needed to create a invited_users.
     */
    data: XOR<invited_usersCreateInput, invited_usersUncheckedCreateInput>
  }

  /**
   * invited_users createMany
   */
  export type invited_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many invited_users.
     */
    data: invited_usersCreateManyInput | invited_usersCreateManyInput[]
  }

  /**
   * invited_users update
   */
  export type invited_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invited_users
     */
    select?: invited_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invited_usersInclude<ExtArgs> | null
    /**
     * The data needed to update a invited_users.
     */
    data: XOR<invited_usersUpdateInput, invited_usersUncheckedUpdateInput>
    /**
     * Choose, which invited_users to update.
     */
    where: invited_usersWhereUniqueInput
  }

  /**
   * invited_users updateMany
   */
  export type invited_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update invited_users.
     */
    data: XOR<invited_usersUpdateManyMutationInput, invited_usersUncheckedUpdateManyInput>
    /**
     * Filter which invited_users to update
     */
    where?: invited_usersWhereInput
  }

  /**
   * invited_users upsert
   */
  export type invited_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invited_users
     */
    select?: invited_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invited_usersInclude<ExtArgs> | null
    /**
     * The filter to search for the invited_users to update in case it exists.
     */
    where: invited_usersWhereUniqueInput
    /**
     * In case the invited_users found by the `where` argument doesn't exist, create a new invited_users with this data.
     */
    create: XOR<invited_usersCreateInput, invited_usersUncheckedCreateInput>
    /**
     * In case the invited_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<invited_usersUpdateInput, invited_usersUncheckedUpdateInput>
  }

  /**
   * invited_users delete
   */
  export type invited_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invited_users
     */
    select?: invited_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invited_usersInclude<ExtArgs> | null
    /**
     * Filter which invited_users to delete.
     */
    where: invited_usersWhereUniqueInput
  }

  /**
   * invited_users deleteMany
   */
  export type invited_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which invited_users to delete
     */
    where?: invited_usersWhereInput
  }

  /**
   * invited_users findRaw
   */
  export type invited_usersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * invited_users aggregateRaw
   */
  export type invited_usersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * invited_users without action
   */
  export type invited_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the invited_users
     */
    select?: invited_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: invited_usersInclude<ExtArgs> | null
  }


  /**
   * Model WorkSpace_users
   */

  export type AggregateWorkSpace_users = {
    _count: WorkSpace_usersCountAggregateOutputType | null
    _min: WorkSpace_usersMinAggregateOutputType | null
    _max: WorkSpace_usersMaxAggregateOutputType | null
  }

  export type WorkSpace_usersMinAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    role: $Enums.Role | null
    createdAt: Date | null
  }

  export type WorkSpace_usersMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    workspaceId: string | null
    role: $Enums.Role | null
    createdAt: Date | null
  }

  export type WorkSpace_usersCountAggregateOutputType = {
    id: number
    userId: number
    workspaceId: number
    role: number
    createdAt: number
    _all: number
  }


  export type WorkSpace_usersMinAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    createdAt?: true
  }

  export type WorkSpace_usersMaxAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    createdAt?: true
  }

  export type WorkSpace_usersCountAggregateInputType = {
    id?: true
    userId?: true
    workspaceId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type WorkSpace_usersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkSpace_users to aggregate.
     */
    where?: WorkSpace_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSpace_users to fetch.
     */
    orderBy?: WorkSpace_usersOrderByWithRelationInput | WorkSpace_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkSpace_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSpace_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSpace_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WorkSpace_users
    **/
    _count?: true | WorkSpace_usersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkSpace_usersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkSpace_usersMaxAggregateInputType
  }

  export type GetWorkSpace_usersAggregateType<T extends WorkSpace_usersAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkSpace_users]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkSpace_users[P]>
      : GetScalarType<T[P], AggregateWorkSpace_users[P]>
  }




  export type WorkSpace_usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkSpace_usersWhereInput
    orderBy?: WorkSpace_usersOrderByWithAggregationInput | WorkSpace_usersOrderByWithAggregationInput[]
    by: WorkSpace_usersScalarFieldEnum[] | WorkSpace_usersScalarFieldEnum
    having?: WorkSpace_usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkSpace_usersCountAggregateInputType | true
    _min?: WorkSpace_usersMinAggregateInputType
    _max?: WorkSpace_usersMaxAggregateInputType
  }

  export type WorkSpace_usersGroupByOutputType = {
    id: string
    userId: string
    workspaceId: string
    role: $Enums.Role
    createdAt: Date
    _count: WorkSpace_usersCountAggregateOutputType | null
    _min: WorkSpace_usersMinAggregateOutputType | null
    _max: WorkSpace_usersMaxAggregateOutputType | null
  }

  type GetWorkSpace_usersGroupByPayload<T extends WorkSpace_usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkSpace_usersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkSpace_usersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkSpace_usersGroupByOutputType[P]>
            : GetScalarType<T[P], WorkSpace_usersGroupByOutputType[P]>
        }
      >
    >


  export type WorkSpace_usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkSpaceDefaultArgs<ExtArgs>
    team_member?: boolean | WorkSpace_users$team_memberArgs<ExtArgs>
    _count?: boolean | WorkSpace_usersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workSpace_users"]>


  export type WorkSpace_usersSelectScalar = {
    id?: boolean
    userId?: boolean
    workspaceId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type WorkSpace_usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkSpaceDefaultArgs<ExtArgs>
    team_member?: boolean | WorkSpace_users$team_memberArgs<ExtArgs>
    _count?: boolean | WorkSpace_usersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $WorkSpace_usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WorkSpace_users"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkSpacePayload<ExtArgs>
      team_member: Prisma.$team_memberPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      workspaceId: string
      role: $Enums.Role
      createdAt: Date
    }, ExtArgs["result"]["workSpace_users"]>
    composites: {}
  }

  type WorkSpace_usersGetPayload<S extends boolean | null | undefined | WorkSpace_usersDefaultArgs> = $Result.GetResult<Prisma.$WorkSpace_usersPayload, S>

  type WorkSpace_usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<WorkSpace_usersFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: WorkSpace_usersCountAggregateInputType | true
    }

  export interface WorkSpace_usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WorkSpace_users'], meta: { name: 'WorkSpace_users' } }
    /**
     * Find zero or one WorkSpace_users that matches the filter.
     * @param {WorkSpace_usersFindUniqueArgs} args - Arguments to find a WorkSpace_users
     * @example
     * // Get one WorkSpace_users
     * const workSpace_users = await prisma.workSpace_users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkSpace_usersFindUniqueArgs>(args: SelectSubset<T, WorkSpace_usersFindUniqueArgs<ExtArgs>>): Prisma__WorkSpace_usersClient<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one WorkSpace_users that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {WorkSpace_usersFindUniqueOrThrowArgs} args - Arguments to find a WorkSpace_users
     * @example
     * // Get one WorkSpace_users
     * const workSpace_users = await prisma.workSpace_users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkSpace_usersFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkSpace_usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkSpace_usersClient<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first WorkSpace_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpace_usersFindFirstArgs} args - Arguments to find a WorkSpace_users
     * @example
     * // Get one WorkSpace_users
     * const workSpace_users = await prisma.workSpace_users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkSpace_usersFindFirstArgs>(args?: SelectSubset<T, WorkSpace_usersFindFirstArgs<ExtArgs>>): Prisma__WorkSpace_usersClient<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first WorkSpace_users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpace_usersFindFirstOrThrowArgs} args - Arguments to find a WorkSpace_users
     * @example
     * // Get one WorkSpace_users
     * const workSpace_users = await prisma.workSpace_users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkSpace_usersFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkSpace_usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkSpace_usersClient<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more WorkSpace_users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpace_usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WorkSpace_users
     * const workSpace_users = await prisma.workSpace_users.findMany()
     * 
     * // Get first 10 WorkSpace_users
     * const workSpace_users = await prisma.workSpace_users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workSpace_usersWithIdOnly = await prisma.workSpace_users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkSpace_usersFindManyArgs>(args?: SelectSubset<T, WorkSpace_usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a WorkSpace_users.
     * @param {WorkSpace_usersCreateArgs} args - Arguments to create a WorkSpace_users.
     * @example
     * // Create one WorkSpace_users
     * const WorkSpace_users = await prisma.workSpace_users.create({
     *   data: {
     *     // ... data to create a WorkSpace_users
     *   }
     * })
     * 
     */
    create<T extends WorkSpace_usersCreateArgs>(args: SelectSubset<T, WorkSpace_usersCreateArgs<ExtArgs>>): Prisma__WorkSpace_usersClient<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many WorkSpace_users.
     * @param {WorkSpace_usersCreateManyArgs} args - Arguments to create many WorkSpace_users.
     * @example
     * // Create many WorkSpace_users
     * const workSpace_users = await prisma.workSpace_users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkSpace_usersCreateManyArgs>(args?: SelectSubset<T, WorkSpace_usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a WorkSpace_users.
     * @param {WorkSpace_usersDeleteArgs} args - Arguments to delete one WorkSpace_users.
     * @example
     * // Delete one WorkSpace_users
     * const WorkSpace_users = await prisma.workSpace_users.delete({
     *   where: {
     *     // ... filter to delete one WorkSpace_users
     *   }
     * })
     * 
     */
    delete<T extends WorkSpace_usersDeleteArgs>(args: SelectSubset<T, WorkSpace_usersDeleteArgs<ExtArgs>>): Prisma__WorkSpace_usersClient<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one WorkSpace_users.
     * @param {WorkSpace_usersUpdateArgs} args - Arguments to update one WorkSpace_users.
     * @example
     * // Update one WorkSpace_users
     * const workSpace_users = await prisma.workSpace_users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkSpace_usersUpdateArgs>(args: SelectSubset<T, WorkSpace_usersUpdateArgs<ExtArgs>>): Prisma__WorkSpace_usersClient<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more WorkSpace_users.
     * @param {WorkSpace_usersDeleteManyArgs} args - Arguments to filter WorkSpace_users to delete.
     * @example
     * // Delete a few WorkSpace_users
     * const { count } = await prisma.workSpace_users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkSpace_usersDeleteManyArgs>(args?: SelectSubset<T, WorkSpace_usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WorkSpace_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpace_usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WorkSpace_users
     * const workSpace_users = await prisma.workSpace_users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkSpace_usersUpdateManyArgs>(args: SelectSubset<T, WorkSpace_usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one WorkSpace_users.
     * @param {WorkSpace_usersUpsertArgs} args - Arguments to update or create a WorkSpace_users.
     * @example
     * // Update or create a WorkSpace_users
     * const workSpace_users = await prisma.workSpace_users.upsert({
     *   create: {
     *     // ... data to create a WorkSpace_users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WorkSpace_users we want to update
     *   }
     * })
     */
    upsert<T extends WorkSpace_usersUpsertArgs>(args: SelectSubset<T, WorkSpace_usersUpsertArgs<ExtArgs>>): Prisma__WorkSpace_usersClient<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more WorkSpace_users that matches the filter.
     * @param {WorkSpace_usersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const workSpace_users = await prisma.workSpace_users.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: WorkSpace_usersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a WorkSpace_users.
     * @param {WorkSpace_usersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const workSpace_users = await prisma.workSpace_users.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: WorkSpace_usersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of WorkSpace_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpace_usersCountArgs} args - Arguments to filter WorkSpace_users to count.
     * @example
     * // Count the number of WorkSpace_users
     * const count = await prisma.workSpace_users.count({
     *   where: {
     *     // ... the filter for the WorkSpace_users we want to count
     *   }
     * })
    **/
    count<T extends WorkSpace_usersCountArgs>(
      args?: Subset<T, WorkSpace_usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkSpace_usersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WorkSpace_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpace_usersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkSpace_usersAggregateArgs>(args: Subset<T, WorkSpace_usersAggregateArgs>): Prisma.PrismaPromise<GetWorkSpace_usersAggregateType<T>>

    /**
     * Group by WorkSpace_users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkSpace_usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkSpace_usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkSpace_usersGroupByArgs['orderBy'] }
        : { orderBy?: WorkSpace_usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkSpace_usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkSpace_usersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WorkSpace_users model
   */
  readonly fields: WorkSpace_usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WorkSpace_users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkSpace_usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workspace<T extends WorkSpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpaceDefaultArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team_member<T extends WorkSpace_users$team_memberArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpace_users$team_memberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WorkSpace_users model
   */ 
  interface WorkSpace_usersFieldRefs {
    readonly id: FieldRef<"WorkSpace_users", 'String'>
    readonly userId: FieldRef<"WorkSpace_users", 'String'>
    readonly workspaceId: FieldRef<"WorkSpace_users", 'String'>
    readonly role: FieldRef<"WorkSpace_users", 'Role'>
    readonly createdAt: FieldRef<"WorkSpace_users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WorkSpace_users findUnique
   */
  export type WorkSpace_usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
    /**
     * Filter, which WorkSpace_users to fetch.
     */
    where: WorkSpace_usersWhereUniqueInput
  }

  /**
   * WorkSpace_users findUniqueOrThrow
   */
  export type WorkSpace_usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
    /**
     * Filter, which WorkSpace_users to fetch.
     */
    where: WorkSpace_usersWhereUniqueInput
  }

  /**
   * WorkSpace_users findFirst
   */
  export type WorkSpace_usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
    /**
     * Filter, which WorkSpace_users to fetch.
     */
    where?: WorkSpace_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSpace_users to fetch.
     */
    orderBy?: WorkSpace_usersOrderByWithRelationInput | WorkSpace_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkSpace_users.
     */
    cursor?: WorkSpace_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSpace_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSpace_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkSpace_users.
     */
    distinct?: WorkSpace_usersScalarFieldEnum | WorkSpace_usersScalarFieldEnum[]
  }

  /**
   * WorkSpace_users findFirstOrThrow
   */
  export type WorkSpace_usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
    /**
     * Filter, which WorkSpace_users to fetch.
     */
    where?: WorkSpace_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSpace_users to fetch.
     */
    orderBy?: WorkSpace_usersOrderByWithRelationInput | WorkSpace_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WorkSpace_users.
     */
    cursor?: WorkSpace_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSpace_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSpace_users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WorkSpace_users.
     */
    distinct?: WorkSpace_usersScalarFieldEnum | WorkSpace_usersScalarFieldEnum[]
  }

  /**
   * WorkSpace_users findMany
   */
  export type WorkSpace_usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
    /**
     * Filter, which WorkSpace_users to fetch.
     */
    where?: WorkSpace_usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WorkSpace_users to fetch.
     */
    orderBy?: WorkSpace_usersOrderByWithRelationInput | WorkSpace_usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WorkSpace_users.
     */
    cursor?: WorkSpace_usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` WorkSpace_users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WorkSpace_users.
     */
    skip?: number
    distinct?: WorkSpace_usersScalarFieldEnum | WorkSpace_usersScalarFieldEnum[]
  }

  /**
   * WorkSpace_users create
   */
  export type WorkSpace_usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
    /**
     * The data needed to create a WorkSpace_users.
     */
    data: XOR<WorkSpace_usersCreateInput, WorkSpace_usersUncheckedCreateInput>
  }

  /**
   * WorkSpace_users createMany
   */
  export type WorkSpace_usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WorkSpace_users.
     */
    data: WorkSpace_usersCreateManyInput | WorkSpace_usersCreateManyInput[]
  }

  /**
   * WorkSpace_users update
   */
  export type WorkSpace_usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
    /**
     * The data needed to update a WorkSpace_users.
     */
    data: XOR<WorkSpace_usersUpdateInput, WorkSpace_usersUncheckedUpdateInput>
    /**
     * Choose, which WorkSpace_users to update.
     */
    where: WorkSpace_usersWhereUniqueInput
  }

  /**
   * WorkSpace_users updateMany
   */
  export type WorkSpace_usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WorkSpace_users.
     */
    data: XOR<WorkSpace_usersUpdateManyMutationInput, WorkSpace_usersUncheckedUpdateManyInput>
    /**
     * Filter which WorkSpace_users to update
     */
    where?: WorkSpace_usersWhereInput
  }

  /**
   * WorkSpace_users upsert
   */
  export type WorkSpace_usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
    /**
     * The filter to search for the WorkSpace_users to update in case it exists.
     */
    where: WorkSpace_usersWhereUniqueInput
    /**
     * In case the WorkSpace_users found by the `where` argument doesn't exist, create a new WorkSpace_users with this data.
     */
    create: XOR<WorkSpace_usersCreateInput, WorkSpace_usersUncheckedCreateInput>
    /**
     * In case the WorkSpace_users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkSpace_usersUpdateInput, WorkSpace_usersUncheckedUpdateInput>
  }

  /**
   * WorkSpace_users delete
   */
  export type WorkSpace_usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
    /**
     * Filter which WorkSpace_users to delete.
     */
    where: WorkSpace_usersWhereUniqueInput
  }

  /**
   * WorkSpace_users deleteMany
   */
  export type WorkSpace_usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WorkSpace_users to delete
     */
    where?: WorkSpace_usersWhereInput
  }

  /**
   * WorkSpace_users findRaw
   */
  export type WorkSpace_usersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WorkSpace_users aggregateRaw
   */
  export type WorkSpace_usersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * WorkSpace_users.team_member
   */
  export type WorkSpace_users$team_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    where?: team_memberWhereInput
    orderBy?: team_memberOrderByWithRelationInput | team_memberOrderByWithRelationInput[]
    cursor?: team_memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_memberScalarFieldEnum | Team_memberScalarFieldEnum[]
  }

  /**
   * WorkSpace_users without action
   */
  export type WorkSpace_usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WorkSpace_users
     */
    select?: WorkSpace_usersSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkSpace_usersInclude<ExtArgs> | null
  }


  /**
   * Model team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    creatorId: string | null
    workspaceId: string | null
    teamName: string | null
    description: string | null
    createdAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    creatorId: string | null
    workspaceId: string | null
    teamName: string | null
    description: string | null
    createdAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    creatorId: number
    workspaceId: number
    teamName: number
    description: number
    createdAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    creatorId?: true
    workspaceId?: true
    teamName?: true
    description?: true
    createdAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    creatorId?: true
    workspaceId?: true
    teamName?: true
    description?: true
    createdAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    creatorId?: true
    workspaceId?: true
    teamName?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team to aggregate.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type teamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: teamWhereInput
    orderBy?: teamOrderByWithAggregationInput | teamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: teamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    creatorId: string
    workspaceId: string
    teamName: string
    description: string | null
    createdAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends teamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type teamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    creatorId?: boolean
    workspaceId?: boolean
    teamName?: boolean
    description?: boolean
    createdAt?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkSpaceDefaultArgs<ExtArgs>
    team_member?: boolean | team$team_memberArgs<ExtArgs>
    monitor_config?: boolean | team$monitor_configArgs<ExtArgs>
    team_escalationpolicy?: boolean | team$team_escalationpolicyArgs<ExtArgs>
    escalation_policy_rules?: boolean | team$escalation_policy_rulesArgs<ExtArgs>
    team_schedule?: boolean | team$team_scheduleArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>


  export type teamSelectScalar = {
    id?: boolean
    creatorId?: boolean
    workspaceId?: boolean
    teamName?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type teamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
    workspace?: boolean | WorkSpaceDefaultArgs<ExtArgs>
    team_member?: boolean | team$team_memberArgs<ExtArgs>
    monitor_config?: boolean | team$monitor_configArgs<ExtArgs>
    team_escalationpolicy?: boolean | team$team_escalationpolicyArgs<ExtArgs>
    escalation_policy_rules?: boolean | team$escalation_policy_rulesArgs<ExtArgs>
    team_schedule?: boolean | team$team_scheduleArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $teamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
      workspace: Prisma.$WorkSpacePayload<ExtArgs>
      team_member: Prisma.$team_memberPayload<ExtArgs>[]
      monitor_config: Prisma.$Monitor_configPayload<ExtArgs>[]
      team_escalationpolicy: Prisma.$team_escalationpolicyPayload<ExtArgs>[]
      escalation_policy_rules: Prisma.$escalation_policy_rulesPayload<ExtArgs>[]
      team_schedule: Prisma.$team_schedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      creatorId: string
      workspaceId: string
      teamName: string
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type teamGetPayload<S extends boolean | null | undefined | teamDefaultArgs> = $Result.GetResult<Prisma.$teamPayload, S>

  type teamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<teamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface teamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team'], meta: { name: 'team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {teamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends teamFindUniqueArgs>(args: SelectSubset<T, teamFindUniqueArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {teamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends teamFindUniqueOrThrowArgs>(args: SelectSubset<T, teamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends teamFindFirstArgs>(args?: SelectSubset<T, teamFindFirstArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends teamFindFirstOrThrowArgs>(args?: SelectSubset<T, teamFindFirstOrThrowArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends teamFindManyArgs>(args?: SelectSubset<T, teamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {teamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends teamCreateArgs>(args: SelectSubset<T, teamCreateArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {teamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends teamCreateManyArgs>(args?: SelectSubset<T, teamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {teamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends teamDeleteArgs>(args: SelectSubset<T, teamDeleteArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {teamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends teamUpdateArgs>(args: SelectSubset<T, teamUpdateArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {teamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends teamDeleteManyArgs>(args?: SelectSubset<T, teamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends teamUpdateManyArgs>(args: SelectSubset<T, teamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {teamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends teamUpsertArgs>(args: SelectSubset<T, teamUpsertArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * @param {teamFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const team = await prisma.team.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: teamFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Team.
     * @param {teamAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const team = await prisma.team.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: teamAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends teamCountArgs>(
      args?: Subset<T, teamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {teamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends teamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: teamGroupByArgs['orderBy'] }
        : { orderBy?: teamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, teamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team model
   */
  readonly fields: teamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__teamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workspace<T extends WorkSpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpaceDefaultArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team_member<T extends team$team_memberArgs<ExtArgs> = {}>(args?: Subset<T, team$team_memberArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "findMany"> | Null>
    monitor_config<T extends team$monitor_configArgs<ExtArgs> = {}>(args?: Subset<T, team$monitor_configArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findMany"> | Null>
    team_escalationpolicy<T extends team$team_escalationpolicyArgs<ExtArgs> = {}>(args?: Subset<T, team$team_escalationpolicyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_escalationpolicyPayload<ExtArgs>, T, "findMany"> | Null>
    escalation_policy_rules<T extends team$escalation_policy_rulesArgs<ExtArgs> = {}>(args?: Subset<T, team$escalation_policy_rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "findMany"> | Null>
    team_schedule<T extends team$team_scheduleArgs<ExtArgs> = {}>(args?: Subset<T, team$team_scheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the team model
   */ 
  interface teamFieldRefs {
    readonly id: FieldRef<"team", 'String'>
    readonly creatorId: FieldRef<"team", 'String'>
    readonly workspaceId: FieldRef<"team", 'String'>
    readonly teamName: FieldRef<"team", 'String'>
    readonly description: FieldRef<"team", 'String'>
    readonly createdAt: FieldRef<"team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * team findUnique
   */
  export type teamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team findUniqueOrThrow
   */
  export type teamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team findFirst
   */
  export type teamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * team findFirstOrThrow
   */
  export type teamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which team to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * team findMany
   */
  export type teamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter, which teams to fetch.
     */
    where?: teamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of teams to fetch.
     */
    orderBy?: teamOrderByWithRelationInput | teamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing teams.
     */
    cursor?: teamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * team create
   */
  export type teamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to create a team.
     */
    data: XOR<teamCreateInput, teamUncheckedCreateInput>
  }

  /**
   * team createMany
   */
  export type teamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many teams.
     */
    data: teamCreateManyInput | teamCreateManyInput[]
  }

  /**
   * team update
   */
  export type teamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The data needed to update a team.
     */
    data: XOR<teamUpdateInput, teamUncheckedUpdateInput>
    /**
     * Choose, which team to update.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team updateMany
   */
  export type teamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update teams.
     */
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyInput>
    /**
     * Filter which teams to update
     */
    where?: teamWhereInput
  }

  /**
   * team upsert
   */
  export type teamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * The filter to search for the team to update in case it exists.
     */
    where: teamWhereUniqueInput
    /**
     * In case the team found by the `where` argument doesn't exist, create a new team with this data.
     */
    create: XOR<teamCreateInput, teamUncheckedCreateInput>
    /**
     * In case the team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<teamUpdateInput, teamUncheckedUpdateInput>
  }

  /**
   * team delete
   */
  export type teamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    /**
     * Filter which team to delete.
     */
    where: teamWhereUniqueInput
  }

  /**
   * team deleteMany
   */
  export type teamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which teams to delete
     */
    where?: teamWhereInput
  }

  /**
   * team findRaw
   */
  export type teamFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team aggregateRaw
   */
  export type teamAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team.team_member
   */
  export type team$team_memberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    where?: team_memberWhereInput
    orderBy?: team_memberOrderByWithRelationInput | team_memberOrderByWithRelationInput[]
    cursor?: team_memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_memberScalarFieldEnum | Team_memberScalarFieldEnum[]
  }

  /**
   * team.monitor_config
   */
  export type team$monitor_configArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Monitor_config
     */
    select?: Monitor_configSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: Monitor_configInclude<ExtArgs> | null
    where?: Monitor_configWhereInput
    orderBy?: Monitor_configOrderByWithRelationInput | Monitor_configOrderByWithRelationInput[]
    cursor?: Monitor_configWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Monitor_configScalarFieldEnum | Monitor_configScalarFieldEnum[]
  }

  /**
   * team.team_escalationpolicy
   */
  export type team$team_escalationpolicyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_escalationpolicy
     */
    select?: team_escalationpolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_escalationpolicyInclude<ExtArgs> | null
    where?: team_escalationpolicyWhereInput
    orderBy?: team_escalationpolicyOrderByWithRelationInput | team_escalationpolicyOrderByWithRelationInput[]
    cursor?: team_escalationpolicyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_escalationpolicyScalarFieldEnum | Team_escalationpolicyScalarFieldEnum[]
  }

  /**
   * team.escalation_policy_rules
   */
  export type team$escalation_policy_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    where?: escalation_policy_rulesWhereInput
    orderBy?: escalation_policy_rulesOrderByWithRelationInput | escalation_policy_rulesOrderByWithRelationInput[]
    cursor?: escalation_policy_rulesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Escalation_policy_rulesScalarFieldEnum | Escalation_policy_rulesScalarFieldEnum[]
  }

  /**
   * team.team_schedule
   */
  export type team$team_scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule
     */
    select?: team_scheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_scheduleInclude<ExtArgs> | null
    where?: team_scheduleWhereInput
    orderBy?: team_scheduleOrderByWithRelationInput | team_scheduleOrderByWithRelationInput[]
    cursor?: team_scheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_scheduleScalarFieldEnum | Team_scheduleScalarFieldEnum[]
  }

  /**
   * team without action
   */
  export type teamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
  }


  /**
   * Model team_member
   */

  export type AggregateTeam_member = {
    _count: Team_memberCountAggregateOutputType | null
    _min: Team_memberMinAggregateOutputType | null
    _max: Team_memberMaxAggregateOutputType | null
  }

  export type Team_memberMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    workspace_userId: string | null
    workspaceId: string | null
  }

  export type Team_memberMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    workspace_userId: string | null
    workspaceId: string | null
  }

  export type Team_memberCountAggregateOutputType = {
    id: number
    teamId: number
    workspace_userId: number
    workspaceId: number
    _all: number
  }


  export type Team_memberMinAggregateInputType = {
    id?: true
    teamId?: true
    workspace_userId?: true
    workspaceId?: true
  }

  export type Team_memberMaxAggregateInputType = {
    id?: true
    teamId?: true
    workspace_userId?: true
    workspaceId?: true
  }

  export type Team_memberCountAggregateInputType = {
    id?: true
    teamId?: true
    workspace_userId?: true
    workspaceId?: true
    _all?: true
  }

  export type Team_memberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_member to aggregate.
     */
    where?: team_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_members to fetch.
     */
    orderBy?: team_memberOrderByWithRelationInput | team_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: team_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned team_members
    **/
    _count?: true | Team_memberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Team_memberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Team_memberMaxAggregateInputType
  }

  export type GetTeam_memberAggregateType<T extends Team_memberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam_member]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam_member[P]>
      : GetScalarType<T[P], AggregateTeam_member[P]>
  }




  export type team_memberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_memberWhereInput
    orderBy?: team_memberOrderByWithAggregationInput | team_memberOrderByWithAggregationInput[]
    by: Team_memberScalarFieldEnum[] | Team_memberScalarFieldEnum
    having?: team_memberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Team_memberCountAggregateInputType | true
    _min?: Team_memberMinAggregateInputType
    _max?: Team_memberMaxAggregateInputType
  }

  export type Team_memberGroupByOutputType = {
    id: string
    teamId: string
    workspace_userId: string
    workspaceId: string
    _count: Team_memberCountAggregateOutputType | null
    _min: Team_memberMinAggregateOutputType | null
    _max: Team_memberMaxAggregateOutputType | null
  }

  type GetTeam_memberGroupByPayload<T extends team_memberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Team_memberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Team_memberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Team_memberGroupByOutputType[P]>
            : GetScalarType<T[P], Team_memberGroupByOutputType[P]>
        }
      >
    >


  export type team_memberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    workspace_userId?: boolean
    workspaceId?: boolean
    team?: boolean | teamDefaultArgs<ExtArgs>
    workspace_user?: boolean | WorkSpace_usersDefaultArgs<ExtArgs>
    workspace?: boolean | WorkSpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team_member"]>


  export type team_memberSelectScalar = {
    id?: boolean
    teamId?: boolean
    workspace_userId?: boolean
    workspaceId?: boolean
  }

  export type team_memberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | teamDefaultArgs<ExtArgs>
    workspace_user?: boolean | WorkSpace_usersDefaultArgs<ExtArgs>
    workspace?: boolean | WorkSpaceDefaultArgs<ExtArgs>
  }

  export type $team_memberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team_member"
    objects: {
      team: Prisma.$teamPayload<ExtArgs>
      workspace_user: Prisma.$WorkSpace_usersPayload<ExtArgs>
      workspace: Prisma.$WorkSpacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      workspace_userId: string
      workspaceId: string
    }, ExtArgs["result"]["team_member"]>
    composites: {}
  }

  type team_memberGetPayload<S extends boolean | null | undefined | team_memberDefaultArgs> = $Result.GetResult<Prisma.$team_memberPayload, S>

  type team_memberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<team_memberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Team_memberCountAggregateInputType | true
    }

  export interface team_memberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team_member'], meta: { name: 'team_member' } }
    /**
     * Find zero or one Team_member that matches the filter.
     * @param {team_memberFindUniqueArgs} args - Arguments to find a Team_member
     * @example
     * // Get one Team_member
     * const team_member = await prisma.team_member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends team_memberFindUniqueArgs>(args: SelectSubset<T, team_memberFindUniqueArgs<ExtArgs>>): Prisma__team_memberClient<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team_member that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {team_memberFindUniqueOrThrowArgs} args - Arguments to find a Team_member
     * @example
     * // Get one Team_member
     * const team_member = await prisma.team_member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends team_memberFindUniqueOrThrowArgs>(args: SelectSubset<T, team_memberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__team_memberClient<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team_member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_memberFindFirstArgs} args - Arguments to find a Team_member
     * @example
     * // Get one Team_member
     * const team_member = await prisma.team_member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends team_memberFindFirstArgs>(args?: SelectSubset<T, team_memberFindFirstArgs<ExtArgs>>): Prisma__team_memberClient<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team_member that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_memberFindFirstOrThrowArgs} args - Arguments to find a Team_member
     * @example
     * // Get one Team_member
     * const team_member = await prisma.team_member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends team_memberFindFirstOrThrowArgs>(args?: SelectSubset<T, team_memberFindFirstOrThrowArgs<ExtArgs>>): Prisma__team_memberClient<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Team_members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_memberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Team_members
     * const team_members = await prisma.team_member.findMany()
     * 
     * // Get first 10 Team_members
     * const team_members = await prisma.team_member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const team_memberWithIdOnly = await prisma.team_member.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends team_memberFindManyArgs>(args?: SelectSubset<T, team_memberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team_member.
     * @param {team_memberCreateArgs} args - Arguments to create a Team_member.
     * @example
     * // Create one Team_member
     * const Team_member = await prisma.team_member.create({
     *   data: {
     *     // ... data to create a Team_member
     *   }
     * })
     * 
     */
    create<T extends team_memberCreateArgs>(args: SelectSubset<T, team_memberCreateArgs<ExtArgs>>): Prisma__team_memberClient<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Team_members.
     * @param {team_memberCreateManyArgs} args - Arguments to create many Team_members.
     * @example
     * // Create many Team_members
     * const team_member = await prisma.team_member.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends team_memberCreateManyArgs>(args?: SelectSubset<T, team_memberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team_member.
     * @param {team_memberDeleteArgs} args - Arguments to delete one Team_member.
     * @example
     * // Delete one Team_member
     * const Team_member = await prisma.team_member.delete({
     *   where: {
     *     // ... filter to delete one Team_member
     *   }
     * })
     * 
     */
    delete<T extends team_memberDeleteArgs>(args: SelectSubset<T, team_memberDeleteArgs<ExtArgs>>): Prisma__team_memberClient<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team_member.
     * @param {team_memberUpdateArgs} args - Arguments to update one Team_member.
     * @example
     * // Update one Team_member
     * const team_member = await prisma.team_member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends team_memberUpdateArgs>(args: SelectSubset<T, team_memberUpdateArgs<ExtArgs>>): Prisma__team_memberClient<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Team_members.
     * @param {team_memberDeleteManyArgs} args - Arguments to filter Team_members to delete.
     * @example
     * // Delete a few Team_members
     * const { count } = await prisma.team_member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends team_memberDeleteManyArgs>(args?: SelectSubset<T, team_memberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Team_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_memberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Team_members
     * const team_member = await prisma.team_member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends team_memberUpdateManyArgs>(args: SelectSubset<T, team_memberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team_member.
     * @param {team_memberUpsertArgs} args - Arguments to update or create a Team_member.
     * @example
     * // Update or create a Team_member
     * const team_member = await prisma.team_member.upsert({
     *   create: {
     *     // ... data to create a Team_member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team_member we want to update
     *   }
     * })
     */
    upsert<T extends team_memberUpsertArgs>(args: SelectSubset<T, team_memberUpsertArgs<ExtArgs>>): Prisma__team_memberClient<$Result.GetResult<Prisma.$team_memberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Team_members that matches the filter.
     * @param {team_memberFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const team_member = await prisma.team_member.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: team_memberFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Team_member.
     * @param {team_memberAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const team_member = await prisma.team_member.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: team_memberAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Team_members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_memberCountArgs} args - Arguments to filter Team_members to count.
     * @example
     * // Count the number of Team_members
     * const count = await prisma.team_member.count({
     *   where: {
     *     // ... the filter for the Team_members we want to count
     *   }
     * })
    **/
    count<T extends team_memberCountArgs>(
      args?: Subset<T, team_memberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Team_memberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team_member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Team_memberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Team_memberAggregateArgs>(args: Subset<T, Team_memberAggregateArgs>): Prisma.PrismaPromise<GetTeam_memberAggregateType<T>>

    /**
     * Group by Team_member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_memberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends team_memberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: team_memberGroupByArgs['orderBy'] }
        : { orderBy?: team_memberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, team_memberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeam_memberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team_member model
   */
  readonly fields: team_memberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team_member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__team_memberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends teamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teamDefaultArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workspace_user<T extends WorkSpace_usersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpace_usersDefaultArgs<ExtArgs>>): Prisma__WorkSpace_usersClient<$Result.GetResult<Prisma.$WorkSpace_usersPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    workspace<T extends WorkSpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpaceDefaultArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the team_member model
   */ 
  interface team_memberFieldRefs {
    readonly id: FieldRef<"team_member", 'String'>
    readonly teamId: FieldRef<"team_member", 'String'>
    readonly workspace_userId: FieldRef<"team_member", 'String'>
    readonly workspaceId: FieldRef<"team_member", 'String'>
  }
    

  // Custom InputTypes
  /**
   * team_member findUnique
   */
  export type team_memberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    /**
     * Filter, which team_member to fetch.
     */
    where: team_memberWhereUniqueInput
  }

  /**
   * team_member findUniqueOrThrow
   */
  export type team_memberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    /**
     * Filter, which team_member to fetch.
     */
    where: team_memberWhereUniqueInput
  }

  /**
   * team_member findFirst
   */
  export type team_memberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    /**
     * Filter, which team_member to fetch.
     */
    where?: team_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_members to fetch.
     */
    orderBy?: team_memberOrderByWithRelationInput | team_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_members.
     */
    cursor?: team_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_members.
     */
    distinct?: Team_memberScalarFieldEnum | Team_memberScalarFieldEnum[]
  }

  /**
   * team_member findFirstOrThrow
   */
  export type team_memberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    /**
     * Filter, which team_member to fetch.
     */
    where?: team_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_members to fetch.
     */
    orderBy?: team_memberOrderByWithRelationInput | team_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_members.
     */
    cursor?: team_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_members.
     */
    distinct?: Team_memberScalarFieldEnum | Team_memberScalarFieldEnum[]
  }

  /**
   * team_member findMany
   */
  export type team_memberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    /**
     * Filter, which team_members to fetch.
     */
    where?: team_memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_members to fetch.
     */
    orderBy?: team_memberOrderByWithRelationInput | team_memberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing team_members.
     */
    cursor?: team_memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_members.
     */
    skip?: number
    distinct?: Team_memberScalarFieldEnum | Team_memberScalarFieldEnum[]
  }

  /**
   * team_member create
   */
  export type team_memberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    /**
     * The data needed to create a team_member.
     */
    data: XOR<team_memberCreateInput, team_memberUncheckedCreateInput>
  }

  /**
   * team_member createMany
   */
  export type team_memberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many team_members.
     */
    data: team_memberCreateManyInput | team_memberCreateManyInput[]
  }

  /**
   * team_member update
   */
  export type team_memberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    /**
     * The data needed to update a team_member.
     */
    data: XOR<team_memberUpdateInput, team_memberUncheckedUpdateInput>
    /**
     * Choose, which team_member to update.
     */
    where: team_memberWhereUniqueInput
  }

  /**
   * team_member updateMany
   */
  export type team_memberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update team_members.
     */
    data: XOR<team_memberUpdateManyMutationInput, team_memberUncheckedUpdateManyInput>
    /**
     * Filter which team_members to update
     */
    where?: team_memberWhereInput
  }

  /**
   * team_member upsert
   */
  export type team_memberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    /**
     * The filter to search for the team_member to update in case it exists.
     */
    where: team_memberWhereUniqueInput
    /**
     * In case the team_member found by the `where` argument doesn't exist, create a new team_member with this data.
     */
    create: XOR<team_memberCreateInput, team_memberUncheckedCreateInput>
    /**
     * In case the team_member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<team_memberUpdateInput, team_memberUncheckedUpdateInput>
  }

  /**
   * team_member delete
   */
  export type team_memberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
    /**
     * Filter which team_member to delete.
     */
    where: team_memberWhereUniqueInput
  }

  /**
   * team_member deleteMany
   */
  export type team_memberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_members to delete
     */
    where?: team_memberWhereInput
  }

  /**
   * team_member findRaw
   */
  export type team_memberFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team_member aggregateRaw
   */
  export type team_memberAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team_member without action
   */
  export type team_memberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_member
     */
    select?: team_memberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_memberInclude<ExtArgs> | null
  }


  /**
   * Model alert
   */

  export type AggregateAlert = {
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  export type AlertMinAggregateOutputType = {
    id: string | null
    acknowledged: boolean | null
    monitor_configId: string | null
    userId: string | null
    workspaceId: string | null
    createdAt: Date | null
  }

  export type AlertMaxAggregateOutputType = {
    id: string | null
    acknowledged: boolean | null
    monitor_configId: string | null
    userId: string | null
    workspaceId: string | null
    createdAt: Date | null
  }

  export type AlertCountAggregateOutputType = {
    id: number
    acknowledged: number
    monitor_configId: number
    userId: number
    workspaceId: number
    createdAt: number
    _all: number
  }


  export type AlertMinAggregateInputType = {
    id?: true
    acknowledged?: true
    monitor_configId?: true
    userId?: true
    workspaceId?: true
    createdAt?: true
  }

  export type AlertMaxAggregateInputType = {
    id?: true
    acknowledged?: true
    monitor_configId?: true
    userId?: true
    workspaceId?: true
    createdAt?: true
  }

  export type AlertCountAggregateInputType = {
    id?: true
    acknowledged?: true
    monitor_configId?: true
    userId?: true
    workspaceId?: true
    createdAt?: true
    _all?: true
  }

  export type AlertAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alert to aggregate.
     */
    where?: alertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alerts to fetch.
     */
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: alertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned alerts
    **/
    _count?: true | AlertCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AlertMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AlertMaxAggregateInputType
  }

  export type GetAlertAggregateType<T extends AlertAggregateArgs> = {
        [P in keyof T & keyof AggregateAlert]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAlert[P]>
      : GetScalarType<T[P], AggregateAlert[P]>
  }




  export type alertGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: alertWhereInput
    orderBy?: alertOrderByWithAggregationInput | alertOrderByWithAggregationInput[]
    by: AlertScalarFieldEnum[] | AlertScalarFieldEnum
    having?: alertScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AlertCountAggregateInputType | true
    _min?: AlertMinAggregateInputType
    _max?: AlertMaxAggregateInputType
  }

  export type AlertGroupByOutputType = {
    id: string
    acknowledged: boolean
    monitor_configId: string
    userId: string | null
    workspaceId: string
    createdAt: Date
    _count: AlertCountAggregateOutputType | null
    _min: AlertMinAggregateOutputType | null
    _max: AlertMaxAggregateOutputType | null
  }

  type GetAlertGroupByPayload<T extends alertGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AlertGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AlertGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AlertGroupByOutputType[P]>
            : GetScalarType<T[P], AlertGroupByOutputType[P]>
        }
      >
    >


  export type alertSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    acknowledged?: boolean
    monitor_configId?: boolean
    userId?: boolean
    workspaceId?: boolean
    createdAt?: boolean
    monitor_config?: boolean | Monitor_configDefaultArgs<ExtArgs>
    user?: boolean | alert$userArgs<ExtArgs>
    workspace?: boolean | WorkSpaceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["alert"]>


  export type alertSelectScalar = {
    id?: boolean
    acknowledged?: boolean
    monitor_configId?: boolean
    userId?: boolean
    workspaceId?: boolean
    createdAt?: boolean
  }

  export type alertInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    monitor_config?: boolean | Monitor_configDefaultArgs<ExtArgs>
    user?: boolean | alert$userArgs<ExtArgs>
    workspace?: boolean | WorkSpaceDefaultArgs<ExtArgs>
  }

  export type $alertPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "alert"
    objects: {
      monitor_config: Prisma.$Monitor_configPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      workspace: Prisma.$WorkSpacePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      acknowledged: boolean
      monitor_configId: string
      userId: string | null
      workspaceId: string
      createdAt: Date
    }, ExtArgs["result"]["alert"]>
    composites: {}
  }

  type alertGetPayload<S extends boolean | null | undefined | alertDefaultArgs> = $Result.GetResult<Prisma.$alertPayload, S>

  type alertCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<alertFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AlertCountAggregateInputType | true
    }

  export interface alertDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['alert'], meta: { name: 'alert' } }
    /**
     * Find zero or one Alert that matches the filter.
     * @param {alertFindUniqueArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends alertFindUniqueArgs>(args: SelectSubset<T, alertFindUniqueArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Alert that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {alertFindUniqueOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends alertFindUniqueOrThrowArgs>(args: SelectSubset<T, alertFindUniqueOrThrowArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Alert that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertFindFirstArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends alertFindFirstArgs>(args?: SelectSubset<T, alertFindFirstArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Alert that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertFindFirstOrThrowArgs} args - Arguments to find a Alert
     * @example
     * // Get one Alert
     * const alert = await prisma.alert.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends alertFindFirstOrThrowArgs>(args?: SelectSubset<T, alertFindFirstOrThrowArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Alerts
     * const alerts = await prisma.alert.findMany()
     * 
     * // Get first 10 Alerts
     * const alerts = await prisma.alert.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const alertWithIdOnly = await prisma.alert.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends alertFindManyArgs>(args?: SelectSubset<T, alertFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Alert.
     * @param {alertCreateArgs} args - Arguments to create a Alert.
     * @example
     * // Create one Alert
     * const Alert = await prisma.alert.create({
     *   data: {
     *     // ... data to create a Alert
     *   }
     * })
     * 
     */
    create<T extends alertCreateArgs>(args: SelectSubset<T, alertCreateArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Alerts.
     * @param {alertCreateManyArgs} args - Arguments to create many Alerts.
     * @example
     * // Create many Alerts
     * const alert = await prisma.alert.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends alertCreateManyArgs>(args?: SelectSubset<T, alertCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Alert.
     * @param {alertDeleteArgs} args - Arguments to delete one Alert.
     * @example
     * // Delete one Alert
     * const Alert = await prisma.alert.delete({
     *   where: {
     *     // ... filter to delete one Alert
     *   }
     * })
     * 
     */
    delete<T extends alertDeleteArgs>(args: SelectSubset<T, alertDeleteArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Alert.
     * @param {alertUpdateArgs} args - Arguments to update one Alert.
     * @example
     * // Update one Alert
     * const alert = await prisma.alert.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends alertUpdateArgs>(args: SelectSubset<T, alertUpdateArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Alerts.
     * @param {alertDeleteManyArgs} args - Arguments to filter Alerts to delete.
     * @example
     * // Delete a few Alerts
     * const { count } = await prisma.alert.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends alertDeleteManyArgs>(args?: SelectSubset<T, alertDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Alerts
     * const alert = await prisma.alert.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends alertUpdateManyArgs>(args: SelectSubset<T, alertUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Alert.
     * @param {alertUpsertArgs} args - Arguments to update or create a Alert.
     * @example
     * // Update or create a Alert
     * const alert = await prisma.alert.upsert({
     *   create: {
     *     // ... data to create a Alert
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Alert we want to update
     *   }
     * })
     */
    upsert<T extends alertUpsertArgs>(args: SelectSubset<T, alertUpsertArgs<ExtArgs>>): Prisma__alertClient<$Result.GetResult<Prisma.$alertPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Alerts that matches the filter.
     * @param {alertFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const alert = await prisma.alert.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: alertFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Alert.
     * @param {alertAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const alert = await prisma.alert.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: alertAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Alerts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertCountArgs} args - Arguments to filter Alerts to count.
     * @example
     * // Count the number of Alerts
     * const count = await prisma.alert.count({
     *   where: {
     *     // ... the filter for the Alerts we want to count
     *   }
     * })
    **/
    count<T extends alertCountArgs>(
      args?: Subset<T, alertCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AlertCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AlertAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AlertAggregateArgs>(args: Subset<T, AlertAggregateArgs>): Prisma.PrismaPromise<GetAlertAggregateType<T>>

    /**
     * Group by Alert.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {alertGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends alertGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: alertGroupByArgs['orderBy'] }
        : { orderBy?: alertGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, alertGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAlertGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the alert model
   */
  readonly fields: alertFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for alert.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__alertClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    monitor_config<T extends Monitor_configDefaultArgs<ExtArgs> = {}>(args?: Subset<T, Monitor_configDefaultArgs<ExtArgs>>): Prisma__Monitor_configClient<$Result.GetResult<Prisma.$Monitor_configPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends alert$userArgs<ExtArgs> = {}>(args?: Subset<T, alert$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    workspace<T extends WorkSpaceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkSpaceDefaultArgs<ExtArgs>>): Prisma__WorkSpaceClient<$Result.GetResult<Prisma.$WorkSpacePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the alert model
   */ 
  interface alertFieldRefs {
    readonly id: FieldRef<"alert", 'String'>
    readonly acknowledged: FieldRef<"alert", 'Boolean'>
    readonly monitor_configId: FieldRef<"alert", 'String'>
    readonly userId: FieldRef<"alert", 'String'>
    readonly workspaceId: FieldRef<"alert", 'String'>
    readonly createdAt: FieldRef<"alert", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * alert findUnique
   */
  export type alertFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter, which alert to fetch.
     */
    where: alertWhereUniqueInput
  }

  /**
   * alert findUniqueOrThrow
   */
  export type alertFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter, which alert to fetch.
     */
    where: alertWhereUniqueInput
  }

  /**
   * alert findFirst
   */
  export type alertFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter, which alert to fetch.
     */
    where?: alertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alerts to fetch.
     */
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alerts.
     */
    cursor?: alertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * alert findFirstOrThrow
   */
  export type alertFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter, which alert to fetch.
     */
    where?: alertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alerts to fetch.
     */
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for alerts.
     */
    cursor?: alertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alerts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of alerts.
     */
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * alert findMany
   */
  export type alertFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter, which alerts to fetch.
     */
    where?: alertWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of alerts to fetch.
     */
    orderBy?: alertOrderByWithRelationInput | alertOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing alerts.
     */
    cursor?: alertWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` alerts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` alerts.
     */
    skip?: number
    distinct?: AlertScalarFieldEnum | AlertScalarFieldEnum[]
  }

  /**
   * alert create
   */
  export type alertCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * The data needed to create a alert.
     */
    data: XOR<alertCreateInput, alertUncheckedCreateInput>
  }

  /**
   * alert createMany
   */
  export type alertCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many alerts.
     */
    data: alertCreateManyInput | alertCreateManyInput[]
  }

  /**
   * alert update
   */
  export type alertUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * The data needed to update a alert.
     */
    data: XOR<alertUpdateInput, alertUncheckedUpdateInput>
    /**
     * Choose, which alert to update.
     */
    where: alertWhereUniqueInput
  }

  /**
   * alert updateMany
   */
  export type alertUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update alerts.
     */
    data: XOR<alertUpdateManyMutationInput, alertUncheckedUpdateManyInput>
    /**
     * Filter which alerts to update
     */
    where?: alertWhereInput
  }

  /**
   * alert upsert
   */
  export type alertUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * The filter to search for the alert to update in case it exists.
     */
    where: alertWhereUniqueInput
    /**
     * In case the alert found by the `where` argument doesn't exist, create a new alert with this data.
     */
    create: XOR<alertCreateInput, alertUncheckedCreateInput>
    /**
     * In case the alert was found with the provided `where` argument, update it with this data.
     */
    update: XOR<alertUpdateInput, alertUncheckedUpdateInput>
  }

  /**
   * alert delete
   */
  export type alertDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
    /**
     * Filter which alert to delete.
     */
    where: alertWhereUniqueInput
  }

  /**
   * alert deleteMany
   */
  export type alertDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which alerts to delete
     */
    where?: alertWhereInput
  }

  /**
   * alert findRaw
   */
  export type alertFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * alert aggregateRaw
   */
  export type alertAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * alert.user
   */
  export type alert$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * alert without action
   */
  export type alertDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the alert
     */
    select?: alertSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: alertInclude<ExtArgs> | null
  }


  /**
   * Model team_escalationpolicy
   */

  export type AggregateTeam_escalationpolicy = {
    _count: Team_escalationpolicyCountAggregateOutputType | null
    _min: Team_escalationpolicyMinAggregateOutputType | null
    _max: Team_escalationpolicyMaxAggregateOutputType | null
  }

  export type Team_escalationpolicyMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    escalationplicy_name: string | null
    isActive: boolean | null
    description: string | null
    createdAt: Date | null
  }

  export type Team_escalationpolicyMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    escalationplicy_name: string | null
    isActive: boolean | null
    description: string | null
    createdAt: Date | null
  }

  export type Team_escalationpolicyCountAggregateOutputType = {
    id: number
    teamId: number
    escalationplicy_name: number
    isActive: number
    description: number
    createdAt: number
    _all: number
  }


  export type Team_escalationpolicyMinAggregateInputType = {
    id?: true
    teamId?: true
    escalationplicy_name?: true
    isActive?: true
    description?: true
    createdAt?: true
  }

  export type Team_escalationpolicyMaxAggregateInputType = {
    id?: true
    teamId?: true
    escalationplicy_name?: true
    isActive?: true
    description?: true
    createdAt?: true
  }

  export type Team_escalationpolicyCountAggregateInputType = {
    id?: true
    teamId?: true
    escalationplicy_name?: true
    isActive?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type Team_escalationpolicyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_escalationpolicy to aggregate.
     */
    where?: team_escalationpolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_escalationpolicies to fetch.
     */
    orderBy?: team_escalationpolicyOrderByWithRelationInput | team_escalationpolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: team_escalationpolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_escalationpolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_escalationpolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned team_escalationpolicies
    **/
    _count?: true | Team_escalationpolicyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Team_escalationpolicyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Team_escalationpolicyMaxAggregateInputType
  }

  export type GetTeam_escalationpolicyAggregateType<T extends Team_escalationpolicyAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam_escalationpolicy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam_escalationpolicy[P]>
      : GetScalarType<T[P], AggregateTeam_escalationpolicy[P]>
  }




  export type team_escalationpolicyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_escalationpolicyWhereInput
    orderBy?: team_escalationpolicyOrderByWithAggregationInput | team_escalationpolicyOrderByWithAggregationInput[]
    by: Team_escalationpolicyScalarFieldEnum[] | Team_escalationpolicyScalarFieldEnum
    having?: team_escalationpolicyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Team_escalationpolicyCountAggregateInputType | true
    _min?: Team_escalationpolicyMinAggregateInputType
    _max?: Team_escalationpolicyMaxAggregateInputType
  }

  export type Team_escalationpolicyGroupByOutputType = {
    id: string
    teamId: string
    escalationplicy_name: string
    isActive: boolean
    description: string | null
    createdAt: Date
    _count: Team_escalationpolicyCountAggregateOutputType | null
    _min: Team_escalationpolicyMinAggregateOutputType | null
    _max: Team_escalationpolicyMaxAggregateOutputType | null
  }

  type GetTeam_escalationpolicyGroupByPayload<T extends team_escalationpolicyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Team_escalationpolicyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Team_escalationpolicyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Team_escalationpolicyGroupByOutputType[P]>
            : GetScalarType<T[P], Team_escalationpolicyGroupByOutputType[P]>
        }
      >
    >


  export type team_escalationpolicySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    escalationplicy_name?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
    team?: boolean | teamDefaultArgs<ExtArgs>
    escalation_policy_rules?: boolean | team_escalationpolicy$escalation_policy_rulesArgs<ExtArgs>
    _count?: boolean | Team_escalationpolicyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team_escalationpolicy"]>


  export type team_escalationpolicySelectScalar = {
    id?: boolean
    teamId?: boolean
    escalationplicy_name?: boolean
    isActive?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type team_escalationpolicyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | teamDefaultArgs<ExtArgs>
    escalation_policy_rules?: boolean | team_escalationpolicy$escalation_policy_rulesArgs<ExtArgs>
    _count?: boolean | Team_escalationpolicyCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $team_escalationpolicyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team_escalationpolicy"
    objects: {
      team: Prisma.$teamPayload<ExtArgs>
      escalation_policy_rules: Prisma.$escalation_policy_rulesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      escalationplicy_name: string
      isActive: boolean
      description: string | null
      createdAt: Date
    }, ExtArgs["result"]["team_escalationpolicy"]>
    composites: {}
  }

  type team_escalationpolicyGetPayload<S extends boolean | null | undefined | team_escalationpolicyDefaultArgs> = $Result.GetResult<Prisma.$team_escalationpolicyPayload, S>

  type team_escalationpolicyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<team_escalationpolicyFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Team_escalationpolicyCountAggregateInputType | true
    }

  export interface team_escalationpolicyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team_escalationpolicy'], meta: { name: 'team_escalationpolicy' } }
    /**
     * Find zero or one Team_escalationpolicy that matches the filter.
     * @param {team_escalationpolicyFindUniqueArgs} args - Arguments to find a Team_escalationpolicy
     * @example
     * // Get one Team_escalationpolicy
     * const team_escalationpolicy = await prisma.team_escalationpolicy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends team_escalationpolicyFindUniqueArgs>(args: SelectSubset<T, team_escalationpolicyFindUniqueArgs<ExtArgs>>): Prisma__team_escalationpolicyClient<$Result.GetResult<Prisma.$team_escalationpolicyPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team_escalationpolicy that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {team_escalationpolicyFindUniqueOrThrowArgs} args - Arguments to find a Team_escalationpolicy
     * @example
     * // Get one Team_escalationpolicy
     * const team_escalationpolicy = await prisma.team_escalationpolicy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends team_escalationpolicyFindUniqueOrThrowArgs>(args: SelectSubset<T, team_escalationpolicyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__team_escalationpolicyClient<$Result.GetResult<Prisma.$team_escalationpolicyPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team_escalationpolicy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_escalationpolicyFindFirstArgs} args - Arguments to find a Team_escalationpolicy
     * @example
     * // Get one Team_escalationpolicy
     * const team_escalationpolicy = await prisma.team_escalationpolicy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends team_escalationpolicyFindFirstArgs>(args?: SelectSubset<T, team_escalationpolicyFindFirstArgs<ExtArgs>>): Prisma__team_escalationpolicyClient<$Result.GetResult<Prisma.$team_escalationpolicyPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team_escalationpolicy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_escalationpolicyFindFirstOrThrowArgs} args - Arguments to find a Team_escalationpolicy
     * @example
     * // Get one Team_escalationpolicy
     * const team_escalationpolicy = await prisma.team_escalationpolicy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends team_escalationpolicyFindFirstOrThrowArgs>(args?: SelectSubset<T, team_escalationpolicyFindFirstOrThrowArgs<ExtArgs>>): Prisma__team_escalationpolicyClient<$Result.GetResult<Prisma.$team_escalationpolicyPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Team_escalationpolicies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_escalationpolicyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Team_escalationpolicies
     * const team_escalationpolicies = await prisma.team_escalationpolicy.findMany()
     * 
     * // Get first 10 Team_escalationpolicies
     * const team_escalationpolicies = await prisma.team_escalationpolicy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const team_escalationpolicyWithIdOnly = await prisma.team_escalationpolicy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends team_escalationpolicyFindManyArgs>(args?: SelectSubset<T, team_escalationpolicyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_escalationpolicyPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team_escalationpolicy.
     * @param {team_escalationpolicyCreateArgs} args - Arguments to create a Team_escalationpolicy.
     * @example
     * // Create one Team_escalationpolicy
     * const Team_escalationpolicy = await prisma.team_escalationpolicy.create({
     *   data: {
     *     // ... data to create a Team_escalationpolicy
     *   }
     * })
     * 
     */
    create<T extends team_escalationpolicyCreateArgs>(args: SelectSubset<T, team_escalationpolicyCreateArgs<ExtArgs>>): Prisma__team_escalationpolicyClient<$Result.GetResult<Prisma.$team_escalationpolicyPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Team_escalationpolicies.
     * @param {team_escalationpolicyCreateManyArgs} args - Arguments to create many Team_escalationpolicies.
     * @example
     * // Create many Team_escalationpolicies
     * const team_escalationpolicy = await prisma.team_escalationpolicy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends team_escalationpolicyCreateManyArgs>(args?: SelectSubset<T, team_escalationpolicyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team_escalationpolicy.
     * @param {team_escalationpolicyDeleteArgs} args - Arguments to delete one Team_escalationpolicy.
     * @example
     * // Delete one Team_escalationpolicy
     * const Team_escalationpolicy = await prisma.team_escalationpolicy.delete({
     *   where: {
     *     // ... filter to delete one Team_escalationpolicy
     *   }
     * })
     * 
     */
    delete<T extends team_escalationpolicyDeleteArgs>(args: SelectSubset<T, team_escalationpolicyDeleteArgs<ExtArgs>>): Prisma__team_escalationpolicyClient<$Result.GetResult<Prisma.$team_escalationpolicyPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team_escalationpolicy.
     * @param {team_escalationpolicyUpdateArgs} args - Arguments to update one Team_escalationpolicy.
     * @example
     * // Update one Team_escalationpolicy
     * const team_escalationpolicy = await prisma.team_escalationpolicy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends team_escalationpolicyUpdateArgs>(args: SelectSubset<T, team_escalationpolicyUpdateArgs<ExtArgs>>): Prisma__team_escalationpolicyClient<$Result.GetResult<Prisma.$team_escalationpolicyPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Team_escalationpolicies.
     * @param {team_escalationpolicyDeleteManyArgs} args - Arguments to filter Team_escalationpolicies to delete.
     * @example
     * // Delete a few Team_escalationpolicies
     * const { count } = await prisma.team_escalationpolicy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends team_escalationpolicyDeleteManyArgs>(args?: SelectSubset<T, team_escalationpolicyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Team_escalationpolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_escalationpolicyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Team_escalationpolicies
     * const team_escalationpolicy = await prisma.team_escalationpolicy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends team_escalationpolicyUpdateManyArgs>(args: SelectSubset<T, team_escalationpolicyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team_escalationpolicy.
     * @param {team_escalationpolicyUpsertArgs} args - Arguments to update or create a Team_escalationpolicy.
     * @example
     * // Update or create a Team_escalationpolicy
     * const team_escalationpolicy = await prisma.team_escalationpolicy.upsert({
     *   create: {
     *     // ... data to create a Team_escalationpolicy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team_escalationpolicy we want to update
     *   }
     * })
     */
    upsert<T extends team_escalationpolicyUpsertArgs>(args: SelectSubset<T, team_escalationpolicyUpsertArgs<ExtArgs>>): Prisma__team_escalationpolicyClient<$Result.GetResult<Prisma.$team_escalationpolicyPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Team_escalationpolicies that matches the filter.
     * @param {team_escalationpolicyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const team_escalationpolicy = await prisma.team_escalationpolicy.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: team_escalationpolicyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Team_escalationpolicy.
     * @param {team_escalationpolicyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const team_escalationpolicy = await prisma.team_escalationpolicy.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: team_escalationpolicyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Team_escalationpolicies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_escalationpolicyCountArgs} args - Arguments to filter Team_escalationpolicies to count.
     * @example
     * // Count the number of Team_escalationpolicies
     * const count = await prisma.team_escalationpolicy.count({
     *   where: {
     *     // ... the filter for the Team_escalationpolicies we want to count
     *   }
     * })
    **/
    count<T extends team_escalationpolicyCountArgs>(
      args?: Subset<T, team_escalationpolicyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Team_escalationpolicyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team_escalationpolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Team_escalationpolicyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Team_escalationpolicyAggregateArgs>(args: Subset<T, Team_escalationpolicyAggregateArgs>): Prisma.PrismaPromise<GetTeam_escalationpolicyAggregateType<T>>

    /**
     * Group by Team_escalationpolicy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_escalationpolicyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends team_escalationpolicyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: team_escalationpolicyGroupByArgs['orderBy'] }
        : { orderBy?: team_escalationpolicyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, team_escalationpolicyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeam_escalationpolicyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team_escalationpolicy model
   */
  readonly fields: team_escalationpolicyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team_escalationpolicy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__team_escalationpolicyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends teamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teamDefaultArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    escalation_policy_rules<T extends team_escalationpolicy$escalation_policy_rulesArgs<ExtArgs> = {}>(args?: Subset<T, team_escalationpolicy$escalation_policy_rulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the team_escalationpolicy model
   */ 
  interface team_escalationpolicyFieldRefs {
    readonly id: FieldRef<"team_escalationpolicy", 'String'>
    readonly teamId: FieldRef<"team_escalationpolicy", 'String'>
    readonly escalationplicy_name: FieldRef<"team_escalationpolicy", 'String'>
    readonly isActive: FieldRef<"team_escalationpolicy", 'Boolean'>
    readonly description: FieldRef<"team_escalationpolicy", 'String'>
    readonly createdAt: FieldRef<"team_escalationpolicy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * team_escalationpolicy findUnique
   */
  export type team_escalationpolicyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_escalationpolicy
     */
    select?: team_escalationpolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_escalationpolicyInclude<ExtArgs> | null
    /**
     * Filter, which team_escalationpolicy to fetch.
     */
    where: team_escalationpolicyWhereUniqueInput
  }

  /**
   * team_escalationpolicy findUniqueOrThrow
   */
  export type team_escalationpolicyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_escalationpolicy
     */
    select?: team_escalationpolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_escalationpolicyInclude<ExtArgs> | null
    /**
     * Filter, which team_escalationpolicy to fetch.
     */
    where: team_escalationpolicyWhereUniqueInput
  }

  /**
   * team_escalationpolicy findFirst
   */
  export type team_escalationpolicyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_escalationpolicy
     */
    select?: team_escalationpolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_escalationpolicyInclude<ExtArgs> | null
    /**
     * Filter, which team_escalationpolicy to fetch.
     */
    where?: team_escalationpolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_escalationpolicies to fetch.
     */
    orderBy?: team_escalationpolicyOrderByWithRelationInput | team_escalationpolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_escalationpolicies.
     */
    cursor?: team_escalationpolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_escalationpolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_escalationpolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_escalationpolicies.
     */
    distinct?: Team_escalationpolicyScalarFieldEnum | Team_escalationpolicyScalarFieldEnum[]
  }

  /**
   * team_escalationpolicy findFirstOrThrow
   */
  export type team_escalationpolicyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_escalationpolicy
     */
    select?: team_escalationpolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_escalationpolicyInclude<ExtArgs> | null
    /**
     * Filter, which team_escalationpolicy to fetch.
     */
    where?: team_escalationpolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_escalationpolicies to fetch.
     */
    orderBy?: team_escalationpolicyOrderByWithRelationInput | team_escalationpolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_escalationpolicies.
     */
    cursor?: team_escalationpolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_escalationpolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_escalationpolicies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_escalationpolicies.
     */
    distinct?: Team_escalationpolicyScalarFieldEnum | Team_escalationpolicyScalarFieldEnum[]
  }

  /**
   * team_escalationpolicy findMany
   */
  export type team_escalationpolicyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_escalationpolicy
     */
    select?: team_escalationpolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_escalationpolicyInclude<ExtArgs> | null
    /**
     * Filter, which team_escalationpolicies to fetch.
     */
    where?: team_escalationpolicyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_escalationpolicies to fetch.
     */
    orderBy?: team_escalationpolicyOrderByWithRelationInput | team_escalationpolicyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing team_escalationpolicies.
     */
    cursor?: team_escalationpolicyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_escalationpolicies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_escalationpolicies.
     */
    skip?: number
    distinct?: Team_escalationpolicyScalarFieldEnum | Team_escalationpolicyScalarFieldEnum[]
  }

  /**
   * team_escalationpolicy create
   */
  export type team_escalationpolicyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_escalationpolicy
     */
    select?: team_escalationpolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_escalationpolicyInclude<ExtArgs> | null
    /**
     * The data needed to create a team_escalationpolicy.
     */
    data: XOR<team_escalationpolicyCreateInput, team_escalationpolicyUncheckedCreateInput>
  }

  /**
   * team_escalationpolicy createMany
   */
  export type team_escalationpolicyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many team_escalationpolicies.
     */
    data: team_escalationpolicyCreateManyInput | team_escalationpolicyCreateManyInput[]
  }

  /**
   * team_escalationpolicy update
   */
  export type team_escalationpolicyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_escalationpolicy
     */
    select?: team_escalationpolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_escalationpolicyInclude<ExtArgs> | null
    /**
     * The data needed to update a team_escalationpolicy.
     */
    data: XOR<team_escalationpolicyUpdateInput, team_escalationpolicyUncheckedUpdateInput>
    /**
     * Choose, which team_escalationpolicy to update.
     */
    where: team_escalationpolicyWhereUniqueInput
  }

  /**
   * team_escalationpolicy updateMany
   */
  export type team_escalationpolicyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update team_escalationpolicies.
     */
    data: XOR<team_escalationpolicyUpdateManyMutationInput, team_escalationpolicyUncheckedUpdateManyInput>
    /**
     * Filter which team_escalationpolicies to update
     */
    where?: team_escalationpolicyWhereInput
  }

  /**
   * team_escalationpolicy upsert
   */
  export type team_escalationpolicyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_escalationpolicy
     */
    select?: team_escalationpolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_escalationpolicyInclude<ExtArgs> | null
    /**
     * The filter to search for the team_escalationpolicy to update in case it exists.
     */
    where: team_escalationpolicyWhereUniqueInput
    /**
     * In case the team_escalationpolicy found by the `where` argument doesn't exist, create a new team_escalationpolicy with this data.
     */
    create: XOR<team_escalationpolicyCreateInput, team_escalationpolicyUncheckedCreateInput>
    /**
     * In case the team_escalationpolicy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<team_escalationpolicyUpdateInput, team_escalationpolicyUncheckedUpdateInput>
  }

  /**
   * team_escalationpolicy delete
   */
  export type team_escalationpolicyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_escalationpolicy
     */
    select?: team_escalationpolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_escalationpolicyInclude<ExtArgs> | null
    /**
     * Filter which team_escalationpolicy to delete.
     */
    where: team_escalationpolicyWhereUniqueInput
  }

  /**
   * team_escalationpolicy deleteMany
   */
  export type team_escalationpolicyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_escalationpolicies to delete
     */
    where?: team_escalationpolicyWhereInput
  }

  /**
   * team_escalationpolicy findRaw
   */
  export type team_escalationpolicyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team_escalationpolicy aggregateRaw
   */
  export type team_escalationpolicyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team_escalationpolicy.escalation_policy_rules
   */
  export type team_escalationpolicy$escalation_policy_rulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    where?: escalation_policy_rulesWhereInput
    orderBy?: escalation_policy_rulesOrderByWithRelationInput | escalation_policy_rulesOrderByWithRelationInput[]
    cursor?: escalation_policy_rulesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Escalation_policy_rulesScalarFieldEnum | Escalation_policy_rulesScalarFieldEnum[]
  }

  /**
   * team_escalationpolicy without action
   */
  export type team_escalationpolicyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_escalationpolicy
     */
    select?: team_escalationpolicySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_escalationpolicyInclude<ExtArgs> | null
  }


  /**
   * Model escalation_policy_rules
   */

  export type AggregateEscalation_policy_rules = {
    _count: Escalation_policy_rulesCountAggregateOutputType | null
    _avg: Escalation_policy_rulesAvgAggregateOutputType | null
    _sum: Escalation_policy_rulesSumAggregateOutputType | null
    _min: Escalation_policy_rulesMinAggregateOutputType | null
    _max: Escalation_policy_rulesMaxAggregateOutputType | null
  }

  export type Escalation_policy_rulesAvgAggregateOutputType = {
    minutes_after_creation: number | null
  }

  export type Escalation_policy_rulesSumAggregateOutputType = {
    minutes_after_creation: number | null
  }

  export type Escalation_policy_rulesMinAggregateOutputType = {
    id: string | null
    team_escalationpolicyId: string | null
    alert_status: string | null
    minutes_after_creation: number | null
    notification_type: $Enums.notification_type | null
    userId: string | null
    scheudleId: string | null
    teamId: string | null
    is_active: boolean | null
  }

  export type Escalation_policy_rulesMaxAggregateOutputType = {
    id: string | null
    team_escalationpolicyId: string | null
    alert_status: string | null
    minutes_after_creation: number | null
    notification_type: $Enums.notification_type | null
    userId: string | null
    scheudleId: string | null
    teamId: string | null
    is_active: boolean | null
  }

  export type Escalation_policy_rulesCountAggregateOutputType = {
    id: number
    team_escalationpolicyId: number
    alert_status: number
    minutes_after_creation: number
    notification_type: number
    userId: number
    scheudleId: number
    teamId: number
    is_active: number
    _all: number
  }


  export type Escalation_policy_rulesAvgAggregateInputType = {
    minutes_after_creation?: true
  }

  export type Escalation_policy_rulesSumAggregateInputType = {
    minutes_after_creation?: true
  }

  export type Escalation_policy_rulesMinAggregateInputType = {
    id?: true
    team_escalationpolicyId?: true
    alert_status?: true
    minutes_after_creation?: true
    notification_type?: true
    userId?: true
    scheudleId?: true
    teamId?: true
    is_active?: true
  }

  export type Escalation_policy_rulesMaxAggregateInputType = {
    id?: true
    team_escalationpolicyId?: true
    alert_status?: true
    minutes_after_creation?: true
    notification_type?: true
    userId?: true
    scheudleId?: true
    teamId?: true
    is_active?: true
  }

  export type Escalation_policy_rulesCountAggregateInputType = {
    id?: true
    team_escalationpolicyId?: true
    alert_status?: true
    minutes_after_creation?: true
    notification_type?: true
    userId?: true
    scheudleId?: true
    teamId?: true
    is_active?: true
    _all?: true
  }

  export type Escalation_policy_rulesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which escalation_policy_rules to aggregate.
     */
    where?: escalation_policy_rulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escalation_policy_rules to fetch.
     */
    orderBy?: escalation_policy_rulesOrderByWithRelationInput | escalation_policy_rulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: escalation_policy_rulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escalation_policy_rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escalation_policy_rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned escalation_policy_rules
    **/
    _count?: true | Escalation_policy_rulesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Escalation_policy_rulesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Escalation_policy_rulesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Escalation_policy_rulesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Escalation_policy_rulesMaxAggregateInputType
  }

  export type GetEscalation_policy_rulesAggregateType<T extends Escalation_policy_rulesAggregateArgs> = {
        [P in keyof T & keyof AggregateEscalation_policy_rules]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEscalation_policy_rules[P]>
      : GetScalarType<T[P], AggregateEscalation_policy_rules[P]>
  }




  export type escalation_policy_rulesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: escalation_policy_rulesWhereInput
    orderBy?: escalation_policy_rulesOrderByWithAggregationInput | escalation_policy_rulesOrderByWithAggregationInput[]
    by: Escalation_policy_rulesScalarFieldEnum[] | Escalation_policy_rulesScalarFieldEnum
    having?: escalation_policy_rulesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Escalation_policy_rulesCountAggregateInputType | true
    _avg?: Escalation_policy_rulesAvgAggregateInputType
    _sum?: Escalation_policy_rulesSumAggregateInputType
    _min?: Escalation_policy_rulesMinAggregateInputType
    _max?: Escalation_policy_rulesMaxAggregateInputType
  }

  export type Escalation_policy_rulesGroupByOutputType = {
    id: string
    team_escalationpolicyId: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    userId: string | null
    scheudleId: string | null
    teamId: string | null
    is_active: boolean
    _count: Escalation_policy_rulesCountAggregateOutputType | null
    _avg: Escalation_policy_rulesAvgAggregateOutputType | null
    _sum: Escalation_policy_rulesSumAggregateOutputType | null
    _min: Escalation_policy_rulesMinAggregateOutputType | null
    _max: Escalation_policy_rulesMaxAggregateOutputType | null
  }

  type GetEscalation_policy_rulesGroupByPayload<T extends escalation_policy_rulesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Escalation_policy_rulesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Escalation_policy_rulesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Escalation_policy_rulesGroupByOutputType[P]>
            : GetScalarType<T[P], Escalation_policy_rulesGroupByOutputType[P]>
        }
      >
    >


  export type escalation_policy_rulesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    team_escalationpolicyId?: boolean
    alert_status?: boolean
    minutes_after_creation?: boolean
    notification_type?: boolean
    userId?: boolean
    scheudleId?: boolean
    teamId?: boolean
    is_active?: boolean
    team_escalation_policy?: boolean | team_escalationpolicyDefaultArgs<ExtArgs>
    user?: boolean | escalation_policy_rules$userArgs<ExtArgs>
    team?: boolean | escalation_policy_rules$teamArgs<ExtArgs>
  }, ExtArgs["result"]["escalation_policy_rules"]>


  export type escalation_policy_rulesSelectScalar = {
    id?: boolean
    team_escalationpolicyId?: boolean
    alert_status?: boolean
    minutes_after_creation?: boolean
    notification_type?: boolean
    userId?: boolean
    scheudleId?: boolean
    teamId?: boolean
    is_active?: boolean
  }

  export type escalation_policy_rulesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team_escalation_policy?: boolean | team_escalationpolicyDefaultArgs<ExtArgs>
    user?: boolean | escalation_policy_rules$userArgs<ExtArgs>
    team?: boolean | escalation_policy_rules$teamArgs<ExtArgs>
  }

  export type $escalation_policy_rulesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "escalation_policy_rules"
    objects: {
      team_escalation_policy: Prisma.$team_escalationpolicyPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs> | null
      team: Prisma.$teamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      team_escalationpolicyId: string
      alert_status: string
      minutes_after_creation: number
      notification_type: $Enums.notification_type
      userId: string | null
      scheudleId: string | null
      teamId: string | null
      is_active: boolean
    }, ExtArgs["result"]["escalation_policy_rules"]>
    composites: {}
  }

  type escalation_policy_rulesGetPayload<S extends boolean | null | undefined | escalation_policy_rulesDefaultArgs> = $Result.GetResult<Prisma.$escalation_policy_rulesPayload, S>

  type escalation_policy_rulesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<escalation_policy_rulesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Escalation_policy_rulesCountAggregateInputType | true
    }

  export interface escalation_policy_rulesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['escalation_policy_rules'], meta: { name: 'escalation_policy_rules' } }
    /**
     * Find zero or one Escalation_policy_rules that matches the filter.
     * @param {escalation_policy_rulesFindUniqueArgs} args - Arguments to find a Escalation_policy_rules
     * @example
     * // Get one Escalation_policy_rules
     * const escalation_policy_rules = await prisma.escalation_policy_rules.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends escalation_policy_rulesFindUniqueArgs>(args: SelectSubset<T, escalation_policy_rulesFindUniqueArgs<ExtArgs>>): Prisma__escalation_policy_rulesClient<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Escalation_policy_rules that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {escalation_policy_rulesFindUniqueOrThrowArgs} args - Arguments to find a Escalation_policy_rules
     * @example
     * // Get one Escalation_policy_rules
     * const escalation_policy_rules = await prisma.escalation_policy_rules.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends escalation_policy_rulesFindUniqueOrThrowArgs>(args: SelectSubset<T, escalation_policy_rulesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__escalation_policy_rulesClient<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Escalation_policy_rules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escalation_policy_rulesFindFirstArgs} args - Arguments to find a Escalation_policy_rules
     * @example
     * // Get one Escalation_policy_rules
     * const escalation_policy_rules = await prisma.escalation_policy_rules.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends escalation_policy_rulesFindFirstArgs>(args?: SelectSubset<T, escalation_policy_rulesFindFirstArgs<ExtArgs>>): Prisma__escalation_policy_rulesClient<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Escalation_policy_rules that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escalation_policy_rulesFindFirstOrThrowArgs} args - Arguments to find a Escalation_policy_rules
     * @example
     * // Get one Escalation_policy_rules
     * const escalation_policy_rules = await prisma.escalation_policy_rules.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends escalation_policy_rulesFindFirstOrThrowArgs>(args?: SelectSubset<T, escalation_policy_rulesFindFirstOrThrowArgs<ExtArgs>>): Prisma__escalation_policy_rulesClient<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Escalation_policy_rules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escalation_policy_rulesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Escalation_policy_rules
     * const escalation_policy_rules = await prisma.escalation_policy_rules.findMany()
     * 
     * // Get first 10 Escalation_policy_rules
     * const escalation_policy_rules = await prisma.escalation_policy_rules.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const escalation_policy_rulesWithIdOnly = await prisma.escalation_policy_rules.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends escalation_policy_rulesFindManyArgs>(args?: SelectSubset<T, escalation_policy_rulesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Escalation_policy_rules.
     * @param {escalation_policy_rulesCreateArgs} args - Arguments to create a Escalation_policy_rules.
     * @example
     * // Create one Escalation_policy_rules
     * const Escalation_policy_rules = await prisma.escalation_policy_rules.create({
     *   data: {
     *     // ... data to create a Escalation_policy_rules
     *   }
     * })
     * 
     */
    create<T extends escalation_policy_rulesCreateArgs>(args: SelectSubset<T, escalation_policy_rulesCreateArgs<ExtArgs>>): Prisma__escalation_policy_rulesClient<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Escalation_policy_rules.
     * @param {escalation_policy_rulesCreateManyArgs} args - Arguments to create many Escalation_policy_rules.
     * @example
     * // Create many Escalation_policy_rules
     * const escalation_policy_rules = await prisma.escalation_policy_rules.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends escalation_policy_rulesCreateManyArgs>(args?: SelectSubset<T, escalation_policy_rulesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Escalation_policy_rules.
     * @param {escalation_policy_rulesDeleteArgs} args - Arguments to delete one Escalation_policy_rules.
     * @example
     * // Delete one Escalation_policy_rules
     * const Escalation_policy_rules = await prisma.escalation_policy_rules.delete({
     *   where: {
     *     // ... filter to delete one Escalation_policy_rules
     *   }
     * })
     * 
     */
    delete<T extends escalation_policy_rulesDeleteArgs>(args: SelectSubset<T, escalation_policy_rulesDeleteArgs<ExtArgs>>): Prisma__escalation_policy_rulesClient<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Escalation_policy_rules.
     * @param {escalation_policy_rulesUpdateArgs} args - Arguments to update one Escalation_policy_rules.
     * @example
     * // Update one Escalation_policy_rules
     * const escalation_policy_rules = await prisma.escalation_policy_rules.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends escalation_policy_rulesUpdateArgs>(args: SelectSubset<T, escalation_policy_rulesUpdateArgs<ExtArgs>>): Prisma__escalation_policy_rulesClient<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Escalation_policy_rules.
     * @param {escalation_policy_rulesDeleteManyArgs} args - Arguments to filter Escalation_policy_rules to delete.
     * @example
     * // Delete a few Escalation_policy_rules
     * const { count } = await prisma.escalation_policy_rules.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends escalation_policy_rulesDeleteManyArgs>(args?: SelectSubset<T, escalation_policy_rulesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Escalation_policy_rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escalation_policy_rulesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Escalation_policy_rules
     * const escalation_policy_rules = await prisma.escalation_policy_rules.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends escalation_policy_rulesUpdateManyArgs>(args: SelectSubset<T, escalation_policy_rulesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Escalation_policy_rules.
     * @param {escalation_policy_rulesUpsertArgs} args - Arguments to update or create a Escalation_policy_rules.
     * @example
     * // Update or create a Escalation_policy_rules
     * const escalation_policy_rules = await prisma.escalation_policy_rules.upsert({
     *   create: {
     *     // ... data to create a Escalation_policy_rules
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Escalation_policy_rules we want to update
     *   }
     * })
     */
    upsert<T extends escalation_policy_rulesUpsertArgs>(args: SelectSubset<T, escalation_policy_rulesUpsertArgs<ExtArgs>>): Prisma__escalation_policy_rulesClient<$Result.GetResult<Prisma.$escalation_policy_rulesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Escalation_policy_rules that matches the filter.
     * @param {escalation_policy_rulesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const escalation_policy_rules = await prisma.escalation_policy_rules.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: escalation_policy_rulesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Escalation_policy_rules.
     * @param {escalation_policy_rulesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const escalation_policy_rules = await prisma.escalation_policy_rules.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: escalation_policy_rulesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Escalation_policy_rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escalation_policy_rulesCountArgs} args - Arguments to filter Escalation_policy_rules to count.
     * @example
     * // Count the number of Escalation_policy_rules
     * const count = await prisma.escalation_policy_rules.count({
     *   where: {
     *     // ... the filter for the Escalation_policy_rules we want to count
     *   }
     * })
    **/
    count<T extends escalation_policy_rulesCountArgs>(
      args?: Subset<T, escalation_policy_rulesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Escalation_policy_rulesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Escalation_policy_rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Escalation_policy_rulesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Escalation_policy_rulesAggregateArgs>(args: Subset<T, Escalation_policy_rulesAggregateArgs>): Prisma.PrismaPromise<GetEscalation_policy_rulesAggregateType<T>>

    /**
     * Group by Escalation_policy_rules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {escalation_policy_rulesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends escalation_policy_rulesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: escalation_policy_rulesGroupByArgs['orderBy'] }
        : { orderBy?: escalation_policy_rulesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, escalation_policy_rulesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEscalation_policy_rulesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the escalation_policy_rules model
   */
  readonly fields: escalation_policy_rulesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for escalation_policy_rules.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__escalation_policy_rulesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team_escalation_policy<T extends team_escalationpolicyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, team_escalationpolicyDefaultArgs<ExtArgs>>): Prisma__team_escalationpolicyClient<$Result.GetResult<Prisma.$team_escalationpolicyPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends escalation_policy_rules$userArgs<ExtArgs> = {}>(args?: Subset<T, escalation_policy_rules$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    team<T extends escalation_policy_rules$teamArgs<ExtArgs> = {}>(args?: Subset<T, escalation_policy_rules$teamArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the escalation_policy_rules model
   */ 
  interface escalation_policy_rulesFieldRefs {
    readonly id: FieldRef<"escalation_policy_rules", 'String'>
    readonly team_escalationpolicyId: FieldRef<"escalation_policy_rules", 'String'>
    readonly alert_status: FieldRef<"escalation_policy_rules", 'String'>
    readonly minutes_after_creation: FieldRef<"escalation_policy_rules", 'Int'>
    readonly notification_type: FieldRef<"escalation_policy_rules", 'notification_type'>
    readonly userId: FieldRef<"escalation_policy_rules", 'String'>
    readonly scheudleId: FieldRef<"escalation_policy_rules", 'String'>
    readonly teamId: FieldRef<"escalation_policy_rules", 'String'>
    readonly is_active: FieldRef<"escalation_policy_rules", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * escalation_policy_rules findUnique
   */
  export type escalation_policy_rulesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    /**
     * Filter, which escalation_policy_rules to fetch.
     */
    where: escalation_policy_rulesWhereUniqueInput
  }

  /**
   * escalation_policy_rules findUniqueOrThrow
   */
  export type escalation_policy_rulesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    /**
     * Filter, which escalation_policy_rules to fetch.
     */
    where: escalation_policy_rulesWhereUniqueInput
  }

  /**
   * escalation_policy_rules findFirst
   */
  export type escalation_policy_rulesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    /**
     * Filter, which escalation_policy_rules to fetch.
     */
    where?: escalation_policy_rulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escalation_policy_rules to fetch.
     */
    orderBy?: escalation_policy_rulesOrderByWithRelationInput | escalation_policy_rulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for escalation_policy_rules.
     */
    cursor?: escalation_policy_rulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escalation_policy_rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escalation_policy_rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of escalation_policy_rules.
     */
    distinct?: Escalation_policy_rulesScalarFieldEnum | Escalation_policy_rulesScalarFieldEnum[]
  }

  /**
   * escalation_policy_rules findFirstOrThrow
   */
  export type escalation_policy_rulesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    /**
     * Filter, which escalation_policy_rules to fetch.
     */
    where?: escalation_policy_rulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escalation_policy_rules to fetch.
     */
    orderBy?: escalation_policy_rulesOrderByWithRelationInput | escalation_policy_rulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for escalation_policy_rules.
     */
    cursor?: escalation_policy_rulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escalation_policy_rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escalation_policy_rules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of escalation_policy_rules.
     */
    distinct?: Escalation_policy_rulesScalarFieldEnum | Escalation_policy_rulesScalarFieldEnum[]
  }

  /**
   * escalation_policy_rules findMany
   */
  export type escalation_policy_rulesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    /**
     * Filter, which escalation_policy_rules to fetch.
     */
    where?: escalation_policy_rulesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of escalation_policy_rules to fetch.
     */
    orderBy?: escalation_policy_rulesOrderByWithRelationInput | escalation_policy_rulesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing escalation_policy_rules.
     */
    cursor?: escalation_policy_rulesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` escalation_policy_rules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` escalation_policy_rules.
     */
    skip?: number
    distinct?: Escalation_policy_rulesScalarFieldEnum | Escalation_policy_rulesScalarFieldEnum[]
  }

  /**
   * escalation_policy_rules create
   */
  export type escalation_policy_rulesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    /**
     * The data needed to create a escalation_policy_rules.
     */
    data: XOR<escalation_policy_rulesCreateInput, escalation_policy_rulesUncheckedCreateInput>
  }

  /**
   * escalation_policy_rules createMany
   */
  export type escalation_policy_rulesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many escalation_policy_rules.
     */
    data: escalation_policy_rulesCreateManyInput | escalation_policy_rulesCreateManyInput[]
  }

  /**
   * escalation_policy_rules update
   */
  export type escalation_policy_rulesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    /**
     * The data needed to update a escalation_policy_rules.
     */
    data: XOR<escalation_policy_rulesUpdateInput, escalation_policy_rulesUncheckedUpdateInput>
    /**
     * Choose, which escalation_policy_rules to update.
     */
    where: escalation_policy_rulesWhereUniqueInput
  }

  /**
   * escalation_policy_rules updateMany
   */
  export type escalation_policy_rulesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update escalation_policy_rules.
     */
    data: XOR<escalation_policy_rulesUpdateManyMutationInput, escalation_policy_rulesUncheckedUpdateManyInput>
    /**
     * Filter which escalation_policy_rules to update
     */
    where?: escalation_policy_rulesWhereInput
  }

  /**
   * escalation_policy_rules upsert
   */
  export type escalation_policy_rulesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    /**
     * The filter to search for the escalation_policy_rules to update in case it exists.
     */
    where: escalation_policy_rulesWhereUniqueInput
    /**
     * In case the escalation_policy_rules found by the `where` argument doesn't exist, create a new escalation_policy_rules with this data.
     */
    create: XOR<escalation_policy_rulesCreateInput, escalation_policy_rulesUncheckedCreateInput>
    /**
     * In case the escalation_policy_rules was found with the provided `where` argument, update it with this data.
     */
    update: XOR<escalation_policy_rulesUpdateInput, escalation_policy_rulesUncheckedUpdateInput>
  }

  /**
   * escalation_policy_rules delete
   */
  export type escalation_policy_rulesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
    /**
     * Filter which escalation_policy_rules to delete.
     */
    where: escalation_policy_rulesWhereUniqueInput
  }

  /**
   * escalation_policy_rules deleteMany
   */
  export type escalation_policy_rulesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which escalation_policy_rules to delete
     */
    where?: escalation_policy_rulesWhereInput
  }

  /**
   * escalation_policy_rules findRaw
   */
  export type escalation_policy_rulesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * escalation_policy_rules aggregateRaw
   */
  export type escalation_policy_rulesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * escalation_policy_rules.user
   */
  export type escalation_policy_rules$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * escalation_policy_rules.team
   */
  export type escalation_policy_rules$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team
     */
    select?: teamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: teamInclude<ExtArgs> | null
    where?: teamWhereInput
  }

  /**
   * escalation_policy_rules without action
   */
  export type escalation_policy_rulesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the escalation_policy_rules
     */
    select?: escalation_policy_rulesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: escalation_policy_rulesInclude<ExtArgs> | null
  }


  /**
   * Model team_schedule
   */

  export type AggregateTeam_schedule = {
    _count: Team_scheduleCountAggregateOutputType | null
    _min: Team_scheduleMinAggregateOutputType | null
    _max: Team_scheduleMaxAggregateOutputType | null
  }

  export type Team_scheduleMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    name: string | null
    createdAt: Date | null
  }

  export type Team_scheduleMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    name: string | null
    createdAt: Date | null
  }

  export type Team_scheduleCountAggregateOutputType = {
    id: number
    teamId: number
    name: number
    createdAt: number
    _all: number
  }


  export type Team_scheduleMinAggregateInputType = {
    id?: true
    teamId?: true
    name?: true
    createdAt?: true
  }

  export type Team_scheduleMaxAggregateInputType = {
    id?: true
    teamId?: true
    name?: true
    createdAt?: true
  }

  export type Team_scheduleCountAggregateInputType = {
    id?: true
    teamId?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type Team_scheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_schedule to aggregate.
     */
    where?: team_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedules to fetch.
     */
    orderBy?: team_scheduleOrderByWithRelationInput | team_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: team_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned team_schedules
    **/
    _count?: true | Team_scheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Team_scheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Team_scheduleMaxAggregateInputType
  }

  export type GetTeam_scheduleAggregateType<T extends Team_scheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam_schedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam_schedule[P]>
      : GetScalarType<T[P], AggregateTeam_schedule[P]>
  }




  export type team_scheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_scheduleWhereInput
    orderBy?: team_scheduleOrderByWithAggregationInput | team_scheduleOrderByWithAggregationInput[]
    by: Team_scheduleScalarFieldEnum[] | Team_scheduleScalarFieldEnum
    having?: team_scheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Team_scheduleCountAggregateInputType | true
    _min?: Team_scheduleMinAggregateInputType
    _max?: Team_scheduleMaxAggregateInputType
  }

  export type Team_scheduleGroupByOutputType = {
    id: string
    teamId: string
    name: string
    createdAt: Date
    _count: Team_scheduleCountAggregateOutputType | null
    _min: Team_scheduleMinAggregateOutputType | null
    _max: Team_scheduleMaxAggregateOutputType | null
  }

  type GetTeam_scheduleGroupByPayload<T extends team_scheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Team_scheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Team_scheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Team_scheduleGroupByOutputType[P]>
            : GetScalarType<T[P], Team_scheduleGroupByOutputType[P]>
        }
      >
    >


  export type team_scheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    name?: boolean
    createdAt?: boolean
    team?: boolean | teamDefaultArgs<ExtArgs>
    team_schedule_rotation?: boolean | team_schedule$team_schedule_rotationArgs<ExtArgs>
    team_schedule_override?: boolean | team_schedule$team_schedule_overrideArgs<ExtArgs>
    _count?: boolean | Team_scheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team_schedule"]>


  export type team_scheduleSelectScalar = {
    id?: boolean
    teamId?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type team_scheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | teamDefaultArgs<ExtArgs>
    team_schedule_rotation?: boolean | team_schedule$team_schedule_rotationArgs<ExtArgs>
    team_schedule_override?: boolean | team_schedule$team_schedule_overrideArgs<ExtArgs>
    _count?: boolean | Team_scheduleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $team_schedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team_schedule"
    objects: {
      team: Prisma.$teamPayload<ExtArgs>
      team_schedule_rotation: Prisma.$team_schedule_rotationPayload<ExtArgs>[]
      team_schedule_override: Prisma.$team_schedule_overridePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      name: string
      createdAt: Date
    }, ExtArgs["result"]["team_schedule"]>
    composites: {}
  }

  type team_scheduleGetPayload<S extends boolean | null | undefined | team_scheduleDefaultArgs> = $Result.GetResult<Prisma.$team_schedulePayload, S>

  type team_scheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<team_scheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Team_scheduleCountAggregateInputType | true
    }

  export interface team_scheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team_schedule'], meta: { name: 'team_schedule' } }
    /**
     * Find zero or one Team_schedule that matches the filter.
     * @param {team_scheduleFindUniqueArgs} args - Arguments to find a Team_schedule
     * @example
     * // Get one Team_schedule
     * const team_schedule = await prisma.team_schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends team_scheduleFindUniqueArgs>(args: SelectSubset<T, team_scheduleFindUniqueArgs<ExtArgs>>): Prisma__team_scheduleClient<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team_schedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {team_scheduleFindUniqueOrThrowArgs} args - Arguments to find a Team_schedule
     * @example
     * // Get one Team_schedule
     * const team_schedule = await prisma.team_schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends team_scheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, team_scheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__team_scheduleClient<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team_schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_scheduleFindFirstArgs} args - Arguments to find a Team_schedule
     * @example
     * // Get one Team_schedule
     * const team_schedule = await prisma.team_schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends team_scheduleFindFirstArgs>(args?: SelectSubset<T, team_scheduleFindFirstArgs<ExtArgs>>): Prisma__team_scheduleClient<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team_schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_scheduleFindFirstOrThrowArgs} args - Arguments to find a Team_schedule
     * @example
     * // Get one Team_schedule
     * const team_schedule = await prisma.team_schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends team_scheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, team_scheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__team_scheduleClient<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Team_schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_scheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Team_schedules
     * const team_schedules = await prisma.team_schedule.findMany()
     * 
     * // Get first 10 Team_schedules
     * const team_schedules = await prisma.team_schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const team_scheduleWithIdOnly = await prisma.team_schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends team_scheduleFindManyArgs>(args?: SelectSubset<T, team_scheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team_schedule.
     * @param {team_scheduleCreateArgs} args - Arguments to create a Team_schedule.
     * @example
     * // Create one Team_schedule
     * const Team_schedule = await prisma.team_schedule.create({
     *   data: {
     *     // ... data to create a Team_schedule
     *   }
     * })
     * 
     */
    create<T extends team_scheduleCreateArgs>(args: SelectSubset<T, team_scheduleCreateArgs<ExtArgs>>): Prisma__team_scheduleClient<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Team_schedules.
     * @param {team_scheduleCreateManyArgs} args - Arguments to create many Team_schedules.
     * @example
     * // Create many Team_schedules
     * const team_schedule = await prisma.team_schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends team_scheduleCreateManyArgs>(args?: SelectSubset<T, team_scheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team_schedule.
     * @param {team_scheduleDeleteArgs} args - Arguments to delete one Team_schedule.
     * @example
     * // Delete one Team_schedule
     * const Team_schedule = await prisma.team_schedule.delete({
     *   where: {
     *     // ... filter to delete one Team_schedule
     *   }
     * })
     * 
     */
    delete<T extends team_scheduleDeleteArgs>(args: SelectSubset<T, team_scheduleDeleteArgs<ExtArgs>>): Prisma__team_scheduleClient<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team_schedule.
     * @param {team_scheduleUpdateArgs} args - Arguments to update one Team_schedule.
     * @example
     * // Update one Team_schedule
     * const team_schedule = await prisma.team_schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends team_scheduleUpdateArgs>(args: SelectSubset<T, team_scheduleUpdateArgs<ExtArgs>>): Prisma__team_scheduleClient<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Team_schedules.
     * @param {team_scheduleDeleteManyArgs} args - Arguments to filter Team_schedules to delete.
     * @example
     * // Delete a few Team_schedules
     * const { count } = await prisma.team_schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends team_scheduleDeleteManyArgs>(args?: SelectSubset<T, team_scheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Team_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_scheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Team_schedules
     * const team_schedule = await prisma.team_schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends team_scheduleUpdateManyArgs>(args: SelectSubset<T, team_scheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team_schedule.
     * @param {team_scheduleUpsertArgs} args - Arguments to update or create a Team_schedule.
     * @example
     * // Update or create a Team_schedule
     * const team_schedule = await prisma.team_schedule.upsert({
     *   create: {
     *     // ... data to create a Team_schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team_schedule we want to update
     *   }
     * })
     */
    upsert<T extends team_scheduleUpsertArgs>(args: SelectSubset<T, team_scheduleUpsertArgs<ExtArgs>>): Prisma__team_scheduleClient<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Team_schedules that matches the filter.
     * @param {team_scheduleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const team_schedule = await prisma.team_schedule.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: team_scheduleFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Team_schedule.
     * @param {team_scheduleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const team_schedule = await prisma.team_schedule.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: team_scheduleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Team_schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_scheduleCountArgs} args - Arguments to filter Team_schedules to count.
     * @example
     * // Count the number of Team_schedules
     * const count = await prisma.team_schedule.count({
     *   where: {
     *     // ... the filter for the Team_schedules we want to count
     *   }
     * })
    **/
    count<T extends team_scheduleCountArgs>(
      args?: Subset<T, team_scheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Team_scheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team_schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Team_scheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Team_scheduleAggregateArgs>(args: Subset<T, Team_scheduleAggregateArgs>): Prisma.PrismaPromise<GetTeam_scheduleAggregateType<T>>

    /**
     * Group by Team_schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_scheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends team_scheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: team_scheduleGroupByArgs['orderBy'] }
        : { orderBy?: team_scheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, team_scheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeam_scheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team_schedule model
   */
  readonly fields: team_scheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team_schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__team_scheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends teamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, teamDefaultArgs<ExtArgs>>): Prisma__teamClient<$Result.GetResult<Prisma.$teamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team_schedule_rotation<T extends team_schedule$team_schedule_rotationArgs<ExtArgs> = {}>(args?: Subset<T, team_schedule$team_schedule_rotationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_schedule_rotationPayload<ExtArgs>, T, "findMany"> | Null>
    team_schedule_override<T extends team_schedule$team_schedule_overrideArgs<ExtArgs> = {}>(args?: Subset<T, team_schedule$team_schedule_overrideArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_schedule_overridePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the team_schedule model
   */ 
  interface team_scheduleFieldRefs {
    readonly id: FieldRef<"team_schedule", 'String'>
    readonly teamId: FieldRef<"team_schedule", 'String'>
    readonly name: FieldRef<"team_schedule", 'String'>
    readonly createdAt: FieldRef<"team_schedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * team_schedule findUnique
   */
  export type team_scheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule
     */
    select?: team_scheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule to fetch.
     */
    where: team_scheduleWhereUniqueInput
  }

  /**
   * team_schedule findUniqueOrThrow
   */
  export type team_scheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule
     */
    select?: team_scheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule to fetch.
     */
    where: team_scheduleWhereUniqueInput
  }

  /**
   * team_schedule findFirst
   */
  export type team_scheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule
     */
    select?: team_scheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule to fetch.
     */
    where?: team_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedules to fetch.
     */
    orderBy?: team_scheduleOrderByWithRelationInput | team_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_schedules.
     */
    cursor?: team_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_schedules.
     */
    distinct?: Team_scheduleScalarFieldEnum | Team_scheduleScalarFieldEnum[]
  }

  /**
   * team_schedule findFirstOrThrow
   */
  export type team_scheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule
     */
    select?: team_scheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule to fetch.
     */
    where?: team_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedules to fetch.
     */
    orderBy?: team_scheduleOrderByWithRelationInput | team_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_schedules.
     */
    cursor?: team_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_schedules.
     */
    distinct?: Team_scheduleScalarFieldEnum | Team_scheduleScalarFieldEnum[]
  }

  /**
   * team_schedule findMany
   */
  export type team_scheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule
     */
    select?: team_scheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_scheduleInclude<ExtArgs> | null
    /**
     * Filter, which team_schedules to fetch.
     */
    where?: team_scheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedules to fetch.
     */
    orderBy?: team_scheduleOrderByWithRelationInput | team_scheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing team_schedules.
     */
    cursor?: team_scheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedules.
     */
    skip?: number
    distinct?: Team_scheduleScalarFieldEnum | Team_scheduleScalarFieldEnum[]
  }

  /**
   * team_schedule create
   */
  export type team_scheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule
     */
    select?: team_scheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_scheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a team_schedule.
     */
    data: XOR<team_scheduleCreateInput, team_scheduleUncheckedCreateInput>
  }

  /**
   * team_schedule createMany
   */
  export type team_scheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many team_schedules.
     */
    data: team_scheduleCreateManyInput | team_scheduleCreateManyInput[]
  }

  /**
   * team_schedule update
   */
  export type team_scheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule
     */
    select?: team_scheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_scheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a team_schedule.
     */
    data: XOR<team_scheduleUpdateInput, team_scheduleUncheckedUpdateInput>
    /**
     * Choose, which team_schedule to update.
     */
    where: team_scheduleWhereUniqueInput
  }

  /**
   * team_schedule updateMany
   */
  export type team_scheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update team_schedules.
     */
    data: XOR<team_scheduleUpdateManyMutationInput, team_scheduleUncheckedUpdateManyInput>
    /**
     * Filter which team_schedules to update
     */
    where?: team_scheduleWhereInput
  }

  /**
   * team_schedule upsert
   */
  export type team_scheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule
     */
    select?: team_scheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_scheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the team_schedule to update in case it exists.
     */
    where: team_scheduleWhereUniqueInput
    /**
     * In case the team_schedule found by the `where` argument doesn't exist, create a new team_schedule with this data.
     */
    create: XOR<team_scheduleCreateInput, team_scheduleUncheckedCreateInput>
    /**
     * In case the team_schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<team_scheduleUpdateInput, team_scheduleUncheckedUpdateInput>
  }

  /**
   * team_schedule delete
   */
  export type team_scheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule
     */
    select?: team_scheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_scheduleInclude<ExtArgs> | null
    /**
     * Filter which team_schedule to delete.
     */
    where: team_scheduleWhereUniqueInput
  }

  /**
   * team_schedule deleteMany
   */
  export type team_scheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_schedules to delete
     */
    where?: team_scheduleWhereInput
  }

  /**
   * team_schedule findRaw
   */
  export type team_scheduleFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team_schedule aggregateRaw
   */
  export type team_scheduleAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team_schedule.team_schedule_rotation
   */
  export type team_schedule$team_schedule_rotationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
    where?: team_schedule_rotationWhereInput
    orderBy?: team_schedule_rotationOrderByWithRelationInput | team_schedule_rotationOrderByWithRelationInput[]
    cursor?: team_schedule_rotationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_schedule_rotationScalarFieldEnum | Team_schedule_rotationScalarFieldEnum[]
  }

  /**
   * team_schedule.team_schedule_override
   */
  export type team_schedule$team_schedule_overrideArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_override
     */
    select?: team_schedule_overrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_overrideInclude<ExtArgs> | null
    where?: team_schedule_overrideWhereInput
    orderBy?: team_schedule_overrideOrderByWithRelationInput | team_schedule_overrideOrderByWithRelationInput[]
    cursor?: team_schedule_overrideWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Team_schedule_overrideScalarFieldEnum | Team_schedule_overrideScalarFieldEnum[]
  }

  /**
   * team_schedule without action
   */
  export type team_scheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule
     */
    select?: team_scheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_scheduleInclude<ExtArgs> | null
  }


  /**
   * Model team_schedule_rotation
   */

  export type AggregateTeam_schedule_rotation = {
    _count: Team_schedule_rotationCountAggregateOutputType | null
    _min: Team_schedule_rotationMinAggregateOutputType | null
    _max: Team_schedule_rotationMaxAggregateOutputType | null
  }

  export type Team_schedule_rotationMinAggregateOutputType = {
    id: string | null
    team_scheduleId: string | null
    name: string | null
    userId: string | null
    starts_on: Date | null
    frequency: $Enums.Frequency | null
    ends_on: Date | null
    custom_start_date_time: Date | null
    custom_end_date_time: Date | null
    restrict_time_type: $Enums.Restriction | null
    restrict_time_start: Date | null
    restrict_time_end: Date | null
  }

  export type Team_schedule_rotationMaxAggregateOutputType = {
    id: string | null
    team_scheduleId: string | null
    name: string | null
    userId: string | null
    starts_on: Date | null
    frequency: $Enums.Frequency | null
    ends_on: Date | null
    custom_start_date_time: Date | null
    custom_end_date_time: Date | null
    restrict_time_type: $Enums.Restriction | null
    restrict_time_start: Date | null
    restrict_time_end: Date | null
  }

  export type Team_schedule_rotationCountAggregateOutputType = {
    id: number
    team_scheduleId: number
    name: number
    userId: number
    starts_on: number
    frequency: number
    ends_on: number
    custom_start_date_time: number
    custom_end_date_time: number
    restrict_time_type: number
    restrict_time_start: number
    restrict_time_end: number
    _all: number
  }


  export type Team_schedule_rotationMinAggregateInputType = {
    id?: true
    team_scheduleId?: true
    name?: true
    userId?: true
    starts_on?: true
    frequency?: true
    ends_on?: true
    custom_start_date_time?: true
    custom_end_date_time?: true
    restrict_time_type?: true
    restrict_time_start?: true
    restrict_time_end?: true
  }

  export type Team_schedule_rotationMaxAggregateInputType = {
    id?: true
    team_scheduleId?: true
    name?: true
    userId?: true
    starts_on?: true
    frequency?: true
    ends_on?: true
    custom_start_date_time?: true
    custom_end_date_time?: true
    restrict_time_type?: true
    restrict_time_start?: true
    restrict_time_end?: true
  }

  export type Team_schedule_rotationCountAggregateInputType = {
    id?: true
    team_scheduleId?: true
    name?: true
    userId?: true
    starts_on?: true
    frequency?: true
    ends_on?: true
    custom_start_date_time?: true
    custom_end_date_time?: true
    restrict_time_type?: true
    restrict_time_start?: true
    restrict_time_end?: true
    _all?: true
  }

  export type Team_schedule_rotationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_schedule_rotation to aggregate.
     */
    where?: team_schedule_rotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedule_rotations to fetch.
     */
    orderBy?: team_schedule_rotationOrderByWithRelationInput | team_schedule_rotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: team_schedule_rotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedule_rotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedule_rotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned team_schedule_rotations
    **/
    _count?: true | Team_schedule_rotationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Team_schedule_rotationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Team_schedule_rotationMaxAggregateInputType
  }

  export type GetTeam_schedule_rotationAggregateType<T extends Team_schedule_rotationAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam_schedule_rotation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam_schedule_rotation[P]>
      : GetScalarType<T[P], AggregateTeam_schedule_rotation[P]>
  }




  export type team_schedule_rotationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_schedule_rotationWhereInput
    orderBy?: team_schedule_rotationOrderByWithAggregationInput | team_schedule_rotationOrderByWithAggregationInput[]
    by: Team_schedule_rotationScalarFieldEnum[] | Team_schedule_rotationScalarFieldEnum
    having?: team_schedule_rotationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Team_schedule_rotationCountAggregateInputType | true
    _min?: Team_schedule_rotationMinAggregateInputType
    _max?: Team_schedule_rotationMaxAggregateInputType
  }

  export type Team_schedule_rotationGroupByOutputType = {
    id: string
    team_scheduleId: string
    name: string
    userId: string
    starts_on: Date
    frequency: $Enums.Frequency
    ends_on: Date | null
    custom_start_date_time: Date | null
    custom_end_date_time: Date | null
    restrict_time_type: $Enums.Restriction | null
    restrict_time_start: Date | null
    restrict_time_end: Date | null
    _count: Team_schedule_rotationCountAggregateOutputType | null
    _min: Team_schedule_rotationMinAggregateOutputType | null
    _max: Team_schedule_rotationMaxAggregateOutputType | null
  }

  type GetTeam_schedule_rotationGroupByPayload<T extends team_schedule_rotationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Team_schedule_rotationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Team_schedule_rotationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Team_schedule_rotationGroupByOutputType[P]>
            : GetScalarType<T[P], Team_schedule_rotationGroupByOutputType[P]>
        }
      >
    >


  export type team_schedule_rotationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    team_scheduleId?: boolean
    name?: boolean
    userId?: boolean
    starts_on?: boolean
    frequency?: boolean
    ends_on?: boolean
    custom_start_date_time?: boolean
    custom_end_date_time?: boolean
    restrict_time_type?: boolean
    restrict_time_start?: boolean
    restrict_time_end?: boolean
    team_schedule?: boolean | team_scheduleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team_schedule_rotation"]>


  export type team_schedule_rotationSelectScalar = {
    id?: boolean
    team_scheduleId?: boolean
    name?: boolean
    userId?: boolean
    starts_on?: boolean
    frequency?: boolean
    ends_on?: boolean
    custom_start_date_time?: boolean
    custom_end_date_time?: boolean
    restrict_time_type?: boolean
    restrict_time_start?: boolean
    restrict_time_end?: boolean
  }

  export type team_schedule_rotationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team_schedule?: boolean | team_scheduleDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $team_schedule_rotationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team_schedule_rotation"
    objects: {
      team_schedule: Prisma.$team_schedulePayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      team_scheduleId: string
      name: string
      userId: string
      starts_on: Date
      frequency: $Enums.Frequency
      ends_on: Date | null
      custom_start_date_time: Date | null
      custom_end_date_time: Date | null
      restrict_time_type: $Enums.Restriction | null
      restrict_time_start: Date | null
      restrict_time_end: Date | null
    }, ExtArgs["result"]["team_schedule_rotation"]>
    composites: {}
  }

  type team_schedule_rotationGetPayload<S extends boolean | null | undefined | team_schedule_rotationDefaultArgs> = $Result.GetResult<Prisma.$team_schedule_rotationPayload, S>

  type team_schedule_rotationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<team_schedule_rotationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Team_schedule_rotationCountAggregateInputType | true
    }

  export interface team_schedule_rotationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team_schedule_rotation'], meta: { name: 'team_schedule_rotation' } }
    /**
     * Find zero or one Team_schedule_rotation that matches the filter.
     * @param {team_schedule_rotationFindUniqueArgs} args - Arguments to find a Team_schedule_rotation
     * @example
     * // Get one Team_schedule_rotation
     * const team_schedule_rotation = await prisma.team_schedule_rotation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends team_schedule_rotationFindUniqueArgs>(args: SelectSubset<T, team_schedule_rotationFindUniqueArgs<ExtArgs>>): Prisma__team_schedule_rotationClient<$Result.GetResult<Prisma.$team_schedule_rotationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team_schedule_rotation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {team_schedule_rotationFindUniqueOrThrowArgs} args - Arguments to find a Team_schedule_rotation
     * @example
     * // Get one Team_schedule_rotation
     * const team_schedule_rotation = await prisma.team_schedule_rotation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends team_schedule_rotationFindUniqueOrThrowArgs>(args: SelectSubset<T, team_schedule_rotationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__team_schedule_rotationClient<$Result.GetResult<Prisma.$team_schedule_rotationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team_schedule_rotation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_rotationFindFirstArgs} args - Arguments to find a Team_schedule_rotation
     * @example
     * // Get one Team_schedule_rotation
     * const team_schedule_rotation = await prisma.team_schedule_rotation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends team_schedule_rotationFindFirstArgs>(args?: SelectSubset<T, team_schedule_rotationFindFirstArgs<ExtArgs>>): Prisma__team_schedule_rotationClient<$Result.GetResult<Prisma.$team_schedule_rotationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team_schedule_rotation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_rotationFindFirstOrThrowArgs} args - Arguments to find a Team_schedule_rotation
     * @example
     * // Get one Team_schedule_rotation
     * const team_schedule_rotation = await prisma.team_schedule_rotation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends team_schedule_rotationFindFirstOrThrowArgs>(args?: SelectSubset<T, team_schedule_rotationFindFirstOrThrowArgs<ExtArgs>>): Prisma__team_schedule_rotationClient<$Result.GetResult<Prisma.$team_schedule_rotationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Team_schedule_rotations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_rotationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Team_schedule_rotations
     * const team_schedule_rotations = await prisma.team_schedule_rotation.findMany()
     * 
     * // Get first 10 Team_schedule_rotations
     * const team_schedule_rotations = await prisma.team_schedule_rotation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const team_schedule_rotationWithIdOnly = await prisma.team_schedule_rotation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends team_schedule_rotationFindManyArgs>(args?: SelectSubset<T, team_schedule_rotationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_schedule_rotationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team_schedule_rotation.
     * @param {team_schedule_rotationCreateArgs} args - Arguments to create a Team_schedule_rotation.
     * @example
     * // Create one Team_schedule_rotation
     * const Team_schedule_rotation = await prisma.team_schedule_rotation.create({
     *   data: {
     *     // ... data to create a Team_schedule_rotation
     *   }
     * })
     * 
     */
    create<T extends team_schedule_rotationCreateArgs>(args: SelectSubset<T, team_schedule_rotationCreateArgs<ExtArgs>>): Prisma__team_schedule_rotationClient<$Result.GetResult<Prisma.$team_schedule_rotationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Team_schedule_rotations.
     * @param {team_schedule_rotationCreateManyArgs} args - Arguments to create many Team_schedule_rotations.
     * @example
     * // Create many Team_schedule_rotations
     * const team_schedule_rotation = await prisma.team_schedule_rotation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends team_schedule_rotationCreateManyArgs>(args?: SelectSubset<T, team_schedule_rotationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team_schedule_rotation.
     * @param {team_schedule_rotationDeleteArgs} args - Arguments to delete one Team_schedule_rotation.
     * @example
     * // Delete one Team_schedule_rotation
     * const Team_schedule_rotation = await prisma.team_schedule_rotation.delete({
     *   where: {
     *     // ... filter to delete one Team_schedule_rotation
     *   }
     * })
     * 
     */
    delete<T extends team_schedule_rotationDeleteArgs>(args: SelectSubset<T, team_schedule_rotationDeleteArgs<ExtArgs>>): Prisma__team_schedule_rotationClient<$Result.GetResult<Prisma.$team_schedule_rotationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team_schedule_rotation.
     * @param {team_schedule_rotationUpdateArgs} args - Arguments to update one Team_schedule_rotation.
     * @example
     * // Update one Team_schedule_rotation
     * const team_schedule_rotation = await prisma.team_schedule_rotation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends team_schedule_rotationUpdateArgs>(args: SelectSubset<T, team_schedule_rotationUpdateArgs<ExtArgs>>): Prisma__team_schedule_rotationClient<$Result.GetResult<Prisma.$team_schedule_rotationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Team_schedule_rotations.
     * @param {team_schedule_rotationDeleteManyArgs} args - Arguments to filter Team_schedule_rotations to delete.
     * @example
     * // Delete a few Team_schedule_rotations
     * const { count } = await prisma.team_schedule_rotation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends team_schedule_rotationDeleteManyArgs>(args?: SelectSubset<T, team_schedule_rotationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Team_schedule_rotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_rotationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Team_schedule_rotations
     * const team_schedule_rotation = await prisma.team_schedule_rotation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends team_schedule_rotationUpdateManyArgs>(args: SelectSubset<T, team_schedule_rotationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team_schedule_rotation.
     * @param {team_schedule_rotationUpsertArgs} args - Arguments to update or create a Team_schedule_rotation.
     * @example
     * // Update or create a Team_schedule_rotation
     * const team_schedule_rotation = await prisma.team_schedule_rotation.upsert({
     *   create: {
     *     // ... data to create a Team_schedule_rotation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team_schedule_rotation we want to update
     *   }
     * })
     */
    upsert<T extends team_schedule_rotationUpsertArgs>(args: SelectSubset<T, team_schedule_rotationUpsertArgs<ExtArgs>>): Prisma__team_schedule_rotationClient<$Result.GetResult<Prisma.$team_schedule_rotationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Team_schedule_rotations that matches the filter.
     * @param {team_schedule_rotationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const team_schedule_rotation = await prisma.team_schedule_rotation.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: team_schedule_rotationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Team_schedule_rotation.
     * @param {team_schedule_rotationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const team_schedule_rotation = await prisma.team_schedule_rotation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: team_schedule_rotationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Team_schedule_rotations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_rotationCountArgs} args - Arguments to filter Team_schedule_rotations to count.
     * @example
     * // Count the number of Team_schedule_rotations
     * const count = await prisma.team_schedule_rotation.count({
     *   where: {
     *     // ... the filter for the Team_schedule_rotations we want to count
     *   }
     * })
    **/
    count<T extends team_schedule_rotationCountArgs>(
      args?: Subset<T, team_schedule_rotationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Team_schedule_rotationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team_schedule_rotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Team_schedule_rotationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Team_schedule_rotationAggregateArgs>(args: Subset<T, Team_schedule_rotationAggregateArgs>): Prisma.PrismaPromise<GetTeam_schedule_rotationAggregateType<T>>

    /**
     * Group by Team_schedule_rotation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_rotationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends team_schedule_rotationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: team_schedule_rotationGroupByArgs['orderBy'] }
        : { orderBy?: team_schedule_rotationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, team_schedule_rotationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeam_schedule_rotationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team_schedule_rotation model
   */
  readonly fields: team_schedule_rotationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team_schedule_rotation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__team_schedule_rotationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team_schedule<T extends team_scheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, team_scheduleDefaultArgs<ExtArgs>>): Prisma__team_scheduleClient<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the team_schedule_rotation model
   */ 
  interface team_schedule_rotationFieldRefs {
    readonly id: FieldRef<"team_schedule_rotation", 'String'>
    readonly team_scheduleId: FieldRef<"team_schedule_rotation", 'String'>
    readonly name: FieldRef<"team_schedule_rotation", 'String'>
    readonly userId: FieldRef<"team_schedule_rotation", 'String'>
    readonly starts_on: FieldRef<"team_schedule_rotation", 'DateTime'>
    readonly frequency: FieldRef<"team_schedule_rotation", 'Frequency'>
    readonly ends_on: FieldRef<"team_schedule_rotation", 'DateTime'>
    readonly custom_start_date_time: FieldRef<"team_schedule_rotation", 'DateTime'>
    readonly custom_end_date_time: FieldRef<"team_schedule_rotation", 'DateTime'>
    readonly restrict_time_type: FieldRef<"team_schedule_rotation", 'Restriction'>
    readonly restrict_time_start: FieldRef<"team_schedule_rotation", 'DateTime'>
    readonly restrict_time_end: FieldRef<"team_schedule_rotation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * team_schedule_rotation findUnique
   */
  export type team_schedule_rotationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule_rotation to fetch.
     */
    where: team_schedule_rotationWhereUniqueInput
  }

  /**
   * team_schedule_rotation findUniqueOrThrow
   */
  export type team_schedule_rotationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule_rotation to fetch.
     */
    where: team_schedule_rotationWhereUniqueInput
  }

  /**
   * team_schedule_rotation findFirst
   */
  export type team_schedule_rotationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule_rotation to fetch.
     */
    where?: team_schedule_rotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedule_rotations to fetch.
     */
    orderBy?: team_schedule_rotationOrderByWithRelationInput | team_schedule_rotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_schedule_rotations.
     */
    cursor?: team_schedule_rotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedule_rotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedule_rotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_schedule_rotations.
     */
    distinct?: Team_schedule_rotationScalarFieldEnum | Team_schedule_rotationScalarFieldEnum[]
  }

  /**
   * team_schedule_rotation findFirstOrThrow
   */
  export type team_schedule_rotationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule_rotation to fetch.
     */
    where?: team_schedule_rotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedule_rotations to fetch.
     */
    orderBy?: team_schedule_rotationOrderByWithRelationInput | team_schedule_rotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_schedule_rotations.
     */
    cursor?: team_schedule_rotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedule_rotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedule_rotations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_schedule_rotations.
     */
    distinct?: Team_schedule_rotationScalarFieldEnum | Team_schedule_rotationScalarFieldEnum[]
  }

  /**
   * team_schedule_rotation findMany
   */
  export type team_schedule_rotationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule_rotations to fetch.
     */
    where?: team_schedule_rotationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedule_rotations to fetch.
     */
    orderBy?: team_schedule_rotationOrderByWithRelationInput | team_schedule_rotationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing team_schedule_rotations.
     */
    cursor?: team_schedule_rotationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedule_rotations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedule_rotations.
     */
    skip?: number
    distinct?: Team_schedule_rotationScalarFieldEnum | Team_schedule_rotationScalarFieldEnum[]
  }

  /**
   * team_schedule_rotation create
   */
  export type team_schedule_rotationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
    /**
     * The data needed to create a team_schedule_rotation.
     */
    data: XOR<team_schedule_rotationCreateInput, team_schedule_rotationUncheckedCreateInput>
  }

  /**
   * team_schedule_rotation createMany
   */
  export type team_schedule_rotationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many team_schedule_rotations.
     */
    data: team_schedule_rotationCreateManyInput | team_schedule_rotationCreateManyInput[]
  }

  /**
   * team_schedule_rotation update
   */
  export type team_schedule_rotationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
    /**
     * The data needed to update a team_schedule_rotation.
     */
    data: XOR<team_schedule_rotationUpdateInput, team_schedule_rotationUncheckedUpdateInput>
    /**
     * Choose, which team_schedule_rotation to update.
     */
    where: team_schedule_rotationWhereUniqueInput
  }

  /**
   * team_schedule_rotation updateMany
   */
  export type team_schedule_rotationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update team_schedule_rotations.
     */
    data: XOR<team_schedule_rotationUpdateManyMutationInput, team_schedule_rotationUncheckedUpdateManyInput>
    /**
     * Filter which team_schedule_rotations to update
     */
    where?: team_schedule_rotationWhereInput
  }

  /**
   * team_schedule_rotation upsert
   */
  export type team_schedule_rotationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
    /**
     * The filter to search for the team_schedule_rotation to update in case it exists.
     */
    where: team_schedule_rotationWhereUniqueInput
    /**
     * In case the team_schedule_rotation found by the `where` argument doesn't exist, create a new team_schedule_rotation with this data.
     */
    create: XOR<team_schedule_rotationCreateInput, team_schedule_rotationUncheckedCreateInput>
    /**
     * In case the team_schedule_rotation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<team_schedule_rotationUpdateInput, team_schedule_rotationUncheckedUpdateInput>
  }

  /**
   * team_schedule_rotation delete
   */
  export type team_schedule_rotationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
    /**
     * Filter which team_schedule_rotation to delete.
     */
    where: team_schedule_rotationWhereUniqueInput
  }

  /**
   * team_schedule_rotation deleteMany
   */
  export type team_schedule_rotationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_schedule_rotations to delete
     */
    where?: team_schedule_rotationWhereInput
  }

  /**
   * team_schedule_rotation findRaw
   */
  export type team_schedule_rotationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team_schedule_rotation aggregateRaw
   */
  export type team_schedule_rotationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team_schedule_rotation without action
   */
  export type team_schedule_rotationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_rotation
     */
    select?: team_schedule_rotationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_rotationInclude<ExtArgs> | null
  }


  /**
   * Model team_schedule_override
   */

  export type AggregateTeam_schedule_override = {
    _count: Team_schedule_overrideCountAggregateOutputType | null
    _min: Team_schedule_overrideMinAggregateOutputType | null
    _max: Team_schedule_overrideMaxAggregateOutputType | null
  }

  export type Team_schedule_overrideMinAggregateOutputType = {
    id: string | null
    team_scheduleId: string | null
    name: string | null
    start_time: Date | null
    end_time: Date | null
  }

  export type Team_schedule_overrideMaxAggregateOutputType = {
    id: string | null
    team_scheduleId: string | null
    name: string | null
    start_time: Date | null
    end_time: Date | null
  }

  export type Team_schedule_overrideCountAggregateOutputType = {
    id: number
    team_scheduleId: number
    name: number
    start_time: number
    end_time: number
    _all: number
  }


  export type Team_schedule_overrideMinAggregateInputType = {
    id?: true
    team_scheduleId?: true
    name?: true
    start_time?: true
    end_time?: true
  }

  export type Team_schedule_overrideMaxAggregateInputType = {
    id?: true
    team_scheduleId?: true
    name?: true
    start_time?: true
    end_time?: true
  }

  export type Team_schedule_overrideCountAggregateInputType = {
    id?: true
    team_scheduleId?: true
    name?: true
    start_time?: true
    end_time?: true
    _all?: true
  }

  export type Team_schedule_overrideAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_schedule_override to aggregate.
     */
    where?: team_schedule_overrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedule_overrides to fetch.
     */
    orderBy?: team_schedule_overrideOrderByWithRelationInput | team_schedule_overrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: team_schedule_overrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedule_overrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedule_overrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned team_schedule_overrides
    **/
    _count?: true | Team_schedule_overrideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Team_schedule_overrideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Team_schedule_overrideMaxAggregateInputType
  }

  export type GetTeam_schedule_overrideAggregateType<T extends Team_schedule_overrideAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam_schedule_override]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam_schedule_override[P]>
      : GetScalarType<T[P], AggregateTeam_schedule_override[P]>
  }




  export type team_schedule_overrideGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: team_schedule_overrideWhereInput
    orderBy?: team_schedule_overrideOrderByWithAggregationInput | team_schedule_overrideOrderByWithAggregationInput[]
    by: Team_schedule_overrideScalarFieldEnum[] | Team_schedule_overrideScalarFieldEnum
    having?: team_schedule_overrideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Team_schedule_overrideCountAggregateInputType | true
    _min?: Team_schedule_overrideMinAggregateInputType
    _max?: Team_schedule_overrideMaxAggregateInputType
  }

  export type Team_schedule_overrideGroupByOutputType = {
    id: string
    team_scheduleId: string
    name: string
    start_time: Date
    end_time: Date | null
    _count: Team_schedule_overrideCountAggregateOutputType | null
    _min: Team_schedule_overrideMinAggregateOutputType | null
    _max: Team_schedule_overrideMaxAggregateOutputType | null
  }

  type GetTeam_schedule_overrideGroupByPayload<T extends team_schedule_overrideGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Team_schedule_overrideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Team_schedule_overrideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Team_schedule_overrideGroupByOutputType[P]>
            : GetScalarType<T[P], Team_schedule_overrideGroupByOutputType[P]>
        }
      >
    >


  export type team_schedule_overrideSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    team_scheduleId?: boolean
    name?: boolean
    start_time?: boolean
    end_time?: boolean
    team_schedule?: boolean | team_scheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team_schedule_override"]>


  export type team_schedule_overrideSelectScalar = {
    id?: boolean
    team_scheduleId?: boolean
    name?: boolean
    start_time?: boolean
    end_time?: boolean
  }

  export type team_schedule_overrideInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team_schedule?: boolean | team_scheduleDefaultArgs<ExtArgs>
  }

  export type $team_schedule_overridePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "team_schedule_override"
    objects: {
      team_schedule: Prisma.$team_schedulePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      team_scheduleId: string
      name: string
      start_time: Date
      end_time: Date | null
    }, ExtArgs["result"]["team_schedule_override"]>
    composites: {}
  }

  type team_schedule_overrideGetPayload<S extends boolean | null | undefined | team_schedule_overrideDefaultArgs> = $Result.GetResult<Prisma.$team_schedule_overridePayload, S>

  type team_schedule_overrideCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<team_schedule_overrideFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: Team_schedule_overrideCountAggregateInputType | true
    }

  export interface team_schedule_overrideDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['team_schedule_override'], meta: { name: 'team_schedule_override' } }
    /**
     * Find zero or one Team_schedule_override that matches the filter.
     * @param {team_schedule_overrideFindUniqueArgs} args - Arguments to find a Team_schedule_override
     * @example
     * // Get one Team_schedule_override
     * const team_schedule_override = await prisma.team_schedule_override.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends team_schedule_overrideFindUniqueArgs>(args: SelectSubset<T, team_schedule_overrideFindUniqueArgs<ExtArgs>>): Prisma__team_schedule_overrideClient<$Result.GetResult<Prisma.$team_schedule_overridePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team_schedule_override that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {team_schedule_overrideFindUniqueOrThrowArgs} args - Arguments to find a Team_schedule_override
     * @example
     * // Get one Team_schedule_override
     * const team_schedule_override = await prisma.team_schedule_override.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends team_schedule_overrideFindUniqueOrThrowArgs>(args: SelectSubset<T, team_schedule_overrideFindUniqueOrThrowArgs<ExtArgs>>): Prisma__team_schedule_overrideClient<$Result.GetResult<Prisma.$team_schedule_overridePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team_schedule_override that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_overrideFindFirstArgs} args - Arguments to find a Team_schedule_override
     * @example
     * // Get one Team_schedule_override
     * const team_schedule_override = await prisma.team_schedule_override.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends team_schedule_overrideFindFirstArgs>(args?: SelectSubset<T, team_schedule_overrideFindFirstArgs<ExtArgs>>): Prisma__team_schedule_overrideClient<$Result.GetResult<Prisma.$team_schedule_overridePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team_schedule_override that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_overrideFindFirstOrThrowArgs} args - Arguments to find a Team_schedule_override
     * @example
     * // Get one Team_schedule_override
     * const team_schedule_override = await prisma.team_schedule_override.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends team_schedule_overrideFindFirstOrThrowArgs>(args?: SelectSubset<T, team_schedule_overrideFindFirstOrThrowArgs<ExtArgs>>): Prisma__team_schedule_overrideClient<$Result.GetResult<Prisma.$team_schedule_overridePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Team_schedule_overrides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_overrideFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Team_schedule_overrides
     * const team_schedule_overrides = await prisma.team_schedule_override.findMany()
     * 
     * // Get first 10 Team_schedule_overrides
     * const team_schedule_overrides = await prisma.team_schedule_override.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const team_schedule_overrideWithIdOnly = await prisma.team_schedule_override.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends team_schedule_overrideFindManyArgs>(args?: SelectSubset<T, team_schedule_overrideFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$team_schedule_overridePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team_schedule_override.
     * @param {team_schedule_overrideCreateArgs} args - Arguments to create a Team_schedule_override.
     * @example
     * // Create one Team_schedule_override
     * const Team_schedule_override = await prisma.team_schedule_override.create({
     *   data: {
     *     // ... data to create a Team_schedule_override
     *   }
     * })
     * 
     */
    create<T extends team_schedule_overrideCreateArgs>(args: SelectSubset<T, team_schedule_overrideCreateArgs<ExtArgs>>): Prisma__team_schedule_overrideClient<$Result.GetResult<Prisma.$team_schedule_overridePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Team_schedule_overrides.
     * @param {team_schedule_overrideCreateManyArgs} args - Arguments to create many Team_schedule_overrides.
     * @example
     * // Create many Team_schedule_overrides
     * const team_schedule_override = await prisma.team_schedule_override.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends team_schedule_overrideCreateManyArgs>(args?: SelectSubset<T, team_schedule_overrideCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team_schedule_override.
     * @param {team_schedule_overrideDeleteArgs} args - Arguments to delete one Team_schedule_override.
     * @example
     * // Delete one Team_schedule_override
     * const Team_schedule_override = await prisma.team_schedule_override.delete({
     *   where: {
     *     // ... filter to delete one Team_schedule_override
     *   }
     * })
     * 
     */
    delete<T extends team_schedule_overrideDeleteArgs>(args: SelectSubset<T, team_schedule_overrideDeleteArgs<ExtArgs>>): Prisma__team_schedule_overrideClient<$Result.GetResult<Prisma.$team_schedule_overridePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team_schedule_override.
     * @param {team_schedule_overrideUpdateArgs} args - Arguments to update one Team_schedule_override.
     * @example
     * // Update one Team_schedule_override
     * const team_schedule_override = await prisma.team_schedule_override.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends team_schedule_overrideUpdateArgs>(args: SelectSubset<T, team_schedule_overrideUpdateArgs<ExtArgs>>): Prisma__team_schedule_overrideClient<$Result.GetResult<Prisma.$team_schedule_overridePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Team_schedule_overrides.
     * @param {team_schedule_overrideDeleteManyArgs} args - Arguments to filter Team_schedule_overrides to delete.
     * @example
     * // Delete a few Team_schedule_overrides
     * const { count } = await prisma.team_schedule_override.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends team_schedule_overrideDeleteManyArgs>(args?: SelectSubset<T, team_schedule_overrideDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Team_schedule_overrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_overrideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Team_schedule_overrides
     * const team_schedule_override = await prisma.team_schedule_override.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends team_schedule_overrideUpdateManyArgs>(args: SelectSubset<T, team_schedule_overrideUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team_schedule_override.
     * @param {team_schedule_overrideUpsertArgs} args - Arguments to update or create a Team_schedule_override.
     * @example
     * // Update or create a Team_schedule_override
     * const team_schedule_override = await prisma.team_schedule_override.upsert({
     *   create: {
     *     // ... data to create a Team_schedule_override
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team_schedule_override we want to update
     *   }
     * })
     */
    upsert<T extends team_schedule_overrideUpsertArgs>(args: SelectSubset<T, team_schedule_overrideUpsertArgs<ExtArgs>>): Prisma__team_schedule_overrideClient<$Result.GetResult<Prisma.$team_schedule_overridePayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Team_schedule_overrides that matches the filter.
     * @param {team_schedule_overrideFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const team_schedule_override = await prisma.team_schedule_override.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: team_schedule_overrideFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Team_schedule_override.
     * @param {team_schedule_overrideAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const team_schedule_override = await prisma.team_schedule_override.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: team_schedule_overrideAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Team_schedule_overrides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_overrideCountArgs} args - Arguments to filter Team_schedule_overrides to count.
     * @example
     * // Count the number of Team_schedule_overrides
     * const count = await prisma.team_schedule_override.count({
     *   where: {
     *     // ... the filter for the Team_schedule_overrides we want to count
     *   }
     * })
    **/
    count<T extends team_schedule_overrideCountArgs>(
      args?: Subset<T, team_schedule_overrideCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Team_schedule_overrideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team_schedule_override.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Team_schedule_overrideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Team_schedule_overrideAggregateArgs>(args: Subset<T, Team_schedule_overrideAggregateArgs>): Prisma.PrismaPromise<GetTeam_schedule_overrideAggregateType<T>>

    /**
     * Group by Team_schedule_override.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {team_schedule_overrideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends team_schedule_overrideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: team_schedule_overrideGroupByArgs['orderBy'] }
        : { orderBy?: team_schedule_overrideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, team_schedule_overrideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeam_schedule_overrideGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the team_schedule_override model
   */
  readonly fields: team_schedule_overrideFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for team_schedule_override.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__team_schedule_overrideClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team_schedule<T extends team_scheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, team_scheduleDefaultArgs<ExtArgs>>): Prisma__team_scheduleClient<$Result.GetResult<Prisma.$team_schedulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the team_schedule_override model
   */ 
  interface team_schedule_overrideFieldRefs {
    readonly id: FieldRef<"team_schedule_override", 'String'>
    readonly team_scheduleId: FieldRef<"team_schedule_override", 'String'>
    readonly name: FieldRef<"team_schedule_override", 'String'>
    readonly start_time: FieldRef<"team_schedule_override", 'DateTime'>
    readonly end_time: FieldRef<"team_schedule_override", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * team_schedule_override findUnique
   */
  export type team_schedule_overrideFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_override
     */
    select?: team_schedule_overrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_overrideInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule_override to fetch.
     */
    where: team_schedule_overrideWhereUniqueInput
  }

  /**
   * team_schedule_override findUniqueOrThrow
   */
  export type team_schedule_overrideFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_override
     */
    select?: team_schedule_overrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_overrideInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule_override to fetch.
     */
    where: team_schedule_overrideWhereUniqueInput
  }

  /**
   * team_schedule_override findFirst
   */
  export type team_schedule_overrideFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_override
     */
    select?: team_schedule_overrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_overrideInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule_override to fetch.
     */
    where?: team_schedule_overrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedule_overrides to fetch.
     */
    orderBy?: team_schedule_overrideOrderByWithRelationInput | team_schedule_overrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_schedule_overrides.
     */
    cursor?: team_schedule_overrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedule_overrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedule_overrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_schedule_overrides.
     */
    distinct?: Team_schedule_overrideScalarFieldEnum | Team_schedule_overrideScalarFieldEnum[]
  }

  /**
   * team_schedule_override findFirstOrThrow
   */
  export type team_schedule_overrideFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_override
     */
    select?: team_schedule_overrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_overrideInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule_override to fetch.
     */
    where?: team_schedule_overrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedule_overrides to fetch.
     */
    orderBy?: team_schedule_overrideOrderByWithRelationInput | team_schedule_overrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for team_schedule_overrides.
     */
    cursor?: team_schedule_overrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedule_overrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedule_overrides.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of team_schedule_overrides.
     */
    distinct?: Team_schedule_overrideScalarFieldEnum | Team_schedule_overrideScalarFieldEnum[]
  }

  /**
   * team_schedule_override findMany
   */
  export type team_schedule_overrideFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_override
     */
    select?: team_schedule_overrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_overrideInclude<ExtArgs> | null
    /**
     * Filter, which team_schedule_overrides to fetch.
     */
    where?: team_schedule_overrideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of team_schedule_overrides to fetch.
     */
    orderBy?: team_schedule_overrideOrderByWithRelationInput | team_schedule_overrideOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing team_schedule_overrides.
     */
    cursor?: team_schedule_overrideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` team_schedule_overrides from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` team_schedule_overrides.
     */
    skip?: number
    distinct?: Team_schedule_overrideScalarFieldEnum | Team_schedule_overrideScalarFieldEnum[]
  }

  /**
   * team_schedule_override create
   */
  export type team_schedule_overrideCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_override
     */
    select?: team_schedule_overrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_overrideInclude<ExtArgs> | null
    /**
     * The data needed to create a team_schedule_override.
     */
    data: XOR<team_schedule_overrideCreateInput, team_schedule_overrideUncheckedCreateInput>
  }

  /**
   * team_schedule_override createMany
   */
  export type team_schedule_overrideCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many team_schedule_overrides.
     */
    data: team_schedule_overrideCreateManyInput | team_schedule_overrideCreateManyInput[]
  }

  /**
   * team_schedule_override update
   */
  export type team_schedule_overrideUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_override
     */
    select?: team_schedule_overrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_overrideInclude<ExtArgs> | null
    /**
     * The data needed to update a team_schedule_override.
     */
    data: XOR<team_schedule_overrideUpdateInput, team_schedule_overrideUncheckedUpdateInput>
    /**
     * Choose, which team_schedule_override to update.
     */
    where: team_schedule_overrideWhereUniqueInput
  }

  /**
   * team_schedule_override updateMany
   */
  export type team_schedule_overrideUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update team_schedule_overrides.
     */
    data: XOR<team_schedule_overrideUpdateManyMutationInput, team_schedule_overrideUncheckedUpdateManyInput>
    /**
     * Filter which team_schedule_overrides to update
     */
    where?: team_schedule_overrideWhereInput
  }

  /**
   * team_schedule_override upsert
   */
  export type team_schedule_overrideUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_override
     */
    select?: team_schedule_overrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_overrideInclude<ExtArgs> | null
    /**
     * The filter to search for the team_schedule_override to update in case it exists.
     */
    where: team_schedule_overrideWhereUniqueInput
    /**
     * In case the team_schedule_override found by the `where` argument doesn't exist, create a new team_schedule_override with this data.
     */
    create: XOR<team_schedule_overrideCreateInput, team_schedule_overrideUncheckedCreateInput>
    /**
     * In case the team_schedule_override was found with the provided `where` argument, update it with this data.
     */
    update: XOR<team_schedule_overrideUpdateInput, team_schedule_overrideUncheckedUpdateInput>
  }

  /**
   * team_schedule_override delete
   */
  export type team_schedule_overrideDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_override
     */
    select?: team_schedule_overrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_overrideInclude<ExtArgs> | null
    /**
     * Filter which team_schedule_override to delete.
     */
    where: team_schedule_overrideWhereUniqueInput
  }

  /**
   * team_schedule_override deleteMany
   */
  export type team_schedule_overrideDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which team_schedule_overrides to delete
     */
    where?: team_schedule_overrideWhereInput
  }

  /**
   * team_schedule_override findRaw
   */
  export type team_schedule_overrideFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team_schedule_override aggregateRaw
   */
  export type team_schedule_overrideAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * team_schedule_override without action
   */
  export type team_schedule_overrideDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the team_schedule_override
     */
    select?: team_schedule_overrideSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: team_schedule_overrideInclude<ExtArgs> | null
  }


  /**
   * Model contactUs
   */

  export type AggregateContactUs = {
    _count: ContactUsCountAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  export type ContactUsMinAggregateOutputType = {
    id: string | null
    name: string | null
    phoneNumber: string | null
    email: string | null
    createdAt: Date | null
  }

  export type ContactUsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    phoneNumber: string | null
    email: string | null
    createdAt: Date | null
  }

  export type ContactUsCountAggregateOutputType = {
    id: number
    name: number
    phoneNumber: number
    email: number
    createdAt: number
    _all: number
  }


  export type ContactUsMinAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
  }

  export type ContactUsMaxAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
  }

  export type ContactUsCountAggregateInputType = {
    id?: true
    name?: true
    phoneNumber?: true
    email?: true
    createdAt?: true
    _all?: true
  }

  export type ContactUsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contactUs to aggregate.
     */
    where?: contactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactuses to fetch.
     */
    orderBy?: contactUsOrderByWithRelationInput | contactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: contactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned contactuses
    **/
    _count?: true | ContactUsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContactUsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContactUsMaxAggregateInputType
  }

  export type GetContactUsAggregateType<T extends ContactUsAggregateArgs> = {
        [P in keyof T & keyof AggregateContactUs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContactUs[P]>
      : GetScalarType<T[P], AggregateContactUs[P]>
  }




  export type contactUsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: contactUsWhereInput
    orderBy?: contactUsOrderByWithAggregationInput | contactUsOrderByWithAggregationInput[]
    by: ContactUsScalarFieldEnum[] | ContactUsScalarFieldEnum
    having?: contactUsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContactUsCountAggregateInputType | true
    _min?: ContactUsMinAggregateInputType
    _max?: ContactUsMaxAggregateInputType
  }

  export type ContactUsGroupByOutputType = {
    id: string
    name: string | null
    phoneNumber: string
    email: string
    createdAt: Date
    _count: ContactUsCountAggregateOutputType | null
    _min: ContactUsMinAggregateOutputType | null
    _max: ContactUsMaxAggregateOutputType | null
  }

  type GetContactUsGroupByPayload<T extends contactUsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContactUsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContactUsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
            : GetScalarType<T[P], ContactUsGroupByOutputType[P]>
        }
      >
    >


  export type contactUsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    email?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["contactUs"]>


  export type contactUsSelectScalar = {
    id?: boolean
    name?: boolean
    phoneNumber?: boolean
    email?: boolean
    createdAt?: boolean
  }


  export type $contactUsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "contactUs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      phoneNumber: string
      email: string
      createdAt: Date
    }, ExtArgs["result"]["contactUs"]>
    composites: {}
  }

  type contactUsGetPayload<S extends boolean | null | undefined | contactUsDefaultArgs> = $Result.GetResult<Prisma.$contactUsPayload, S>

  type contactUsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<contactUsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ContactUsCountAggregateInputType | true
    }

  export interface contactUsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['contactUs'], meta: { name: 'contactUs' } }
    /**
     * Find zero or one ContactUs that matches the filter.
     * @param {contactUsFindUniqueArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends contactUsFindUniqueArgs>(args: SelectSubset<T, contactUsFindUniqueArgs<ExtArgs>>): Prisma__contactUsClient<$Result.GetResult<Prisma.$contactUsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ContactUs that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {contactUsFindUniqueOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends contactUsFindUniqueOrThrowArgs>(args: SelectSubset<T, contactUsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__contactUsClient<$Result.GetResult<Prisma.$contactUsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ContactUs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactUsFindFirstArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends contactUsFindFirstArgs>(args?: SelectSubset<T, contactUsFindFirstArgs<ExtArgs>>): Prisma__contactUsClient<$Result.GetResult<Prisma.$contactUsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ContactUs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactUsFindFirstOrThrowArgs} args - Arguments to find a ContactUs
     * @example
     * // Get one ContactUs
     * const contactUs = await prisma.contactUs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends contactUsFindFirstOrThrowArgs>(args?: SelectSubset<T, contactUsFindFirstOrThrowArgs<ExtArgs>>): Prisma__contactUsClient<$Result.GetResult<Prisma.$contactUsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Contactuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactUsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contactuses
     * const contactuses = await prisma.contactUs.findMany()
     * 
     * // Get first 10 Contactuses
     * const contactuses = await prisma.contactUs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contactUsWithIdOnly = await prisma.contactUs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends contactUsFindManyArgs>(args?: SelectSubset<T, contactUsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$contactUsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ContactUs.
     * @param {contactUsCreateArgs} args - Arguments to create a ContactUs.
     * @example
     * // Create one ContactUs
     * const ContactUs = await prisma.contactUs.create({
     *   data: {
     *     // ... data to create a ContactUs
     *   }
     * })
     * 
     */
    create<T extends contactUsCreateArgs>(args: SelectSubset<T, contactUsCreateArgs<ExtArgs>>): Prisma__contactUsClient<$Result.GetResult<Prisma.$contactUsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Contactuses.
     * @param {contactUsCreateManyArgs} args - Arguments to create many Contactuses.
     * @example
     * // Create many Contactuses
     * const contactUs = await prisma.contactUs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends contactUsCreateManyArgs>(args?: SelectSubset<T, contactUsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ContactUs.
     * @param {contactUsDeleteArgs} args - Arguments to delete one ContactUs.
     * @example
     * // Delete one ContactUs
     * const ContactUs = await prisma.contactUs.delete({
     *   where: {
     *     // ... filter to delete one ContactUs
     *   }
     * })
     * 
     */
    delete<T extends contactUsDeleteArgs>(args: SelectSubset<T, contactUsDeleteArgs<ExtArgs>>): Prisma__contactUsClient<$Result.GetResult<Prisma.$contactUsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ContactUs.
     * @param {contactUsUpdateArgs} args - Arguments to update one ContactUs.
     * @example
     * // Update one ContactUs
     * const contactUs = await prisma.contactUs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends contactUsUpdateArgs>(args: SelectSubset<T, contactUsUpdateArgs<ExtArgs>>): Prisma__contactUsClient<$Result.GetResult<Prisma.$contactUsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Contactuses.
     * @param {contactUsDeleteManyArgs} args - Arguments to filter Contactuses to delete.
     * @example
     * // Delete a few Contactuses
     * const { count } = await prisma.contactUs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends contactUsDeleteManyArgs>(args?: SelectSubset<T, contactUsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactUsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contactuses
     * const contactUs = await prisma.contactUs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends contactUsUpdateManyArgs>(args: SelectSubset<T, contactUsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ContactUs.
     * @param {contactUsUpsertArgs} args - Arguments to update or create a ContactUs.
     * @example
     * // Update or create a ContactUs
     * const contactUs = await prisma.contactUs.upsert({
     *   create: {
     *     // ... data to create a ContactUs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContactUs we want to update
     *   }
     * })
     */
    upsert<T extends contactUsUpsertArgs>(args: SelectSubset<T, contactUsUpsertArgs<ExtArgs>>): Prisma__contactUsClient<$Result.GetResult<Prisma.$contactUsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>

    /**
     * Find zero or more Contactuses that matches the filter.
     * @param {contactUsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const contactUs = await prisma.contactUs.findRaw({
     *   filter: { age: { $gt: 25 } } 
     * })
     */
    findRaw(args?: contactUsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ContactUs.
     * @param {contactUsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const contactUs = await prisma.contactUs.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: contactUsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Contactuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactUsCountArgs} args - Arguments to filter Contactuses to count.
     * @example
     * // Count the number of Contactuses
     * const count = await prisma.contactUs.count({
     *   where: {
     *     // ... the filter for the Contactuses we want to count
     *   }
     * })
    **/
    count<T extends contactUsCountArgs>(
      args?: Subset<T, contactUsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContactUsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContactUsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContactUsAggregateArgs>(args: Subset<T, ContactUsAggregateArgs>): Prisma.PrismaPromise<GetContactUsAggregateType<T>>

    /**
     * Group by ContactUs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {contactUsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends contactUsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: contactUsGroupByArgs['orderBy'] }
        : { orderBy?: contactUsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, contactUsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContactUsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the contactUs model
   */
  readonly fields: contactUsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for contactUs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__contactUsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the contactUs model
   */ 
  interface contactUsFieldRefs {
    readonly id: FieldRef<"contactUs", 'String'>
    readonly name: FieldRef<"contactUs", 'String'>
    readonly phoneNumber: FieldRef<"contactUs", 'String'>
    readonly email: FieldRef<"contactUs", 'String'>
    readonly createdAt: FieldRef<"contactUs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * contactUs findUnique
   */
  export type contactUsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactUs
     */
    select?: contactUsSelect<ExtArgs> | null
    /**
     * Filter, which contactUs to fetch.
     */
    where: contactUsWhereUniqueInput
  }

  /**
   * contactUs findUniqueOrThrow
   */
  export type contactUsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactUs
     */
    select?: contactUsSelect<ExtArgs> | null
    /**
     * Filter, which contactUs to fetch.
     */
    where: contactUsWhereUniqueInput
  }

  /**
   * contactUs findFirst
   */
  export type contactUsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactUs
     */
    select?: contactUsSelect<ExtArgs> | null
    /**
     * Filter, which contactUs to fetch.
     */
    where?: contactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactuses to fetch.
     */
    orderBy?: contactUsOrderByWithRelationInput | contactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contactuses.
     */
    cursor?: contactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * contactUs findFirstOrThrow
   */
  export type contactUsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactUs
     */
    select?: contactUsSelect<ExtArgs> | null
    /**
     * Filter, which contactUs to fetch.
     */
    where?: contactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactuses to fetch.
     */
    orderBy?: contactUsOrderByWithRelationInput | contactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for contactuses.
     */
    cursor?: contactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of contactuses.
     */
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * contactUs findMany
   */
  export type contactUsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactUs
     */
    select?: contactUsSelect<ExtArgs> | null
    /**
     * Filter, which contactuses to fetch.
     */
    where?: contactUsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of contactuses to fetch.
     */
    orderBy?: contactUsOrderByWithRelationInput | contactUsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing contactuses.
     */
    cursor?: contactUsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` contactuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` contactuses.
     */
    skip?: number
    distinct?: ContactUsScalarFieldEnum | ContactUsScalarFieldEnum[]
  }

  /**
   * contactUs create
   */
  export type contactUsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactUs
     */
    select?: contactUsSelect<ExtArgs> | null
    /**
     * The data needed to create a contactUs.
     */
    data: XOR<contactUsCreateInput, contactUsUncheckedCreateInput>
  }

  /**
   * contactUs createMany
   */
  export type contactUsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many contactuses.
     */
    data: contactUsCreateManyInput | contactUsCreateManyInput[]
  }

  /**
   * contactUs update
   */
  export type contactUsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactUs
     */
    select?: contactUsSelect<ExtArgs> | null
    /**
     * The data needed to update a contactUs.
     */
    data: XOR<contactUsUpdateInput, contactUsUncheckedUpdateInput>
    /**
     * Choose, which contactUs to update.
     */
    where: contactUsWhereUniqueInput
  }

  /**
   * contactUs updateMany
   */
  export type contactUsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update contactuses.
     */
    data: XOR<contactUsUpdateManyMutationInput, contactUsUncheckedUpdateManyInput>
    /**
     * Filter which contactuses to update
     */
    where?: contactUsWhereInput
  }

  /**
   * contactUs upsert
   */
  export type contactUsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactUs
     */
    select?: contactUsSelect<ExtArgs> | null
    /**
     * The filter to search for the contactUs to update in case it exists.
     */
    where: contactUsWhereUniqueInput
    /**
     * In case the contactUs found by the `where` argument doesn't exist, create a new contactUs with this data.
     */
    create: XOR<contactUsCreateInput, contactUsUncheckedCreateInput>
    /**
     * In case the contactUs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<contactUsUpdateInput, contactUsUncheckedUpdateInput>
  }

  /**
   * contactUs delete
   */
  export type contactUsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactUs
     */
    select?: contactUsSelect<ExtArgs> | null
    /**
     * Filter which contactUs to delete.
     */
    where: contactUsWhereUniqueInput
  }

  /**
   * contactUs deleteMany
   */
  export type contactUsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which contactuses to delete
     */
    where?: contactUsWhereInput
  }

  /**
   * contactUs findRaw
   */
  export type contactUsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * contactUs aggregateRaw
   */
  export type contactUsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * contactUs without action
   */
  export type contactUsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the contactUs
     */
    select?: contactUsSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UserScalarFieldEnum: {
    id: 'id',
    supaId: 'supaId',
    name: 'name',
    email: 'email',
    number: 'number',
    photo: 'photo',
    is_phone_number_verified: 'is_phone_number_verified'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const User_otpScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    otp: 'otp',
    invalid: 'invalid',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt'
  };

  export type User_otpScalarFieldEnum = (typeof User_otpScalarFieldEnum)[keyof typeof User_otpScalarFieldEnum]


  export const Monitor_configScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    monitorType: 'monitorType',
    is_active: 'is_active',
    workspaceId: 'workspaceId',
    teamId: 'teamId',
    createdAt: 'createdAt'
  };

  export type Monitor_configScalarFieldEnum = (typeof Monitor_configScalarFieldEnum)[keyof typeof Monitor_configScalarFieldEnum]


  export const Monitor_HTTP_gPRC_configScalarFieldEnum: {
    id: 'id',
    monitor_configId: 'monitor_configId',
    authType: 'authType',
    interval_check: 'interval_check',
    userName: 'userName',
    password: 'password',
    inital_token: 'inital_token',
    refresh_token: 'refresh_token',
    header_key: 'header_key',
    header_value: 'header_value',
    endpoint_url: 'endpoint_url',
    failure_count: 'failure_count',
    success_count: 'success_count',
    success_response_code: 'success_response_code'
  };

  export type Monitor_HTTP_gPRC_configScalarFieldEnum = (typeof Monitor_HTTP_gPRC_configScalarFieldEnum)[keyof typeof Monitor_HTTP_gPRC_configScalarFieldEnum]


  export const Monitor_SSL_configScalarFieldEnum: {
    id: 'id',
    monitor_configId: 'monitor_configId',
    endpoint_url: 'endpoint_url',
    alt_names: 'alt_names',
    is_wildcard: 'is_wildcard',
    wildcard_url: 'wildcard_url',
    certifcate_issue: 'certifcate_issue',
    certificate_tenure: 'certificate_tenure',
    expiry_reminder: 'expiry_reminder'
  };

  export type Monitor_SSL_configScalarFieldEnum = (typeof Monitor_SSL_configScalarFieldEnum)[keyof typeof Monitor_SSL_configScalarFieldEnum]


  export const Monitor_System_componentsScalarFieldEnum: {
    id: 'id',
    monitor_configId: 'monitor_configId',
    components_lists: 'components_lists',
    is_cloud: 'is_cloud',
    cloud_service_url: 'cloud_service_url',
    cloud_userName: 'cloud_userName',
    cloud_password: 'cloud_password',
    cloud_downloadUrl: 'cloud_downloadUrl'
  };

  export type Monitor_System_componentsScalarFieldEnum = (typeof Monitor_System_componentsScalarFieldEnum)[keyof typeof Monitor_System_componentsScalarFieldEnum]


  export const WorkSpaceScalarFieldEnum: {
    id: 'id',
    ownerId: 'ownerId',
    workspace_name: 'workspace_name',
    trial_startDate: 'trial_startDate',
    trial_endDate: 'trial_endDate',
    subscription_start: 'subscription_start',
    subscription_end: 'subscription_end'
  };

  export type WorkSpaceScalarFieldEnum = (typeof WorkSpaceScalarFieldEnum)[keyof typeof WorkSpaceScalarFieldEnum]


  export const Invited_usersScalarFieldEnum: {
    id: 'id',
    invited_user_name: 'invited_user_name',
    invited_user_email_id: 'invited_user_email_id',
    invited_by: 'invited_by',
    workspaceId: 'workspaceId',
    role: 'role',
    status: 'status',
    invited_on: 'invited_on'
  };

  export type Invited_usersScalarFieldEnum = (typeof Invited_usersScalarFieldEnum)[keyof typeof Invited_usersScalarFieldEnum]


  export const WorkSpace_usersScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    workspaceId: 'workspaceId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type WorkSpace_usersScalarFieldEnum = (typeof WorkSpace_usersScalarFieldEnum)[keyof typeof WorkSpace_usersScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    creatorId: 'creatorId',
    workspaceId: 'workspaceId',
    teamName: 'teamName',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const Team_memberScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    workspace_userId: 'workspace_userId',
    workspaceId: 'workspaceId'
  };

  export type Team_memberScalarFieldEnum = (typeof Team_memberScalarFieldEnum)[keyof typeof Team_memberScalarFieldEnum]


  export const AlertScalarFieldEnum: {
    id: 'id',
    acknowledged: 'acknowledged',
    monitor_configId: 'monitor_configId',
    userId: 'userId',
    workspaceId: 'workspaceId',
    createdAt: 'createdAt'
  };

  export type AlertScalarFieldEnum = (typeof AlertScalarFieldEnum)[keyof typeof AlertScalarFieldEnum]


  export const Team_escalationpolicyScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    escalationplicy_name: 'escalationplicy_name',
    isActive: 'isActive',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type Team_escalationpolicyScalarFieldEnum = (typeof Team_escalationpolicyScalarFieldEnum)[keyof typeof Team_escalationpolicyScalarFieldEnum]


  export const Escalation_policy_rulesScalarFieldEnum: {
    id: 'id',
    team_escalationpolicyId: 'team_escalationpolicyId',
    alert_status: 'alert_status',
    minutes_after_creation: 'minutes_after_creation',
    notification_type: 'notification_type',
    userId: 'userId',
    scheudleId: 'scheudleId',
    teamId: 'teamId',
    is_active: 'is_active'
  };

  export type Escalation_policy_rulesScalarFieldEnum = (typeof Escalation_policy_rulesScalarFieldEnum)[keyof typeof Escalation_policy_rulesScalarFieldEnum]


  export const Team_scheduleScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type Team_scheduleScalarFieldEnum = (typeof Team_scheduleScalarFieldEnum)[keyof typeof Team_scheduleScalarFieldEnum]


  export const Team_schedule_rotationScalarFieldEnum: {
    id: 'id',
    team_scheduleId: 'team_scheduleId',
    name: 'name',
    userId: 'userId',
    starts_on: 'starts_on',
    frequency: 'frequency',
    ends_on: 'ends_on',
    custom_start_date_time: 'custom_start_date_time',
    custom_end_date_time: 'custom_end_date_time',
    restrict_time_type: 'restrict_time_type',
    restrict_time_start: 'restrict_time_start',
    restrict_time_end: 'restrict_time_end'
  };

  export type Team_schedule_rotationScalarFieldEnum = (typeof Team_schedule_rotationScalarFieldEnum)[keyof typeof Team_schedule_rotationScalarFieldEnum]


  export const Team_schedule_overrideScalarFieldEnum: {
    id: 'id',
    team_scheduleId: 'team_scheduleId',
    name: 'name',
    start_time: 'start_time',
    end_time: 'end_time'
  };

  export type Team_schedule_overrideScalarFieldEnum = (typeof Team_schedule_overrideScalarFieldEnum)[keyof typeof Team_schedule_overrideScalarFieldEnum]


  export const ContactUsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    phoneNumber: 'phoneNumber',
    email: 'email',
    createdAt: 'createdAt'
  };

  export type ContactUsScalarFieldEnum = (typeof ContactUsScalarFieldEnum)[keyof typeof ContactUsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'status'
   */
  export type EnumstatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'status'>
    


  /**
   * Reference to a field of type 'status[]'
   */
  export type ListEnumstatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'status[]'>
    


  /**
   * Reference to a field of type 'notification_type'
   */
  export type Enumnotification_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'notification_type'>
    


  /**
   * Reference to a field of type 'notification_type[]'
   */
  export type ListEnumnotification_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'notification_type[]'>
    


  /**
   * Reference to a field of type 'Frequency'
   */
  export type EnumFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Frequency'>
    


  /**
   * Reference to a field of type 'Frequency[]'
   */
  export type ListEnumFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Frequency[]'>
    


  /**
   * Reference to a field of type 'Restriction'
   */
  export type EnumRestrictionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Restriction'>
    


  /**
   * Reference to a field of type 'Restriction[]'
   */
  export type ListEnumRestrictionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Restriction[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    supaId?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    number?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    is_phone_number_verified?: BoolFilter<"User"> | boolean
    Monitor_config?: Monitor_configListRelationFilter
    workspace?: WorkSpaceListRelationFilter
    workspace_users?: WorkSpace_usersListRelationFilter
    teams?: TeamListRelationFilter
    alert?: AlertListRelationFilter
    escalation_policy_rules?: Escalation_policy_rulesListRelationFilter
    user_otp?: User_otpListRelationFilter
    team_schedule_rotation?: Team_schedule_rotationListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    supaId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    number?: SortOrder
    photo?: SortOrder
    is_phone_number_verified?: SortOrder
    Monitor_config?: Monitor_configOrderByRelationAggregateInput
    workspace?: WorkSpaceOrderByRelationAggregateInput
    workspace_users?: WorkSpace_usersOrderByRelationAggregateInput
    teams?: teamOrderByRelationAggregateInput
    alert?: alertOrderByRelationAggregateInput
    escalation_policy_rules?: escalation_policy_rulesOrderByRelationAggregateInput
    user_otp?: user_otpOrderByRelationAggregateInput
    team_schedule_rotation?: team_schedule_rotationOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    supaId?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringFilter<"User"> | string
    number?: StringNullableFilter<"User"> | string | null
    photo?: StringNullableFilter<"User"> | string | null
    is_phone_number_verified?: BoolFilter<"User"> | boolean
    Monitor_config?: Monitor_configListRelationFilter
    workspace?: WorkSpaceListRelationFilter
    workspace_users?: WorkSpace_usersListRelationFilter
    teams?: TeamListRelationFilter
    alert?: AlertListRelationFilter
    escalation_policy_rules?: Escalation_policy_rulesListRelationFilter
    user_otp?: User_otpListRelationFilter
    team_schedule_rotation?: Team_schedule_rotationListRelationFilter
  }, "id" | "supaId" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    supaId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    number?: SortOrder
    photo?: SortOrder
    is_phone_number_verified?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    supaId?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    number?: StringNullableWithAggregatesFilter<"User"> | string | null
    photo?: StringNullableWithAggregatesFilter<"User"> | string | null
    is_phone_number_verified?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type user_otpWhereInput = {
    AND?: user_otpWhereInput | user_otpWhereInput[]
    OR?: user_otpWhereInput[]
    NOT?: user_otpWhereInput | user_otpWhereInput[]
    id?: StringFilter<"user_otp"> | string
    userId?: StringFilter<"user_otp"> | string
    otp?: StringFilter<"user_otp"> | string
    invalid?: BoolFilter<"user_otp"> | boolean
    expiresAt?: IntFilter<"user_otp"> | number
    createdAt?: DateTimeFilter<"user_otp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type user_otpOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    invalid?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type user_otpWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: user_otpWhereInput | user_otpWhereInput[]
    OR?: user_otpWhereInput[]
    NOT?: user_otpWhereInput | user_otpWhereInput[]
    userId?: StringFilter<"user_otp"> | string
    otp?: StringFilter<"user_otp"> | string
    invalid?: BoolFilter<"user_otp"> | boolean
    expiresAt?: IntFilter<"user_otp"> | number
    createdAt?: DateTimeFilter<"user_otp"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type user_otpOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    invalid?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    _count?: user_otpCountOrderByAggregateInput
    _avg?: user_otpAvgOrderByAggregateInput
    _max?: user_otpMaxOrderByAggregateInput
    _min?: user_otpMinOrderByAggregateInput
    _sum?: user_otpSumOrderByAggregateInput
  }

  export type user_otpScalarWhereWithAggregatesInput = {
    AND?: user_otpScalarWhereWithAggregatesInput | user_otpScalarWhereWithAggregatesInput[]
    OR?: user_otpScalarWhereWithAggregatesInput[]
    NOT?: user_otpScalarWhereWithAggregatesInput | user_otpScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"user_otp"> | string
    userId?: StringWithAggregatesFilter<"user_otp"> | string
    otp?: StringWithAggregatesFilter<"user_otp"> | string
    invalid?: BoolWithAggregatesFilter<"user_otp"> | boolean
    expiresAt?: IntWithAggregatesFilter<"user_otp"> | number
    createdAt?: DateTimeWithAggregatesFilter<"user_otp"> | Date | string
  }

  export type Monitor_configWhereInput = {
    AND?: Monitor_configWhereInput | Monitor_configWhereInput[]
    OR?: Monitor_configWhereInput[]
    NOT?: Monitor_configWhereInput | Monitor_configWhereInput[]
    id?: StringFilter<"Monitor_config"> | string
    userId?: StringFilter<"Monitor_config"> | string
    name?: StringNullableFilter<"Monitor_config"> | string | null
    monitorType?: StringFilter<"Monitor_config"> | string
    is_active?: BoolFilter<"Monitor_config"> | boolean
    workspaceId?: StringNullableFilter<"Monitor_config"> | string | null
    teamId?: StringNullableFilter<"Monitor_config"> | string | null
    createdAt?: DateTimeFilter<"Monitor_config"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkSpaceNullableScalarRelationFilter, WorkSpaceWhereInput> | null
    Monitor_HTTP_gPRC_config?: XOR<Monitor_HTTP_gPRC_configNullableScalarRelationFilter, Monitor_HTTP_gPRC_configWhereInput> | null
    Monitor_SSL_config?: XOR<Monitor_SSL_configNullableScalarRelationFilter, Monitor_SSL_configWhereInput> | null
    Monitor_System_components?: XOR<Monitor_System_componentsNullableScalarRelationFilter, Monitor_System_componentsWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    alert?: AlertListRelationFilter
  }

  export type Monitor_configOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    monitorType?: SortOrder
    is_active?: SortOrder
    workspaceId?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkSpaceOrderByWithRelationInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configOrderByWithRelationInput
    Monitor_SSL_config?: Monitor_SSL_configOrderByWithRelationInput
    Monitor_System_components?: Monitor_System_componentsOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
    alert?: alertOrderByRelationAggregateInput
  }

  export type Monitor_configWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Monitor_configWhereInput | Monitor_configWhereInput[]
    OR?: Monitor_configWhereInput[]
    NOT?: Monitor_configWhereInput | Monitor_configWhereInput[]
    userId?: StringFilter<"Monitor_config"> | string
    name?: StringNullableFilter<"Monitor_config"> | string | null
    monitorType?: StringFilter<"Monitor_config"> | string
    is_active?: BoolFilter<"Monitor_config"> | boolean
    workspaceId?: StringNullableFilter<"Monitor_config"> | string | null
    teamId?: StringNullableFilter<"Monitor_config"> | string | null
    createdAt?: DateTimeFilter<"Monitor_config"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkSpaceNullableScalarRelationFilter, WorkSpaceWhereInput> | null
    Monitor_HTTP_gPRC_config?: XOR<Monitor_HTTP_gPRC_configNullableScalarRelationFilter, Monitor_HTTP_gPRC_configWhereInput> | null
    Monitor_SSL_config?: XOR<Monitor_SSL_configNullableScalarRelationFilter, Monitor_SSL_configWhereInput> | null
    Monitor_System_components?: XOR<Monitor_System_componentsNullableScalarRelationFilter, Monitor_System_componentsWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
    alert?: AlertListRelationFilter
  }, "id">

  export type Monitor_configOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    monitorType?: SortOrder
    is_active?: SortOrder
    workspaceId?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
    _count?: Monitor_configCountOrderByAggregateInput
    _max?: Monitor_configMaxOrderByAggregateInput
    _min?: Monitor_configMinOrderByAggregateInput
  }

  export type Monitor_configScalarWhereWithAggregatesInput = {
    AND?: Monitor_configScalarWhereWithAggregatesInput | Monitor_configScalarWhereWithAggregatesInput[]
    OR?: Monitor_configScalarWhereWithAggregatesInput[]
    NOT?: Monitor_configScalarWhereWithAggregatesInput | Monitor_configScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Monitor_config"> | string
    userId?: StringWithAggregatesFilter<"Monitor_config"> | string
    name?: StringNullableWithAggregatesFilter<"Monitor_config"> | string | null
    monitorType?: StringWithAggregatesFilter<"Monitor_config"> | string
    is_active?: BoolWithAggregatesFilter<"Monitor_config"> | boolean
    workspaceId?: StringNullableWithAggregatesFilter<"Monitor_config"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"Monitor_config"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Monitor_config"> | Date | string
  }

  export type Monitor_HTTP_gPRC_configWhereInput = {
    AND?: Monitor_HTTP_gPRC_configWhereInput | Monitor_HTTP_gPRC_configWhereInput[]
    OR?: Monitor_HTTP_gPRC_configWhereInput[]
    NOT?: Monitor_HTTP_gPRC_configWhereInput | Monitor_HTTP_gPRC_configWhereInput[]
    id?: StringFilter<"Monitor_HTTP_gPRC_config"> | string
    monitor_configId?: StringFilter<"Monitor_HTTP_gPRC_config"> | string
    authType?: StringFilter<"Monitor_HTTP_gPRC_config"> | string
    interval_check?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    userName?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    password?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    inital_token?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    refresh_token?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    header_key?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    header_value?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    endpoint_url?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    failure_count?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    success_count?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    success_response_code?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    monitor_config?: XOR<Monitor_configScalarRelationFilter, Monitor_configWhereInput>
  }

  export type Monitor_HTTP_gPRC_configOrderByWithRelationInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    authType?: SortOrder
    interval_check?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    inital_token?: SortOrder
    refresh_token?: SortOrder
    header_key?: SortOrder
    header_value?: SortOrder
    endpoint_url?: SortOrder
    failure_count?: SortOrder
    success_count?: SortOrder
    success_response_code?: SortOrder
    monitor_config?: Monitor_configOrderByWithRelationInput
  }

  export type Monitor_HTTP_gPRC_configWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    monitor_configId?: string
    AND?: Monitor_HTTP_gPRC_configWhereInput | Monitor_HTTP_gPRC_configWhereInput[]
    OR?: Monitor_HTTP_gPRC_configWhereInput[]
    NOT?: Monitor_HTTP_gPRC_configWhereInput | Monitor_HTTP_gPRC_configWhereInput[]
    authType?: StringFilter<"Monitor_HTTP_gPRC_config"> | string
    interval_check?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    userName?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    password?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    inital_token?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    refresh_token?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    header_key?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    header_value?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    endpoint_url?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    failure_count?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    success_count?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    success_response_code?: StringNullableFilter<"Monitor_HTTP_gPRC_config"> | string | null
    monitor_config?: XOR<Monitor_configScalarRelationFilter, Monitor_configWhereInput>
  }, "id" | "monitor_configId">

  export type Monitor_HTTP_gPRC_configOrderByWithAggregationInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    authType?: SortOrder
    interval_check?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    inital_token?: SortOrder
    refresh_token?: SortOrder
    header_key?: SortOrder
    header_value?: SortOrder
    endpoint_url?: SortOrder
    failure_count?: SortOrder
    success_count?: SortOrder
    success_response_code?: SortOrder
    _count?: Monitor_HTTP_gPRC_configCountOrderByAggregateInput
    _max?: Monitor_HTTP_gPRC_configMaxOrderByAggregateInput
    _min?: Monitor_HTTP_gPRC_configMinOrderByAggregateInput
  }

  export type Monitor_HTTP_gPRC_configScalarWhereWithAggregatesInput = {
    AND?: Monitor_HTTP_gPRC_configScalarWhereWithAggregatesInput | Monitor_HTTP_gPRC_configScalarWhereWithAggregatesInput[]
    OR?: Monitor_HTTP_gPRC_configScalarWhereWithAggregatesInput[]
    NOT?: Monitor_HTTP_gPRC_configScalarWhereWithAggregatesInput | Monitor_HTTP_gPRC_configScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string
    monitor_configId?: StringWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string
    authType?: StringWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string
    interval_check?: StringNullableWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string | null
    userName?: StringNullableWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string | null
    password?: StringNullableWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string | null
    inital_token?: StringNullableWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string | null
    refresh_token?: StringNullableWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string | null
    header_key?: StringNullableWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string | null
    header_value?: StringNullableWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string | null
    endpoint_url?: StringNullableWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string | null
    failure_count?: StringNullableWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string | null
    success_count?: StringNullableWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string | null
    success_response_code?: StringNullableWithAggregatesFilter<"Monitor_HTTP_gPRC_config"> | string | null
  }

  export type Monitor_SSL_configWhereInput = {
    AND?: Monitor_SSL_configWhereInput | Monitor_SSL_configWhereInput[]
    OR?: Monitor_SSL_configWhereInput[]
    NOT?: Monitor_SSL_configWhereInput | Monitor_SSL_configWhereInput[]
    id?: StringFilter<"Monitor_SSL_config"> | string
    monitor_configId?: StringFilter<"Monitor_SSL_config"> | string
    endpoint_url?: StringNullableFilter<"Monitor_SSL_config"> | string | null
    alt_names?: StringNullableFilter<"Monitor_SSL_config"> | string | null
    is_wildcard?: BoolFilter<"Monitor_SSL_config"> | boolean
    wildcard_url?: StringNullableFilter<"Monitor_SSL_config"> | string | null
    certifcate_issue?: DateTimeNullableFilter<"Monitor_SSL_config"> | Date | string | null
    certificate_tenure?: StringNullableFilter<"Monitor_SSL_config"> | string | null
    expiry_reminder?: StringNullableFilter<"Monitor_SSL_config"> | string | null
    monitor_config?: XOR<Monitor_configScalarRelationFilter, Monitor_configWhereInput>
  }

  export type Monitor_SSL_configOrderByWithRelationInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    endpoint_url?: SortOrder
    alt_names?: SortOrder
    is_wildcard?: SortOrder
    wildcard_url?: SortOrder
    certifcate_issue?: SortOrder
    certificate_tenure?: SortOrder
    expiry_reminder?: SortOrder
    monitor_config?: Monitor_configOrderByWithRelationInput
  }

  export type Monitor_SSL_configWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    monitor_configId?: string
    AND?: Monitor_SSL_configWhereInput | Monitor_SSL_configWhereInput[]
    OR?: Monitor_SSL_configWhereInput[]
    NOT?: Monitor_SSL_configWhereInput | Monitor_SSL_configWhereInput[]
    endpoint_url?: StringNullableFilter<"Monitor_SSL_config"> | string | null
    alt_names?: StringNullableFilter<"Monitor_SSL_config"> | string | null
    is_wildcard?: BoolFilter<"Monitor_SSL_config"> | boolean
    wildcard_url?: StringNullableFilter<"Monitor_SSL_config"> | string | null
    certifcate_issue?: DateTimeNullableFilter<"Monitor_SSL_config"> | Date | string | null
    certificate_tenure?: StringNullableFilter<"Monitor_SSL_config"> | string | null
    expiry_reminder?: StringNullableFilter<"Monitor_SSL_config"> | string | null
    monitor_config?: XOR<Monitor_configScalarRelationFilter, Monitor_configWhereInput>
  }, "id" | "monitor_configId">

  export type Monitor_SSL_configOrderByWithAggregationInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    endpoint_url?: SortOrder
    alt_names?: SortOrder
    is_wildcard?: SortOrder
    wildcard_url?: SortOrder
    certifcate_issue?: SortOrder
    certificate_tenure?: SortOrder
    expiry_reminder?: SortOrder
    _count?: Monitor_SSL_configCountOrderByAggregateInput
    _max?: Monitor_SSL_configMaxOrderByAggregateInput
    _min?: Monitor_SSL_configMinOrderByAggregateInput
  }

  export type Monitor_SSL_configScalarWhereWithAggregatesInput = {
    AND?: Monitor_SSL_configScalarWhereWithAggregatesInput | Monitor_SSL_configScalarWhereWithAggregatesInput[]
    OR?: Monitor_SSL_configScalarWhereWithAggregatesInput[]
    NOT?: Monitor_SSL_configScalarWhereWithAggregatesInput | Monitor_SSL_configScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Monitor_SSL_config"> | string
    monitor_configId?: StringWithAggregatesFilter<"Monitor_SSL_config"> | string
    endpoint_url?: StringNullableWithAggregatesFilter<"Monitor_SSL_config"> | string | null
    alt_names?: StringNullableWithAggregatesFilter<"Monitor_SSL_config"> | string | null
    is_wildcard?: BoolWithAggregatesFilter<"Monitor_SSL_config"> | boolean
    wildcard_url?: StringNullableWithAggregatesFilter<"Monitor_SSL_config"> | string | null
    certifcate_issue?: DateTimeNullableWithAggregatesFilter<"Monitor_SSL_config"> | Date | string | null
    certificate_tenure?: StringNullableWithAggregatesFilter<"Monitor_SSL_config"> | string | null
    expiry_reminder?: StringNullableWithAggregatesFilter<"Monitor_SSL_config"> | string | null
  }

  export type Monitor_System_componentsWhereInput = {
    AND?: Monitor_System_componentsWhereInput | Monitor_System_componentsWhereInput[]
    OR?: Monitor_System_componentsWhereInput[]
    NOT?: Monitor_System_componentsWhereInput | Monitor_System_componentsWhereInput[]
    id?: StringFilter<"Monitor_System_components"> | string
    monitor_configId?: StringFilter<"Monitor_System_components"> | string
    components_lists?: StringNullableListFilter<"Monitor_System_components">
    is_cloud?: BoolFilter<"Monitor_System_components"> | boolean
    cloud_service_url?: StringNullableFilter<"Monitor_System_components"> | string | null
    cloud_userName?: StringNullableFilter<"Monitor_System_components"> | string | null
    cloud_password?: StringNullableFilter<"Monitor_System_components"> | string | null
    cloud_downloadUrl?: StringNullableFilter<"Monitor_System_components"> | string | null
    monitor_config?: XOR<Monitor_configScalarRelationFilter, Monitor_configWhereInput>
  }

  export type Monitor_System_componentsOrderByWithRelationInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    components_lists?: SortOrder
    is_cloud?: SortOrder
    cloud_service_url?: SortOrder
    cloud_userName?: SortOrder
    cloud_password?: SortOrder
    cloud_downloadUrl?: SortOrder
    monitor_config?: Monitor_configOrderByWithRelationInput
  }

  export type Monitor_System_componentsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    monitor_configId?: string
    AND?: Monitor_System_componentsWhereInput | Monitor_System_componentsWhereInput[]
    OR?: Monitor_System_componentsWhereInput[]
    NOT?: Monitor_System_componentsWhereInput | Monitor_System_componentsWhereInput[]
    components_lists?: StringNullableListFilter<"Monitor_System_components">
    is_cloud?: BoolFilter<"Monitor_System_components"> | boolean
    cloud_service_url?: StringNullableFilter<"Monitor_System_components"> | string | null
    cloud_userName?: StringNullableFilter<"Monitor_System_components"> | string | null
    cloud_password?: StringNullableFilter<"Monitor_System_components"> | string | null
    cloud_downloadUrl?: StringNullableFilter<"Monitor_System_components"> | string | null
    monitor_config?: XOR<Monitor_configScalarRelationFilter, Monitor_configWhereInput>
  }, "id" | "monitor_configId">

  export type Monitor_System_componentsOrderByWithAggregationInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    components_lists?: SortOrder
    is_cloud?: SortOrder
    cloud_service_url?: SortOrder
    cloud_userName?: SortOrder
    cloud_password?: SortOrder
    cloud_downloadUrl?: SortOrder
    _count?: Monitor_System_componentsCountOrderByAggregateInput
    _max?: Monitor_System_componentsMaxOrderByAggregateInput
    _min?: Monitor_System_componentsMinOrderByAggregateInput
  }

  export type Monitor_System_componentsScalarWhereWithAggregatesInput = {
    AND?: Monitor_System_componentsScalarWhereWithAggregatesInput | Monitor_System_componentsScalarWhereWithAggregatesInput[]
    OR?: Monitor_System_componentsScalarWhereWithAggregatesInput[]
    NOT?: Monitor_System_componentsScalarWhereWithAggregatesInput | Monitor_System_componentsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Monitor_System_components"> | string
    monitor_configId?: StringWithAggregatesFilter<"Monitor_System_components"> | string
    components_lists?: StringNullableListFilter<"Monitor_System_components">
    is_cloud?: BoolWithAggregatesFilter<"Monitor_System_components"> | boolean
    cloud_service_url?: StringNullableWithAggregatesFilter<"Monitor_System_components"> | string | null
    cloud_userName?: StringNullableWithAggregatesFilter<"Monitor_System_components"> | string | null
    cloud_password?: StringNullableWithAggregatesFilter<"Monitor_System_components"> | string | null
    cloud_downloadUrl?: StringNullableWithAggregatesFilter<"Monitor_System_components"> | string | null
  }

  export type WorkSpaceWhereInput = {
    AND?: WorkSpaceWhereInput | WorkSpaceWhereInput[]
    OR?: WorkSpaceWhereInput[]
    NOT?: WorkSpaceWhereInput | WorkSpaceWhereInput[]
    id?: StringFilter<"WorkSpace"> | string
    ownerId?: StringFilter<"WorkSpace"> | string
    workspace_name?: StringFilter<"WorkSpace"> | string
    trial_startDate?: DateTimeFilter<"WorkSpace"> | Date | string
    trial_endDate?: DateTimeFilter<"WorkSpace"> | Date | string
    subscription_start?: DateTimeNullableFilter<"WorkSpace"> | Date | string | null
    subscription_end?: DateTimeNullableFilter<"WorkSpace"> | Date | string | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    monitor_config?: Monitor_configListRelationFilter
    workspace_users?: WorkSpace_usersListRelationFilter
    invited_users?: Invited_usersListRelationFilter
    team?: TeamListRelationFilter
    team_member?: Team_memberListRelationFilter
    alert?: AlertListRelationFilter
  }

  export type WorkSpaceOrderByWithRelationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    workspace_name?: SortOrder
    trial_startDate?: SortOrder
    trial_endDate?: SortOrder
    subscription_start?: SortOrder
    subscription_end?: SortOrder
    owner?: UserOrderByWithRelationInput
    monitor_config?: Monitor_configOrderByRelationAggregateInput
    workspace_users?: WorkSpace_usersOrderByRelationAggregateInput
    invited_users?: invited_usersOrderByRelationAggregateInput
    team?: teamOrderByRelationAggregateInput
    team_member?: team_memberOrderByRelationAggregateInput
    alert?: alertOrderByRelationAggregateInput
  }

  export type WorkSpaceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    workspace_name?: string
    AND?: WorkSpaceWhereInput | WorkSpaceWhereInput[]
    OR?: WorkSpaceWhereInput[]
    NOT?: WorkSpaceWhereInput | WorkSpaceWhereInput[]
    ownerId?: StringFilter<"WorkSpace"> | string
    trial_startDate?: DateTimeFilter<"WorkSpace"> | Date | string
    trial_endDate?: DateTimeFilter<"WorkSpace"> | Date | string
    subscription_start?: DateTimeNullableFilter<"WorkSpace"> | Date | string | null
    subscription_end?: DateTimeNullableFilter<"WorkSpace"> | Date | string | null
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    monitor_config?: Monitor_configListRelationFilter
    workspace_users?: WorkSpace_usersListRelationFilter
    invited_users?: Invited_usersListRelationFilter
    team?: TeamListRelationFilter
    team_member?: Team_memberListRelationFilter
    alert?: AlertListRelationFilter
  }, "id" | "workspace_name">

  export type WorkSpaceOrderByWithAggregationInput = {
    id?: SortOrder
    ownerId?: SortOrder
    workspace_name?: SortOrder
    trial_startDate?: SortOrder
    trial_endDate?: SortOrder
    subscription_start?: SortOrder
    subscription_end?: SortOrder
    _count?: WorkSpaceCountOrderByAggregateInput
    _max?: WorkSpaceMaxOrderByAggregateInput
    _min?: WorkSpaceMinOrderByAggregateInput
  }

  export type WorkSpaceScalarWhereWithAggregatesInput = {
    AND?: WorkSpaceScalarWhereWithAggregatesInput | WorkSpaceScalarWhereWithAggregatesInput[]
    OR?: WorkSpaceScalarWhereWithAggregatesInput[]
    NOT?: WorkSpaceScalarWhereWithAggregatesInput | WorkSpaceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkSpace"> | string
    ownerId?: StringWithAggregatesFilter<"WorkSpace"> | string
    workspace_name?: StringWithAggregatesFilter<"WorkSpace"> | string
    trial_startDate?: DateTimeWithAggregatesFilter<"WorkSpace"> | Date | string
    trial_endDate?: DateTimeWithAggregatesFilter<"WorkSpace"> | Date | string
    subscription_start?: DateTimeNullableWithAggregatesFilter<"WorkSpace"> | Date | string | null
    subscription_end?: DateTimeNullableWithAggregatesFilter<"WorkSpace"> | Date | string | null
  }

  export type invited_usersWhereInput = {
    AND?: invited_usersWhereInput | invited_usersWhereInput[]
    OR?: invited_usersWhereInput[]
    NOT?: invited_usersWhereInput | invited_usersWhereInput[]
    id?: StringFilter<"invited_users"> | string
    invited_user_name?: StringFilter<"invited_users"> | string
    invited_user_email_id?: StringFilter<"invited_users"> | string
    invited_by?: StringFilter<"invited_users"> | string
    workspaceId?: StringFilter<"invited_users"> | string
    role?: EnumRoleFilter<"invited_users"> | $Enums.Role
    status?: EnumstatusFilter<"invited_users"> | $Enums.status
    invited_on?: DateTimeFilter<"invited_users"> | Date | string
    wokspace?: XOR<WorkSpaceScalarRelationFilter, WorkSpaceWhereInput>
  }

  export type invited_usersOrderByWithRelationInput = {
    id?: SortOrder
    invited_user_name?: SortOrder
    invited_user_email_id?: SortOrder
    invited_by?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invited_on?: SortOrder
    wokspace?: WorkSpaceOrderByWithRelationInput
  }

  export type invited_usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: invited_usersWhereInput | invited_usersWhereInput[]
    OR?: invited_usersWhereInput[]
    NOT?: invited_usersWhereInput | invited_usersWhereInput[]
    invited_user_name?: StringFilter<"invited_users"> | string
    invited_user_email_id?: StringFilter<"invited_users"> | string
    invited_by?: StringFilter<"invited_users"> | string
    workspaceId?: StringFilter<"invited_users"> | string
    role?: EnumRoleFilter<"invited_users"> | $Enums.Role
    status?: EnumstatusFilter<"invited_users"> | $Enums.status
    invited_on?: DateTimeFilter<"invited_users"> | Date | string
    wokspace?: XOR<WorkSpaceScalarRelationFilter, WorkSpaceWhereInput>
  }, "id">

  export type invited_usersOrderByWithAggregationInput = {
    id?: SortOrder
    invited_user_name?: SortOrder
    invited_user_email_id?: SortOrder
    invited_by?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invited_on?: SortOrder
    _count?: invited_usersCountOrderByAggregateInput
    _max?: invited_usersMaxOrderByAggregateInput
    _min?: invited_usersMinOrderByAggregateInput
  }

  export type invited_usersScalarWhereWithAggregatesInput = {
    AND?: invited_usersScalarWhereWithAggregatesInput | invited_usersScalarWhereWithAggregatesInput[]
    OR?: invited_usersScalarWhereWithAggregatesInput[]
    NOT?: invited_usersScalarWhereWithAggregatesInput | invited_usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"invited_users"> | string
    invited_user_name?: StringWithAggregatesFilter<"invited_users"> | string
    invited_user_email_id?: StringWithAggregatesFilter<"invited_users"> | string
    invited_by?: StringWithAggregatesFilter<"invited_users"> | string
    workspaceId?: StringWithAggregatesFilter<"invited_users"> | string
    role?: EnumRoleWithAggregatesFilter<"invited_users"> | $Enums.Role
    status?: EnumstatusWithAggregatesFilter<"invited_users"> | $Enums.status
    invited_on?: DateTimeWithAggregatesFilter<"invited_users"> | Date | string
  }

  export type WorkSpace_usersWhereInput = {
    AND?: WorkSpace_usersWhereInput | WorkSpace_usersWhereInput[]
    OR?: WorkSpace_usersWhereInput[]
    NOT?: WorkSpace_usersWhereInput | WorkSpace_usersWhereInput[]
    id?: StringFilter<"WorkSpace_users"> | string
    userId?: StringFilter<"WorkSpace_users"> | string
    workspaceId?: StringFilter<"WorkSpace_users"> | string
    role?: EnumRoleFilter<"WorkSpace_users"> | $Enums.Role
    createdAt?: DateTimeFilter<"WorkSpace_users"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkSpaceScalarRelationFilter, WorkSpaceWhereInput>
    team_member?: Team_memberListRelationFilter
  }

  export type WorkSpace_usersOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    workspace?: WorkSpaceOrderByWithRelationInput
    team_member?: team_memberOrderByRelationAggregateInput
  }

  export type WorkSpace_usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: WorkSpace_usersWhereInput | WorkSpace_usersWhereInput[]
    OR?: WorkSpace_usersWhereInput[]
    NOT?: WorkSpace_usersWhereInput | WorkSpace_usersWhereInput[]
    userId?: StringFilter<"WorkSpace_users"> | string
    workspaceId?: StringFilter<"WorkSpace_users"> | string
    role?: EnumRoleFilter<"WorkSpace_users"> | $Enums.Role
    createdAt?: DateTimeFilter<"WorkSpace_users"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkSpaceScalarRelationFilter, WorkSpaceWhereInput>
    team_member?: Team_memberListRelationFilter
  }, "id">

  export type WorkSpace_usersOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: WorkSpace_usersCountOrderByAggregateInput
    _max?: WorkSpace_usersMaxOrderByAggregateInput
    _min?: WorkSpace_usersMinOrderByAggregateInput
  }

  export type WorkSpace_usersScalarWhereWithAggregatesInput = {
    AND?: WorkSpace_usersScalarWhereWithAggregatesInput | WorkSpace_usersScalarWhereWithAggregatesInput[]
    OR?: WorkSpace_usersScalarWhereWithAggregatesInput[]
    NOT?: WorkSpace_usersScalarWhereWithAggregatesInput | WorkSpace_usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"WorkSpace_users"> | string
    userId?: StringWithAggregatesFilter<"WorkSpace_users"> | string
    workspaceId?: StringWithAggregatesFilter<"WorkSpace_users"> | string
    role?: EnumRoleWithAggregatesFilter<"WorkSpace_users"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"WorkSpace_users"> | Date | string
  }

  export type teamWhereInput = {
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    id?: StringFilter<"team"> | string
    creatorId?: StringFilter<"team"> | string
    workspaceId?: StringFilter<"team"> | string
    teamName?: StringFilter<"team"> | string
    description?: StringNullableFilter<"team"> | string | null
    createdAt?: DateTimeFilter<"team"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkSpaceScalarRelationFilter, WorkSpaceWhereInput>
    team_member?: Team_memberListRelationFilter
    monitor_config?: Monitor_configListRelationFilter
    team_escalationpolicy?: Team_escalationpolicyListRelationFilter
    escalation_policy_rules?: Escalation_policy_rulesListRelationFilter
    team_schedule?: Team_scheduleListRelationFilter
  }

  export type teamOrderByWithRelationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    workspaceId?: SortOrder
    teamName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    workspace?: WorkSpaceOrderByWithRelationInput
    team_member?: team_memberOrderByRelationAggregateInput
    monitor_config?: Monitor_configOrderByRelationAggregateInput
    team_escalationpolicy?: team_escalationpolicyOrderByRelationAggregateInput
    escalation_policy_rules?: escalation_policy_rulesOrderByRelationAggregateInput
    team_schedule?: team_scheduleOrderByRelationAggregateInput
  }

  export type teamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: teamWhereInput | teamWhereInput[]
    OR?: teamWhereInput[]
    NOT?: teamWhereInput | teamWhereInput[]
    creatorId?: StringFilter<"team"> | string
    workspaceId?: StringFilter<"team"> | string
    teamName?: StringFilter<"team"> | string
    description?: StringNullableFilter<"team"> | string | null
    createdAt?: DateTimeFilter<"team"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    workspace?: XOR<WorkSpaceScalarRelationFilter, WorkSpaceWhereInput>
    team_member?: Team_memberListRelationFilter
    monitor_config?: Monitor_configListRelationFilter
    team_escalationpolicy?: Team_escalationpolicyListRelationFilter
    escalation_policy_rules?: Escalation_policy_rulesListRelationFilter
    team_schedule?: Team_scheduleListRelationFilter
  }, "id">

  export type teamOrderByWithAggregationInput = {
    id?: SortOrder
    creatorId?: SortOrder
    workspaceId?: SortOrder
    teamName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: teamCountOrderByAggregateInput
    _max?: teamMaxOrderByAggregateInput
    _min?: teamMinOrderByAggregateInput
  }

  export type teamScalarWhereWithAggregatesInput = {
    AND?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    OR?: teamScalarWhereWithAggregatesInput[]
    NOT?: teamScalarWhereWithAggregatesInput | teamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"team"> | string
    creatorId?: StringWithAggregatesFilter<"team"> | string
    workspaceId?: StringWithAggregatesFilter<"team"> | string
    teamName?: StringWithAggregatesFilter<"team"> | string
    description?: StringNullableWithAggregatesFilter<"team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"team"> | Date | string
  }

  export type team_memberWhereInput = {
    AND?: team_memberWhereInput | team_memberWhereInput[]
    OR?: team_memberWhereInput[]
    NOT?: team_memberWhereInput | team_memberWhereInput[]
    id?: StringFilter<"team_member"> | string
    teamId?: StringFilter<"team_member"> | string
    workspace_userId?: StringFilter<"team_member"> | string
    workspaceId?: StringFilter<"team_member"> | string
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
    workspace_user?: XOR<WorkSpace_usersScalarRelationFilter, WorkSpace_usersWhereInput>
    workspace?: XOR<WorkSpaceScalarRelationFilter, WorkSpaceWhereInput>
  }

  export type team_memberOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    workspace_userId?: SortOrder
    workspaceId?: SortOrder
    team?: teamOrderByWithRelationInput
    workspace_user?: WorkSpace_usersOrderByWithRelationInput
    workspace?: WorkSpaceOrderByWithRelationInput
  }

  export type team_memberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: team_memberWhereInput | team_memberWhereInput[]
    OR?: team_memberWhereInput[]
    NOT?: team_memberWhereInput | team_memberWhereInput[]
    teamId?: StringFilter<"team_member"> | string
    workspace_userId?: StringFilter<"team_member"> | string
    workspaceId?: StringFilter<"team_member"> | string
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
    workspace_user?: XOR<WorkSpace_usersScalarRelationFilter, WorkSpace_usersWhereInput>
    workspace?: XOR<WorkSpaceScalarRelationFilter, WorkSpaceWhereInput>
  }, "id">

  export type team_memberOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    workspace_userId?: SortOrder
    workspaceId?: SortOrder
    _count?: team_memberCountOrderByAggregateInput
    _max?: team_memberMaxOrderByAggregateInput
    _min?: team_memberMinOrderByAggregateInput
  }

  export type team_memberScalarWhereWithAggregatesInput = {
    AND?: team_memberScalarWhereWithAggregatesInput | team_memberScalarWhereWithAggregatesInput[]
    OR?: team_memberScalarWhereWithAggregatesInput[]
    NOT?: team_memberScalarWhereWithAggregatesInput | team_memberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"team_member"> | string
    teamId?: StringWithAggregatesFilter<"team_member"> | string
    workspace_userId?: StringWithAggregatesFilter<"team_member"> | string
    workspaceId?: StringWithAggregatesFilter<"team_member"> | string
  }

  export type alertWhereInput = {
    AND?: alertWhereInput | alertWhereInput[]
    OR?: alertWhereInput[]
    NOT?: alertWhereInput | alertWhereInput[]
    id?: StringFilter<"alert"> | string
    acknowledged?: BoolFilter<"alert"> | boolean
    monitor_configId?: StringFilter<"alert"> | string
    userId?: StringNullableFilter<"alert"> | string | null
    workspaceId?: StringFilter<"alert"> | string
    createdAt?: DateTimeFilter<"alert"> | Date | string
    monitor_config?: XOR<Monitor_configScalarRelationFilter, Monitor_configWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    workspace?: XOR<WorkSpaceScalarRelationFilter, WorkSpaceWhereInput>
  }

  export type alertOrderByWithRelationInput = {
    id?: SortOrder
    acknowledged?: SortOrder
    monitor_configId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    monitor_config?: Monitor_configOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    workspace?: WorkSpaceOrderByWithRelationInput
  }

  export type alertWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: alertWhereInput | alertWhereInput[]
    OR?: alertWhereInput[]
    NOT?: alertWhereInput | alertWhereInput[]
    acknowledged?: BoolFilter<"alert"> | boolean
    monitor_configId?: StringFilter<"alert"> | string
    userId?: StringNullableFilter<"alert"> | string | null
    workspaceId?: StringFilter<"alert"> | string
    createdAt?: DateTimeFilter<"alert"> | Date | string
    monitor_config?: XOR<Monitor_configScalarRelationFilter, Monitor_configWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    workspace?: XOR<WorkSpaceScalarRelationFilter, WorkSpaceWhereInput>
  }, "id">

  export type alertOrderByWithAggregationInput = {
    id?: SortOrder
    acknowledged?: SortOrder
    monitor_configId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
    _count?: alertCountOrderByAggregateInput
    _max?: alertMaxOrderByAggregateInput
    _min?: alertMinOrderByAggregateInput
  }

  export type alertScalarWhereWithAggregatesInput = {
    AND?: alertScalarWhereWithAggregatesInput | alertScalarWhereWithAggregatesInput[]
    OR?: alertScalarWhereWithAggregatesInput[]
    NOT?: alertScalarWhereWithAggregatesInput | alertScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"alert"> | string
    acknowledged?: BoolWithAggregatesFilter<"alert"> | boolean
    monitor_configId?: StringWithAggregatesFilter<"alert"> | string
    userId?: StringNullableWithAggregatesFilter<"alert"> | string | null
    workspaceId?: StringWithAggregatesFilter<"alert"> | string
    createdAt?: DateTimeWithAggregatesFilter<"alert"> | Date | string
  }

  export type team_escalationpolicyWhereInput = {
    AND?: team_escalationpolicyWhereInput | team_escalationpolicyWhereInput[]
    OR?: team_escalationpolicyWhereInput[]
    NOT?: team_escalationpolicyWhereInput | team_escalationpolicyWhereInput[]
    id?: StringFilter<"team_escalationpolicy"> | string
    teamId?: StringFilter<"team_escalationpolicy"> | string
    escalationplicy_name?: StringFilter<"team_escalationpolicy"> | string
    isActive?: BoolFilter<"team_escalationpolicy"> | boolean
    description?: StringNullableFilter<"team_escalationpolicy"> | string | null
    createdAt?: DateTimeFilter<"team_escalationpolicy"> | Date | string
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
    escalation_policy_rules?: Escalation_policy_rulesListRelationFilter
  }

  export type team_escalationpolicyOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    escalationplicy_name?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    team?: teamOrderByWithRelationInput
    escalation_policy_rules?: escalation_policy_rulesOrderByRelationAggregateInput
  }

  export type team_escalationpolicyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: team_escalationpolicyWhereInput | team_escalationpolicyWhereInput[]
    OR?: team_escalationpolicyWhereInput[]
    NOT?: team_escalationpolicyWhereInput | team_escalationpolicyWhereInput[]
    teamId?: StringFilter<"team_escalationpolicy"> | string
    escalationplicy_name?: StringFilter<"team_escalationpolicy"> | string
    isActive?: BoolFilter<"team_escalationpolicy"> | boolean
    description?: StringNullableFilter<"team_escalationpolicy"> | string | null
    createdAt?: DateTimeFilter<"team_escalationpolicy"> | Date | string
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
    escalation_policy_rules?: Escalation_policy_rulesListRelationFilter
  }, "id">

  export type team_escalationpolicyOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    escalationplicy_name?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: team_escalationpolicyCountOrderByAggregateInput
    _max?: team_escalationpolicyMaxOrderByAggregateInput
    _min?: team_escalationpolicyMinOrderByAggregateInput
  }

  export type team_escalationpolicyScalarWhereWithAggregatesInput = {
    AND?: team_escalationpolicyScalarWhereWithAggregatesInput | team_escalationpolicyScalarWhereWithAggregatesInput[]
    OR?: team_escalationpolicyScalarWhereWithAggregatesInput[]
    NOT?: team_escalationpolicyScalarWhereWithAggregatesInput | team_escalationpolicyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"team_escalationpolicy"> | string
    teamId?: StringWithAggregatesFilter<"team_escalationpolicy"> | string
    escalationplicy_name?: StringWithAggregatesFilter<"team_escalationpolicy"> | string
    isActive?: BoolWithAggregatesFilter<"team_escalationpolicy"> | boolean
    description?: StringNullableWithAggregatesFilter<"team_escalationpolicy"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"team_escalationpolicy"> | Date | string
  }

  export type escalation_policy_rulesWhereInput = {
    AND?: escalation_policy_rulesWhereInput | escalation_policy_rulesWhereInput[]
    OR?: escalation_policy_rulesWhereInput[]
    NOT?: escalation_policy_rulesWhereInput | escalation_policy_rulesWhereInput[]
    id?: StringFilter<"escalation_policy_rules"> | string
    team_escalationpolicyId?: StringFilter<"escalation_policy_rules"> | string
    alert_status?: StringFilter<"escalation_policy_rules"> | string
    minutes_after_creation?: IntFilter<"escalation_policy_rules"> | number
    notification_type?: Enumnotification_typeFilter<"escalation_policy_rules"> | $Enums.notification_type
    userId?: StringNullableFilter<"escalation_policy_rules"> | string | null
    scheudleId?: StringNullableFilter<"escalation_policy_rules"> | string | null
    teamId?: StringNullableFilter<"escalation_policy_rules"> | string | null
    is_active?: BoolFilter<"escalation_policy_rules"> | boolean
    team_escalation_policy?: XOR<Team_escalationpolicyScalarRelationFilter, team_escalationpolicyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
  }

  export type escalation_policy_rulesOrderByWithRelationInput = {
    id?: SortOrder
    team_escalationpolicyId?: SortOrder
    alert_status?: SortOrder
    minutes_after_creation?: SortOrder
    notification_type?: SortOrder
    userId?: SortOrder
    scheudleId?: SortOrder
    teamId?: SortOrder
    is_active?: SortOrder
    team_escalation_policy?: team_escalationpolicyOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    team?: teamOrderByWithRelationInput
  }

  export type escalation_policy_rulesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: escalation_policy_rulesWhereInput | escalation_policy_rulesWhereInput[]
    OR?: escalation_policy_rulesWhereInput[]
    NOT?: escalation_policy_rulesWhereInput | escalation_policy_rulesWhereInput[]
    team_escalationpolicyId?: StringFilter<"escalation_policy_rules"> | string
    alert_status?: StringFilter<"escalation_policy_rules"> | string
    minutes_after_creation?: IntFilter<"escalation_policy_rules"> | number
    notification_type?: Enumnotification_typeFilter<"escalation_policy_rules"> | $Enums.notification_type
    userId?: StringNullableFilter<"escalation_policy_rules"> | string | null
    scheudleId?: StringNullableFilter<"escalation_policy_rules"> | string | null
    teamId?: StringNullableFilter<"escalation_policy_rules"> | string | null
    is_active?: BoolFilter<"escalation_policy_rules"> | boolean
    team_escalation_policy?: XOR<Team_escalationpolicyScalarRelationFilter, team_escalationpolicyWhereInput>
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    team?: XOR<TeamNullableScalarRelationFilter, teamWhereInput> | null
  }, "id">

  export type escalation_policy_rulesOrderByWithAggregationInput = {
    id?: SortOrder
    team_escalationpolicyId?: SortOrder
    alert_status?: SortOrder
    minutes_after_creation?: SortOrder
    notification_type?: SortOrder
    userId?: SortOrder
    scheudleId?: SortOrder
    teamId?: SortOrder
    is_active?: SortOrder
    _count?: escalation_policy_rulesCountOrderByAggregateInput
    _avg?: escalation_policy_rulesAvgOrderByAggregateInput
    _max?: escalation_policy_rulesMaxOrderByAggregateInput
    _min?: escalation_policy_rulesMinOrderByAggregateInput
    _sum?: escalation_policy_rulesSumOrderByAggregateInput
  }

  export type escalation_policy_rulesScalarWhereWithAggregatesInput = {
    AND?: escalation_policy_rulesScalarWhereWithAggregatesInput | escalation_policy_rulesScalarWhereWithAggregatesInput[]
    OR?: escalation_policy_rulesScalarWhereWithAggregatesInput[]
    NOT?: escalation_policy_rulesScalarWhereWithAggregatesInput | escalation_policy_rulesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"escalation_policy_rules"> | string
    team_escalationpolicyId?: StringWithAggregatesFilter<"escalation_policy_rules"> | string
    alert_status?: StringWithAggregatesFilter<"escalation_policy_rules"> | string
    minutes_after_creation?: IntWithAggregatesFilter<"escalation_policy_rules"> | number
    notification_type?: Enumnotification_typeWithAggregatesFilter<"escalation_policy_rules"> | $Enums.notification_type
    userId?: StringNullableWithAggregatesFilter<"escalation_policy_rules"> | string | null
    scheudleId?: StringNullableWithAggregatesFilter<"escalation_policy_rules"> | string | null
    teamId?: StringNullableWithAggregatesFilter<"escalation_policy_rules"> | string | null
    is_active?: BoolWithAggregatesFilter<"escalation_policy_rules"> | boolean
  }

  export type team_scheduleWhereInput = {
    AND?: team_scheduleWhereInput | team_scheduleWhereInput[]
    OR?: team_scheduleWhereInput[]
    NOT?: team_scheduleWhereInput | team_scheduleWhereInput[]
    id?: StringFilter<"team_schedule"> | string
    teamId?: StringFilter<"team_schedule"> | string
    name?: StringFilter<"team_schedule"> | string
    createdAt?: DateTimeFilter<"team_schedule"> | Date | string
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
    team_schedule_rotation?: Team_schedule_rotationListRelationFilter
    team_schedule_override?: Team_schedule_overrideListRelationFilter
  }

  export type team_scheduleOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    team?: teamOrderByWithRelationInput
    team_schedule_rotation?: team_schedule_rotationOrderByRelationAggregateInput
    team_schedule_override?: team_schedule_overrideOrderByRelationAggregateInput
  }

  export type team_scheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: team_scheduleWhereInput | team_scheduleWhereInput[]
    OR?: team_scheduleWhereInput[]
    NOT?: team_scheduleWhereInput | team_scheduleWhereInput[]
    teamId?: StringFilter<"team_schedule"> | string
    name?: StringFilter<"team_schedule"> | string
    createdAt?: DateTimeFilter<"team_schedule"> | Date | string
    team?: XOR<TeamScalarRelationFilter, teamWhereInput>
    team_schedule_rotation?: Team_schedule_rotationListRelationFilter
    team_schedule_override?: Team_schedule_overrideListRelationFilter
  }, "id">

  export type team_scheduleOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: team_scheduleCountOrderByAggregateInput
    _max?: team_scheduleMaxOrderByAggregateInput
    _min?: team_scheduleMinOrderByAggregateInput
  }

  export type team_scheduleScalarWhereWithAggregatesInput = {
    AND?: team_scheduleScalarWhereWithAggregatesInput | team_scheduleScalarWhereWithAggregatesInput[]
    OR?: team_scheduleScalarWhereWithAggregatesInput[]
    NOT?: team_scheduleScalarWhereWithAggregatesInput | team_scheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"team_schedule"> | string
    teamId?: StringWithAggregatesFilter<"team_schedule"> | string
    name?: StringWithAggregatesFilter<"team_schedule"> | string
    createdAt?: DateTimeWithAggregatesFilter<"team_schedule"> | Date | string
  }

  export type team_schedule_rotationWhereInput = {
    AND?: team_schedule_rotationWhereInput | team_schedule_rotationWhereInput[]
    OR?: team_schedule_rotationWhereInput[]
    NOT?: team_schedule_rotationWhereInput | team_schedule_rotationWhereInput[]
    id?: StringFilter<"team_schedule_rotation"> | string
    team_scheduleId?: StringFilter<"team_schedule_rotation"> | string
    name?: StringFilter<"team_schedule_rotation"> | string
    userId?: StringFilter<"team_schedule_rotation"> | string
    starts_on?: DateTimeFilter<"team_schedule_rotation"> | Date | string
    frequency?: EnumFrequencyFilter<"team_schedule_rotation"> | $Enums.Frequency
    ends_on?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    custom_start_date_time?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    custom_end_date_time?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    restrict_time_type?: EnumRestrictionNullableFilter<"team_schedule_rotation"> | $Enums.Restriction | null
    restrict_time_start?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    restrict_time_end?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    team_schedule?: XOR<Team_scheduleScalarRelationFilter, team_scheduleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type team_schedule_rotationOrderByWithRelationInput = {
    id?: SortOrder
    team_scheduleId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    starts_on?: SortOrder
    frequency?: SortOrder
    ends_on?: SortOrder
    custom_start_date_time?: SortOrder
    custom_end_date_time?: SortOrder
    restrict_time_type?: SortOrder
    restrict_time_start?: SortOrder
    restrict_time_end?: SortOrder
    team_schedule?: team_scheduleOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type team_schedule_rotationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: team_schedule_rotationWhereInput | team_schedule_rotationWhereInput[]
    OR?: team_schedule_rotationWhereInput[]
    NOT?: team_schedule_rotationWhereInput | team_schedule_rotationWhereInput[]
    team_scheduleId?: StringFilter<"team_schedule_rotation"> | string
    name?: StringFilter<"team_schedule_rotation"> | string
    userId?: StringFilter<"team_schedule_rotation"> | string
    starts_on?: DateTimeFilter<"team_schedule_rotation"> | Date | string
    frequency?: EnumFrequencyFilter<"team_schedule_rotation"> | $Enums.Frequency
    ends_on?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    custom_start_date_time?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    custom_end_date_time?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    restrict_time_type?: EnumRestrictionNullableFilter<"team_schedule_rotation"> | $Enums.Restriction | null
    restrict_time_start?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    restrict_time_end?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    team_schedule?: XOR<Team_scheduleScalarRelationFilter, team_scheduleWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type team_schedule_rotationOrderByWithAggregationInput = {
    id?: SortOrder
    team_scheduleId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    starts_on?: SortOrder
    frequency?: SortOrder
    ends_on?: SortOrder
    custom_start_date_time?: SortOrder
    custom_end_date_time?: SortOrder
    restrict_time_type?: SortOrder
    restrict_time_start?: SortOrder
    restrict_time_end?: SortOrder
    _count?: team_schedule_rotationCountOrderByAggregateInput
    _max?: team_schedule_rotationMaxOrderByAggregateInput
    _min?: team_schedule_rotationMinOrderByAggregateInput
  }

  export type team_schedule_rotationScalarWhereWithAggregatesInput = {
    AND?: team_schedule_rotationScalarWhereWithAggregatesInput | team_schedule_rotationScalarWhereWithAggregatesInput[]
    OR?: team_schedule_rotationScalarWhereWithAggregatesInput[]
    NOT?: team_schedule_rotationScalarWhereWithAggregatesInput | team_schedule_rotationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"team_schedule_rotation"> | string
    team_scheduleId?: StringWithAggregatesFilter<"team_schedule_rotation"> | string
    name?: StringWithAggregatesFilter<"team_schedule_rotation"> | string
    userId?: StringWithAggregatesFilter<"team_schedule_rotation"> | string
    starts_on?: DateTimeWithAggregatesFilter<"team_schedule_rotation"> | Date | string
    frequency?: EnumFrequencyWithAggregatesFilter<"team_schedule_rotation"> | $Enums.Frequency
    ends_on?: DateTimeNullableWithAggregatesFilter<"team_schedule_rotation"> | Date | string | null
    custom_start_date_time?: DateTimeNullableWithAggregatesFilter<"team_schedule_rotation"> | Date | string | null
    custom_end_date_time?: DateTimeNullableWithAggregatesFilter<"team_schedule_rotation"> | Date | string | null
    restrict_time_type?: EnumRestrictionNullableWithAggregatesFilter<"team_schedule_rotation"> | $Enums.Restriction | null
    restrict_time_start?: DateTimeNullableWithAggregatesFilter<"team_schedule_rotation"> | Date | string | null
    restrict_time_end?: DateTimeNullableWithAggregatesFilter<"team_schedule_rotation"> | Date | string | null
  }

  export type team_schedule_overrideWhereInput = {
    AND?: team_schedule_overrideWhereInput | team_schedule_overrideWhereInput[]
    OR?: team_schedule_overrideWhereInput[]
    NOT?: team_schedule_overrideWhereInput | team_schedule_overrideWhereInput[]
    id?: StringFilter<"team_schedule_override"> | string
    team_scheduleId?: StringFilter<"team_schedule_override"> | string
    name?: StringFilter<"team_schedule_override"> | string
    start_time?: DateTimeFilter<"team_schedule_override"> | Date | string
    end_time?: DateTimeNullableFilter<"team_schedule_override"> | Date | string | null
    team_schedule?: XOR<Team_scheduleScalarRelationFilter, team_scheduleWhereInput>
  }

  export type team_schedule_overrideOrderByWithRelationInput = {
    id?: SortOrder
    team_scheduleId?: SortOrder
    name?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    team_schedule?: team_scheduleOrderByWithRelationInput
  }

  export type team_schedule_overrideWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: team_schedule_overrideWhereInput | team_schedule_overrideWhereInput[]
    OR?: team_schedule_overrideWhereInput[]
    NOT?: team_schedule_overrideWhereInput | team_schedule_overrideWhereInput[]
    team_scheduleId?: StringFilter<"team_schedule_override"> | string
    name?: StringFilter<"team_schedule_override"> | string
    start_time?: DateTimeFilter<"team_schedule_override"> | Date | string
    end_time?: DateTimeNullableFilter<"team_schedule_override"> | Date | string | null
    team_schedule?: XOR<Team_scheduleScalarRelationFilter, team_scheduleWhereInput>
  }, "id">

  export type team_schedule_overrideOrderByWithAggregationInput = {
    id?: SortOrder
    team_scheduleId?: SortOrder
    name?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    _count?: team_schedule_overrideCountOrderByAggregateInput
    _max?: team_schedule_overrideMaxOrderByAggregateInput
    _min?: team_schedule_overrideMinOrderByAggregateInput
  }

  export type team_schedule_overrideScalarWhereWithAggregatesInput = {
    AND?: team_schedule_overrideScalarWhereWithAggregatesInput | team_schedule_overrideScalarWhereWithAggregatesInput[]
    OR?: team_schedule_overrideScalarWhereWithAggregatesInput[]
    NOT?: team_schedule_overrideScalarWhereWithAggregatesInput | team_schedule_overrideScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"team_schedule_override"> | string
    team_scheduleId?: StringWithAggregatesFilter<"team_schedule_override"> | string
    name?: StringWithAggregatesFilter<"team_schedule_override"> | string
    start_time?: DateTimeWithAggregatesFilter<"team_schedule_override"> | Date | string
    end_time?: DateTimeNullableWithAggregatesFilter<"team_schedule_override"> | Date | string | null
  }

  export type contactUsWhereInput = {
    AND?: contactUsWhereInput | contactUsWhereInput[]
    OR?: contactUsWhereInput[]
    NOT?: contactUsWhereInput | contactUsWhereInput[]
    id?: StringFilter<"contactUs"> | string
    name?: StringNullableFilter<"contactUs"> | string | null
    phoneNumber?: StringFilter<"contactUs"> | string
    email?: StringFilter<"contactUs"> | string
    createdAt?: DateTimeFilter<"contactUs"> | Date | string
  }

  export type contactUsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type contactUsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: contactUsWhereInput | contactUsWhereInput[]
    OR?: contactUsWhereInput[]
    NOT?: contactUsWhereInput | contactUsWhereInput[]
    name?: StringNullableFilter<"contactUs"> | string | null
    phoneNumber?: StringFilter<"contactUs"> | string
    email?: StringFilter<"contactUs"> | string
    createdAt?: DateTimeFilter<"contactUs"> | Date | string
  }, "id">

  export type contactUsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
    _count?: contactUsCountOrderByAggregateInput
    _max?: contactUsMaxOrderByAggregateInput
    _min?: contactUsMinOrderByAggregateInput
  }

  export type contactUsScalarWhereWithAggregatesInput = {
    AND?: contactUsScalarWhereWithAggregatesInput | contactUsScalarWhereWithAggregatesInput[]
    OR?: contactUsScalarWhereWithAggregatesInput[]
    NOT?: contactUsScalarWhereWithAggregatesInput | contactUsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"contactUs"> | string
    name?: StringNullableWithAggregatesFilter<"contactUs"> | string | null
    phoneNumber?: StringWithAggregatesFilter<"contactUs"> | string
    email?: StringWithAggregatesFilter<"contactUs"> | string
    createdAt?: DateTimeWithAggregatesFilter<"contactUs"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutUserInput
    teams?: teamCreateNestedManyWithoutCreatorInput
    alert?: alertCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutUserInput
    user_otp?: user_otpCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceUncheckedCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutUserInput
    teams?: teamUncheckedCreateNestedManyWithoutCreatorInput
    alert?: alertUncheckedCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutUserInput
    user_otp?: user_otpUncheckedCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutUserNestedInput
    teams?: teamUpdateManyWithoutCreatorNestedInput
    alert?: alertUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUncheckedUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUncheckedUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutUserNestedInput
    teams?: teamUncheckedUpdateManyWithoutCreatorNestedInput
    alert?: alertUncheckedUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUncheckedUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
  }

  export type UserUpdateManyMutationInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_otpCreateInput = {
    id?: string
    otp: string
    invalid?: boolean
    expiresAt: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutUser_otpInput
  }

  export type user_otpUncheckedCreateInput = {
    id?: string
    userId: string
    otp: string
    invalid?: boolean
    expiresAt: number
    createdAt?: Date | string
  }

  export type user_otpUpdateInput = {
    otp?: StringFieldUpdateOperationsInput | string
    invalid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutUser_otpNestedInput
  }

  export type user_otpUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    invalid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_otpCreateManyInput = {
    id?: string
    userId: string
    otp: string
    invalid?: boolean
    expiresAt: number
    createdAt?: Date | string
  }

  export type user_otpUpdateManyMutationInput = {
    otp?: StringFieldUpdateOperationsInput | string
    invalid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_otpUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    invalid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Monitor_configCreateInput = {
    id?: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMonitor_configInput
    workspace?: WorkSpaceCreateNestedOneWithoutMonitor_configInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsCreateNestedOneWithoutMonitor_configInput
    team?: teamCreateNestedOneWithoutMonitor_configInput
    alert?: alertCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configUncheckedCreateInput = {
    id?: string
    userId: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    workspaceId?: string | null
    teamId?: string | null
    createdAt?: Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsUncheckedCreateNestedOneWithoutMonitor_configInput
    alert?: alertUncheckedCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMonitor_configNestedInput
    workspace?: WorkSpaceUpdateOneWithoutMonitor_configNestedInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUpdateOneWithoutMonitor_configNestedInput
    team?: teamUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUncheckedUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUncheckedUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configCreateManyInput = {
    id?: string
    userId: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    workspaceId?: string | null
    teamId?: string | null
    createdAt?: Date | string
  }

  export type Monitor_configUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Monitor_configUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Monitor_HTTP_gPRC_configCreateInput = {
    id?: string
    authType: string
    interval_check?: string | null
    userName?: string | null
    password?: string | null
    inital_token?: string | null
    refresh_token?: string | null
    header_key?: string | null
    header_value?: string | null
    endpoint_url?: string | null
    failure_count?: string | null
    success_count?: string | null
    success_response_code?: string | null
    monitor_config: Monitor_configCreateNestedOneWithoutMonitor_HTTP_gPRC_configInput
  }

  export type Monitor_HTTP_gPRC_configUncheckedCreateInput = {
    id?: string
    monitor_configId: string
    authType: string
    interval_check?: string | null
    userName?: string | null
    password?: string | null
    inital_token?: string | null
    refresh_token?: string | null
    header_key?: string | null
    header_value?: string | null
    endpoint_url?: string | null
    failure_count?: string | null
    success_count?: string | null
    success_response_code?: string | null
  }

  export type Monitor_HTTP_gPRC_configUpdateInput = {
    authType?: StringFieldUpdateOperationsInput | string
    interval_check?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    inital_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    header_key?: NullableStringFieldUpdateOperationsInput | string | null
    header_value?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    failure_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_response_code?: NullableStringFieldUpdateOperationsInput | string | null
    monitor_config?: Monitor_configUpdateOneRequiredWithoutMonitor_HTTP_gPRC_configNestedInput
  }

  export type Monitor_HTTP_gPRC_configUncheckedUpdateInput = {
    monitor_configId?: StringFieldUpdateOperationsInput | string
    authType?: StringFieldUpdateOperationsInput | string
    interval_check?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    inital_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    header_key?: NullableStringFieldUpdateOperationsInput | string | null
    header_value?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    failure_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_response_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_HTTP_gPRC_configCreateManyInput = {
    id?: string
    monitor_configId: string
    authType: string
    interval_check?: string | null
    userName?: string | null
    password?: string | null
    inital_token?: string | null
    refresh_token?: string | null
    header_key?: string | null
    header_value?: string | null
    endpoint_url?: string | null
    failure_count?: string | null
    success_count?: string | null
    success_response_code?: string | null
  }

  export type Monitor_HTTP_gPRC_configUpdateManyMutationInput = {
    authType?: StringFieldUpdateOperationsInput | string
    interval_check?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    inital_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    header_key?: NullableStringFieldUpdateOperationsInput | string | null
    header_value?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    failure_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_response_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_HTTP_gPRC_configUncheckedUpdateManyInput = {
    monitor_configId?: StringFieldUpdateOperationsInput | string
    authType?: StringFieldUpdateOperationsInput | string
    interval_check?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    inital_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    header_key?: NullableStringFieldUpdateOperationsInput | string | null
    header_value?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    failure_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_response_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_SSL_configCreateInput = {
    id?: string
    endpoint_url?: string | null
    alt_names?: string | null
    is_wildcard?: boolean
    wildcard_url?: string | null
    certifcate_issue?: Date | string | null
    certificate_tenure?: string | null
    expiry_reminder?: string | null
    monitor_config: Monitor_configCreateNestedOneWithoutMonitor_SSL_configInput
  }

  export type Monitor_SSL_configUncheckedCreateInput = {
    id?: string
    monitor_configId: string
    endpoint_url?: string | null
    alt_names?: string | null
    is_wildcard?: boolean
    wildcard_url?: string | null
    certifcate_issue?: Date | string | null
    certificate_tenure?: string | null
    expiry_reminder?: string | null
  }

  export type Monitor_SSL_configUpdateInput = {
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_names?: NullableStringFieldUpdateOperationsInput | string | null
    is_wildcard?: BoolFieldUpdateOperationsInput | boolean
    wildcard_url?: NullableStringFieldUpdateOperationsInput | string | null
    certifcate_issue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_tenure?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_reminder?: NullableStringFieldUpdateOperationsInput | string | null
    monitor_config?: Monitor_configUpdateOneRequiredWithoutMonitor_SSL_configNestedInput
  }

  export type Monitor_SSL_configUncheckedUpdateInput = {
    monitor_configId?: StringFieldUpdateOperationsInput | string
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_names?: NullableStringFieldUpdateOperationsInput | string | null
    is_wildcard?: BoolFieldUpdateOperationsInput | boolean
    wildcard_url?: NullableStringFieldUpdateOperationsInput | string | null
    certifcate_issue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_tenure?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_reminder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_SSL_configCreateManyInput = {
    id?: string
    monitor_configId: string
    endpoint_url?: string | null
    alt_names?: string | null
    is_wildcard?: boolean
    wildcard_url?: string | null
    certifcate_issue?: Date | string | null
    certificate_tenure?: string | null
    expiry_reminder?: string | null
  }

  export type Monitor_SSL_configUpdateManyMutationInput = {
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_names?: NullableStringFieldUpdateOperationsInput | string | null
    is_wildcard?: BoolFieldUpdateOperationsInput | boolean
    wildcard_url?: NullableStringFieldUpdateOperationsInput | string | null
    certifcate_issue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_tenure?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_reminder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_SSL_configUncheckedUpdateManyInput = {
    monitor_configId?: StringFieldUpdateOperationsInput | string
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_names?: NullableStringFieldUpdateOperationsInput | string | null
    is_wildcard?: BoolFieldUpdateOperationsInput | boolean
    wildcard_url?: NullableStringFieldUpdateOperationsInput | string | null
    certifcate_issue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_tenure?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_reminder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_System_componentsCreateInput = {
    id?: string
    components_lists?: Monitor_System_componentsCreatecomponents_listsInput | string[]
    is_cloud?: boolean
    cloud_service_url?: string | null
    cloud_userName?: string | null
    cloud_password?: string | null
    cloud_downloadUrl?: string | null
    monitor_config: Monitor_configCreateNestedOneWithoutMonitor_System_componentsInput
  }

  export type Monitor_System_componentsUncheckedCreateInput = {
    id?: string
    monitor_configId: string
    components_lists?: Monitor_System_componentsCreatecomponents_listsInput | string[]
    is_cloud?: boolean
    cloud_service_url?: string | null
    cloud_userName?: string | null
    cloud_password?: string | null
    cloud_downloadUrl?: string | null
  }

  export type Monitor_System_componentsUpdateInput = {
    components_lists?: Monitor_System_componentsUpdatecomponents_listsInput | string[]
    is_cloud?: BoolFieldUpdateOperationsInput | boolean
    cloud_service_url?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_userName?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_password?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    monitor_config?: Monitor_configUpdateOneRequiredWithoutMonitor_System_componentsNestedInput
  }

  export type Monitor_System_componentsUncheckedUpdateInput = {
    monitor_configId?: StringFieldUpdateOperationsInput | string
    components_lists?: Monitor_System_componentsUpdatecomponents_listsInput | string[]
    is_cloud?: BoolFieldUpdateOperationsInput | boolean
    cloud_service_url?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_userName?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_password?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_System_componentsCreateManyInput = {
    id?: string
    monitor_configId: string
    components_lists?: Monitor_System_componentsCreatecomponents_listsInput | string[]
    is_cloud?: boolean
    cloud_service_url?: string | null
    cloud_userName?: string | null
    cloud_password?: string | null
    cloud_downloadUrl?: string | null
  }

  export type Monitor_System_componentsUpdateManyMutationInput = {
    components_lists?: Monitor_System_componentsUpdatecomponents_listsInput | string[]
    is_cloud?: BoolFieldUpdateOperationsInput | boolean
    cloud_service_url?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_userName?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_password?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_System_componentsUncheckedUpdateManyInput = {
    monitor_configId?: StringFieldUpdateOperationsInput | string
    components_lists?: Monitor_System_componentsUpdatecomponents_listsInput | string[]
    is_cloud?: BoolFieldUpdateOperationsInput | boolean
    cloud_service_url?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_userName?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_password?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type WorkSpaceCreateInput = {
    id?: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    owner: UserCreateNestedOneWithoutWorkspaceInput
    monitor_config?: Monitor_configCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersCreateNestedManyWithoutWokspaceInput
    team?: teamCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberCreateNestedManyWithoutWorkspaceInput
    alert?: alertCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceUncheckedCreateInput = {
    id?: string
    ownerId: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersUncheckedCreateNestedManyWithoutWokspaceInput
    team?: teamUncheckedCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberUncheckedCreateNestedManyWithoutWorkspaceInput
    alert?: alertUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceUpdateInput = {
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutWorkspaceNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUpdateManyWithoutWokspaceNestedInput
    team?: teamUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkSpaceUncheckedUpdateInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUncheckedUpdateManyWithoutWokspaceNestedInput
    team?: teamUncheckedUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUncheckedUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkSpaceCreateManyInput = {
    id?: string
    ownerId: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
  }

  export type WorkSpaceUpdateManyMutationInput = {
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkSpaceUncheckedUpdateManyInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type invited_usersCreateInput = {
    id?: string
    invited_user_name: string
    invited_user_email_id: string
    invited_by: string
    role: $Enums.Role
    status: $Enums.status
    invited_on?: Date | string
    wokspace: WorkSpaceCreateNestedOneWithoutInvited_usersInput
  }

  export type invited_usersUncheckedCreateInput = {
    id?: string
    invited_user_name: string
    invited_user_email_id: string
    invited_by: string
    workspaceId: string
    role: $Enums.Role
    status: $Enums.status
    invited_on?: Date | string
  }

  export type invited_usersUpdateInput = {
    invited_user_name?: StringFieldUpdateOperationsInput | string
    invited_user_email_id?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    invited_on?: DateTimeFieldUpdateOperationsInput | Date | string
    wokspace?: WorkSpaceUpdateOneRequiredWithoutInvited_usersNestedInput
  }

  export type invited_usersUncheckedUpdateInput = {
    invited_user_name?: StringFieldUpdateOperationsInput | string
    invited_user_email_id?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    invited_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invited_usersCreateManyInput = {
    id?: string
    invited_user_name: string
    invited_user_email_id: string
    invited_by: string
    workspaceId: string
    role: $Enums.Role
    status: $Enums.status
    invited_on?: Date | string
  }

  export type invited_usersUpdateManyMutationInput = {
    invited_user_name?: StringFieldUpdateOperationsInput | string
    invited_user_email_id?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    invited_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invited_usersUncheckedUpdateManyInput = {
    invited_user_name?: StringFieldUpdateOperationsInput | string
    invited_user_email_id?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    invited_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkSpace_usersCreateInput = {
    id?: string
    role?: $Enums.Role
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspace_usersInput
    workspace: WorkSpaceCreateNestedOneWithoutWorkspace_usersInput
    team_member?: team_memberCreateNestedManyWithoutWorkspace_userInput
  }

  export type WorkSpace_usersUncheckedCreateInput = {
    id?: string
    userId: string
    workspaceId: string
    role?: $Enums.Role
    createdAt?: Date | string
    team_member?: team_memberUncheckedCreateNestedManyWithoutWorkspace_userInput
  }

  export type WorkSpace_usersUpdateInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspace_usersNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutWorkspace_usersNestedInput
    team_member?: team_memberUpdateManyWithoutWorkspace_userNestedInput
  }

  export type WorkSpace_usersUncheckedUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_member?: team_memberUncheckedUpdateManyWithoutWorkspace_userNestedInput
  }

  export type WorkSpace_usersCreateManyInput = {
    id?: string
    userId: string
    workspaceId: string
    role?: $Enums.Role
    createdAt?: Date | string
  }

  export type WorkSpace_usersUpdateManyMutationInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkSpace_usersUncheckedUpdateManyInput = {
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamCreateInput = {
    id?: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutTeamsInput
    workspace: WorkSpaceCreateNestedOneWithoutTeamInput
    team_member?: team_memberCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateInput = {
    id?: string
    creatorId: string
    workspaceId: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    team_member?: team_memberUncheckedCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyUncheckedCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamUpdateInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTeamsNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutTeamNestedInput
    team_member?: team_memberUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_member?: team_memberUncheckedUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUncheckedUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamCreateManyInput = {
    id?: string
    creatorId: string
    workspaceId: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
  }

  export type teamUpdateManyMutationInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamUncheckedUpdateManyInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type team_memberCreateInput = {
    id?: string
    team: teamCreateNestedOneWithoutTeam_memberInput
    workspace_user: WorkSpace_usersCreateNestedOneWithoutTeam_memberInput
    workspace: WorkSpaceCreateNestedOneWithoutTeam_memberInput
  }

  export type team_memberUncheckedCreateInput = {
    id?: string
    teamId: string
    workspace_userId: string
    workspaceId: string
  }

  export type team_memberUpdateInput = {
    team?: teamUpdateOneRequiredWithoutTeam_memberNestedInput
    workspace_user?: WorkSpace_usersUpdateOneRequiredWithoutTeam_memberNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutTeam_memberNestedInput
  }

  export type team_memberUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    workspace_userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type team_memberCreateManyInput = {
    id?: string
    teamId: string
    workspace_userId: string
    workspaceId: string
  }

  export type team_memberUpdateManyMutationInput = {

  }

  export type team_memberUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    workspace_userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type alertCreateInput = {
    id?: string
    acknowledged?: boolean
    createdAt?: Date | string
    monitor_config: Monitor_configCreateNestedOneWithoutAlertInput
    user?: UserCreateNestedOneWithoutAlertInput
    workspace: WorkSpaceCreateNestedOneWithoutAlertInput
  }

  export type alertUncheckedCreateInput = {
    id?: string
    acknowledged?: boolean
    monitor_configId: string
    userId?: string | null
    workspaceId: string
    createdAt?: Date | string
  }

  export type alertUpdateInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitor_config?: Monitor_configUpdateOneRequiredWithoutAlertNestedInput
    user?: UserUpdateOneWithoutAlertNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutAlertNestedInput
  }

  export type alertUncheckedUpdateInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    monitor_configId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertCreateManyInput = {
    id?: string
    acknowledged?: boolean
    monitor_configId: string
    userId?: string | null
    workspaceId: string
    createdAt?: Date | string
  }

  export type alertUpdateManyMutationInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertUncheckedUpdateManyInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    monitor_configId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type team_escalationpolicyCreateInput = {
    id?: string
    escalationplicy_name: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    team: teamCreateNestedOneWithoutTeam_escalationpolicyInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutTeam_escalation_policyInput
  }

  export type team_escalationpolicyUncheckedCreateInput = {
    id?: string
    teamId: string
    escalationplicy_name: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutTeam_escalation_policyInput
  }

  export type team_escalationpolicyUpdateInput = {
    escalationplicy_name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: teamUpdateOneRequiredWithoutTeam_escalationpolicyNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutTeam_escalation_policyNestedInput
  }

  export type team_escalationpolicyUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    escalationplicy_name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutTeam_escalation_policyNestedInput
  }

  export type team_escalationpolicyCreateManyInput = {
    id?: string
    teamId: string
    escalationplicy_name: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type team_escalationpolicyUpdateManyMutationInput = {
    escalationplicy_name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type team_escalationpolicyUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    escalationplicy_name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escalation_policy_rulesCreateInput = {
    id?: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    scheudleId?: string | null
    is_active?: boolean
    team_escalation_policy: team_escalationpolicyCreateNestedOneWithoutEscalation_policy_rulesInput
    user?: UserCreateNestedOneWithoutEscalation_policy_rulesInput
    team?: teamCreateNestedOneWithoutEscalation_policy_rulesInput
  }

  export type escalation_policy_rulesUncheckedCreateInput = {
    id?: string
    team_escalationpolicyId: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    userId?: string | null
    scheudleId?: string | null
    teamId?: string | null
    is_active?: boolean
  }

  export type escalation_policy_rulesUpdateInput = {
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    team_escalation_policy?: team_escalationpolicyUpdateOneRequiredWithoutEscalation_policy_rulesNestedInput
    user?: UserUpdateOneWithoutEscalation_policy_rulesNestedInput
    team?: teamUpdateOneWithoutEscalation_policy_rulesNestedInput
  }

  export type escalation_policy_rulesUncheckedUpdateInput = {
    team_escalationpolicyId?: StringFieldUpdateOperationsInput | string
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type escalation_policy_rulesCreateManyInput = {
    id?: string
    team_escalationpolicyId: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    userId?: string | null
    scheudleId?: string | null
    teamId?: string | null
    is_active?: boolean
  }

  export type escalation_policy_rulesUpdateManyMutationInput = {
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type escalation_policy_rulesUncheckedUpdateManyInput = {
    team_escalationpolicyId?: StringFieldUpdateOperationsInput | string
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type team_scheduleCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    team: teamCreateNestedOneWithoutTeam_scheduleInput
    team_schedule_rotation?: team_schedule_rotationCreateNestedManyWithoutTeam_scheduleInput
    team_schedule_override?: team_schedule_overrideCreateNestedManyWithoutTeam_scheduleInput
  }

  export type team_scheduleUncheckedCreateInput = {
    id?: string
    teamId: string
    name: string
    createdAt?: Date | string
    team_schedule_rotation?: team_schedule_rotationUncheckedCreateNestedManyWithoutTeam_scheduleInput
    team_schedule_override?: team_schedule_overrideUncheckedCreateNestedManyWithoutTeam_scheduleInput
  }

  export type team_scheduleUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: teamUpdateOneRequiredWithoutTeam_scheduleNestedInput
    team_schedule_rotation?: team_schedule_rotationUpdateManyWithoutTeam_scheduleNestedInput
    team_schedule_override?: team_schedule_overrideUpdateManyWithoutTeam_scheduleNestedInput
  }

  export type team_scheduleUncheckedUpdateInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_schedule_rotation?: team_schedule_rotationUncheckedUpdateManyWithoutTeam_scheduleNestedInput
    team_schedule_override?: team_schedule_overrideUncheckedUpdateManyWithoutTeam_scheduleNestedInput
  }

  export type team_scheduleCreateManyInput = {
    id?: string
    teamId: string
    name: string
    createdAt?: Date | string
  }

  export type team_scheduleUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type team_scheduleUncheckedUpdateManyInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type team_schedule_rotationCreateInput = {
    id?: string
    name: string
    starts_on?: Date | string
    frequency: $Enums.Frequency
    ends_on?: Date | string | null
    custom_start_date_time?: Date | string | null
    custom_end_date_time?: Date | string | null
    restrict_time_type?: $Enums.Restriction | null
    restrict_time_start?: Date | string | null
    restrict_time_end?: Date | string | null
    team_schedule: team_scheduleCreateNestedOneWithoutTeam_schedule_rotationInput
    user: UserCreateNestedOneWithoutTeam_schedule_rotationInput
  }

  export type team_schedule_rotationUncheckedCreateInput = {
    id?: string
    team_scheduleId: string
    name: string
    userId: string
    starts_on?: Date | string
    frequency: $Enums.Frequency
    ends_on?: Date | string | null
    custom_start_date_time?: Date | string | null
    custom_end_date_time?: Date | string | null
    restrict_time_type?: $Enums.Restriction | null
    restrict_time_start?: Date | string | null
    restrict_time_end?: Date | string | null
  }

  export type team_schedule_rotationUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    starts_on?: DateTimeFieldUpdateOperationsInput | Date | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    ends_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_start_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_end_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_type?: NullableEnumRestrictionFieldUpdateOperationsInput | $Enums.Restriction | null
    restrict_time_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team_schedule?: team_scheduleUpdateOneRequiredWithoutTeam_schedule_rotationNestedInput
    user?: UserUpdateOneRequiredWithoutTeam_schedule_rotationNestedInput
  }

  export type team_schedule_rotationUncheckedUpdateInput = {
    team_scheduleId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    starts_on?: DateTimeFieldUpdateOperationsInput | Date | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    ends_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_start_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_end_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_type?: NullableEnumRestrictionFieldUpdateOperationsInput | $Enums.Restriction | null
    restrict_time_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type team_schedule_rotationCreateManyInput = {
    id?: string
    team_scheduleId: string
    name: string
    userId: string
    starts_on?: Date | string
    frequency: $Enums.Frequency
    ends_on?: Date | string | null
    custom_start_date_time?: Date | string | null
    custom_end_date_time?: Date | string | null
    restrict_time_type?: $Enums.Restriction | null
    restrict_time_start?: Date | string | null
    restrict_time_end?: Date | string | null
  }

  export type team_schedule_rotationUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    starts_on?: DateTimeFieldUpdateOperationsInput | Date | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    ends_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_start_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_end_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_type?: NullableEnumRestrictionFieldUpdateOperationsInput | $Enums.Restriction | null
    restrict_time_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type team_schedule_rotationUncheckedUpdateManyInput = {
    team_scheduleId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    starts_on?: DateTimeFieldUpdateOperationsInput | Date | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    ends_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_start_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_end_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_type?: NullableEnumRestrictionFieldUpdateOperationsInput | $Enums.Restriction | null
    restrict_time_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type team_schedule_overrideCreateInput = {
    id?: string
    name: string
    start_time: Date | string
    end_time?: Date | string | null
    team_schedule: team_scheduleCreateNestedOneWithoutTeam_schedule_overrideInput
  }

  export type team_schedule_overrideUncheckedCreateInput = {
    id?: string
    team_scheduleId: string
    name: string
    start_time: Date | string
    end_time?: Date | string | null
  }

  export type team_schedule_overrideUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team_schedule?: team_scheduleUpdateOneRequiredWithoutTeam_schedule_overrideNestedInput
  }

  export type team_schedule_overrideUncheckedUpdateInput = {
    team_scheduleId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type team_schedule_overrideCreateManyInput = {
    id?: string
    team_scheduleId: string
    name: string
    start_time: Date | string
    end_time?: Date | string | null
  }

  export type team_schedule_overrideUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type team_schedule_overrideUncheckedUpdateManyInput = {
    team_scheduleId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type contactUsCreateInput = {
    id?: string
    name?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
  }

  export type contactUsUncheckedCreateInput = {
    id?: string
    name?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
  }

  export type contactUsUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactUsUncheckedUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactUsCreateManyInput = {
    id?: string
    name?: string | null
    phoneNumber: string
    email: string
    createdAt?: Date | string
  }

  export type contactUsUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type contactUsUncheckedUpdateManyInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type Monitor_configListRelationFilter = {
    every?: Monitor_configWhereInput
    some?: Monitor_configWhereInput
    none?: Monitor_configWhereInput
  }

  export type WorkSpaceListRelationFilter = {
    every?: WorkSpaceWhereInput
    some?: WorkSpaceWhereInput
    none?: WorkSpaceWhereInput
  }

  export type WorkSpace_usersListRelationFilter = {
    every?: WorkSpace_usersWhereInput
    some?: WorkSpace_usersWhereInput
    none?: WorkSpace_usersWhereInput
  }

  export type TeamListRelationFilter = {
    every?: teamWhereInput
    some?: teamWhereInput
    none?: teamWhereInput
  }

  export type AlertListRelationFilter = {
    every?: alertWhereInput
    some?: alertWhereInput
    none?: alertWhereInput
  }

  export type Escalation_policy_rulesListRelationFilter = {
    every?: escalation_policy_rulesWhereInput
    some?: escalation_policy_rulesWhereInput
    none?: escalation_policy_rulesWhereInput
  }

  export type User_otpListRelationFilter = {
    every?: user_otpWhereInput
    some?: user_otpWhereInput
    none?: user_otpWhereInput
  }

  export type Team_schedule_rotationListRelationFilter = {
    every?: team_schedule_rotationWhereInput
    some?: team_schedule_rotationWhereInput
    none?: team_schedule_rotationWhereInput
  }

  export type Monitor_configOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkSpaceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkSpace_usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type alertOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type escalation_policy_rulesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type user_otpOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type team_schedule_rotationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    supaId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    number?: SortOrder
    photo?: SortOrder
    is_phone_number_verified?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    supaId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    number?: SortOrder
    photo?: SortOrder
    is_phone_number_verified?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    supaId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    number?: SortOrder
    photo?: SortOrder
    is_phone_number_verified?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type user_otpCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    invalid?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type user_otpAvgOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type user_otpMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    invalid?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type user_otpMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    otp?: SortOrder
    invalid?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
  }

  export type user_otpSumOrderByAggregateInput = {
    expiresAt?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type WorkSpaceNullableScalarRelationFilter = {
    is?: WorkSpaceWhereInput | null
    isNot?: WorkSpaceWhereInput | null
  }

  export type Monitor_HTTP_gPRC_configNullableScalarRelationFilter = {
    is?: Monitor_HTTP_gPRC_configWhereInput | null
    isNot?: Monitor_HTTP_gPRC_configWhereInput | null
  }

  export type Monitor_SSL_configNullableScalarRelationFilter = {
    is?: Monitor_SSL_configWhereInput | null
    isNot?: Monitor_SSL_configWhereInput | null
  }

  export type Monitor_System_componentsNullableScalarRelationFilter = {
    is?: Monitor_System_componentsWhereInput | null
    isNot?: Monitor_System_componentsWhereInput | null
  }

  export type TeamNullableScalarRelationFilter = {
    is?: teamWhereInput | null
    isNot?: teamWhereInput | null
  }

  export type Monitor_configCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    monitorType?: SortOrder
    is_active?: SortOrder
    workspaceId?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
  }

  export type Monitor_configMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    monitorType?: SortOrder
    is_active?: SortOrder
    workspaceId?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
  }

  export type Monitor_configMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    monitorType?: SortOrder
    is_active?: SortOrder
    workspaceId?: SortOrder
    teamId?: SortOrder
    createdAt?: SortOrder
  }

  export type Monitor_configScalarRelationFilter = {
    is?: Monitor_configWhereInput
    isNot?: Monitor_configWhereInput
  }

  export type Monitor_HTTP_gPRC_configCountOrderByAggregateInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    authType?: SortOrder
    interval_check?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    inital_token?: SortOrder
    refresh_token?: SortOrder
    header_key?: SortOrder
    header_value?: SortOrder
    endpoint_url?: SortOrder
    failure_count?: SortOrder
    success_count?: SortOrder
    success_response_code?: SortOrder
  }

  export type Monitor_HTTP_gPRC_configMaxOrderByAggregateInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    authType?: SortOrder
    interval_check?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    inital_token?: SortOrder
    refresh_token?: SortOrder
    header_key?: SortOrder
    header_value?: SortOrder
    endpoint_url?: SortOrder
    failure_count?: SortOrder
    success_count?: SortOrder
    success_response_code?: SortOrder
  }

  export type Monitor_HTTP_gPRC_configMinOrderByAggregateInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    authType?: SortOrder
    interval_check?: SortOrder
    userName?: SortOrder
    password?: SortOrder
    inital_token?: SortOrder
    refresh_token?: SortOrder
    header_key?: SortOrder
    header_value?: SortOrder
    endpoint_url?: SortOrder
    failure_count?: SortOrder
    success_count?: SortOrder
    success_response_code?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type Monitor_SSL_configCountOrderByAggregateInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    endpoint_url?: SortOrder
    alt_names?: SortOrder
    is_wildcard?: SortOrder
    wildcard_url?: SortOrder
    certifcate_issue?: SortOrder
    certificate_tenure?: SortOrder
    expiry_reminder?: SortOrder
  }

  export type Monitor_SSL_configMaxOrderByAggregateInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    endpoint_url?: SortOrder
    alt_names?: SortOrder
    is_wildcard?: SortOrder
    wildcard_url?: SortOrder
    certifcate_issue?: SortOrder
    certificate_tenure?: SortOrder
    expiry_reminder?: SortOrder
  }

  export type Monitor_SSL_configMinOrderByAggregateInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    endpoint_url?: SortOrder
    alt_names?: SortOrder
    is_wildcard?: SortOrder
    wildcard_url?: SortOrder
    certifcate_issue?: SortOrder
    certificate_tenure?: SortOrder
    expiry_reminder?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type Monitor_System_componentsCountOrderByAggregateInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    components_lists?: SortOrder
    is_cloud?: SortOrder
    cloud_service_url?: SortOrder
    cloud_userName?: SortOrder
    cloud_password?: SortOrder
    cloud_downloadUrl?: SortOrder
  }

  export type Monitor_System_componentsMaxOrderByAggregateInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    is_cloud?: SortOrder
    cloud_service_url?: SortOrder
    cloud_userName?: SortOrder
    cloud_password?: SortOrder
    cloud_downloadUrl?: SortOrder
  }

  export type Monitor_System_componentsMinOrderByAggregateInput = {
    id?: SortOrder
    monitor_configId?: SortOrder
    is_cloud?: SortOrder
    cloud_service_url?: SortOrder
    cloud_userName?: SortOrder
    cloud_password?: SortOrder
    cloud_downloadUrl?: SortOrder
  }

  export type Invited_usersListRelationFilter = {
    every?: invited_usersWhereInput
    some?: invited_usersWhereInput
    none?: invited_usersWhereInput
  }

  export type Team_memberListRelationFilter = {
    every?: team_memberWhereInput
    some?: team_memberWhereInput
    none?: team_memberWhereInput
  }

  export type invited_usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type team_memberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkSpaceCountOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    workspace_name?: SortOrder
    trial_startDate?: SortOrder
    trial_endDate?: SortOrder
    subscription_start?: SortOrder
    subscription_end?: SortOrder
  }

  export type WorkSpaceMaxOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    workspace_name?: SortOrder
    trial_startDate?: SortOrder
    trial_endDate?: SortOrder
    subscription_start?: SortOrder
    subscription_end?: SortOrder
  }

  export type WorkSpaceMinOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    workspace_name?: SortOrder
    trial_startDate?: SortOrder
    trial_endDate?: SortOrder
    subscription_start?: SortOrder
    subscription_end?: SortOrder
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type EnumstatusFilter<$PrismaModel = never> = {
    equals?: $Enums.status | EnumstatusFieldRefInput<$PrismaModel>
    in?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumstatusFilter<$PrismaModel> | $Enums.status
  }

  export type WorkSpaceScalarRelationFilter = {
    is?: WorkSpaceWhereInput
    isNot?: WorkSpaceWhereInput
  }

  export type invited_usersCountOrderByAggregateInput = {
    id?: SortOrder
    invited_user_name?: SortOrder
    invited_user_email_id?: SortOrder
    invited_by?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invited_on?: SortOrder
  }

  export type invited_usersMaxOrderByAggregateInput = {
    id?: SortOrder
    invited_user_name?: SortOrder
    invited_user_email_id?: SortOrder
    invited_by?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invited_on?: SortOrder
  }

  export type invited_usersMinOrderByAggregateInput = {
    id?: SortOrder
    invited_user_name?: SortOrder
    invited_user_email_id?: SortOrder
    invited_by?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    status?: SortOrder
    invited_on?: SortOrder
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type EnumstatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.status | EnumstatusFieldRefInput<$PrismaModel>
    in?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumstatusWithAggregatesFilter<$PrismaModel> | $Enums.status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstatusFilter<$PrismaModel>
    _max?: NestedEnumstatusFilter<$PrismaModel>
  }

  export type WorkSpace_usersCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkSpace_usersMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type WorkSpace_usersMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type Team_escalationpolicyListRelationFilter = {
    every?: team_escalationpolicyWhereInput
    some?: team_escalationpolicyWhereInput
    none?: team_escalationpolicyWhereInput
  }

  export type Team_scheduleListRelationFilter = {
    every?: team_scheduleWhereInput
    some?: team_scheduleWhereInput
    none?: team_scheduleWhereInput
  }

  export type team_escalationpolicyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type team_scheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type teamCountOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    workspaceId?: SortOrder
    teamName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type teamMaxOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    workspaceId?: SortOrder
    teamName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type teamMinOrderByAggregateInput = {
    id?: SortOrder
    creatorId?: SortOrder
    workspaceId?: SortOrder
    teamName?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TeamScalarRelationFilter = {
    is?: teamWhereInput
    isNot?: teamWhereInput
  }

  export type WorkSpace_usersScalarRelationFilter = {
    is?: WorkSpace_usersWhereInput
    isNot?: WorkSpace_usersWhereInput
  }

  export type team_memberCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    workspace_userId?: SortOrder
    workspaceId?: SortOrder
  }

  export type team_memberMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    workspace_userId?: SortOrder
    workspaceId?: SortOrder
  }

  export type team_memberMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    workspace_userId?: SortOrder
    workspaceId?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type alertCountOrderByAggregateInput = {
    id?: SortOrder
    acknowledged?: SortOrder
    monitor_configId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
  }

  export type alertMaxOrderByAggregateInput = {
    id?: SortOrder
    acknowledged?: SortOrder
    monitor_configId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
  }

  export type alertMinOrderByAggregateInput = {
    id?: SortOrder
    acknowledged?: SortOrder
    monitor_configId?: SortOrder
    userId?: SortOrder
    workspaceId?: SortOrder
    createdAt?: SortOrder
  }

  export type team_escalationpolicyCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    escalationplicy_name?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type team_escalationpolicyMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    escalationplicy_name?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type team_escalationpolicyMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    escalationplicy_name?: SortOrder
    isActive?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type Enumnotification_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type | Enumnotification_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type[] | ListEnumnotification_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.notification_type[] | ListEnumnotification_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumnotification_typeFilter<$PrismaModel> | $Enums.notification_type
  }

  export type Team_escalationpolicyScalarRelationFilter = {
    is?: team_escalationpolicyWhereInput
    isNot?: team_escalationpolicyWhereInput
  }

  export type escalation_policy_rulesCountOrderByAggregateInput = {
    id?: SortOrder
    team_escalationpolicyId?: SortOrder
    alert_status?: SortOrder
    minutes_after_creation?: SortOrder
    notification_type?: SortOrder
    userId?: SortOrder
    scheudleId?: SortOrder
    teamId?: SortOrder
    is_active?: SortOrder
  }

  export type escalation_policy_rulesAvgOrderByAggregateInput = {
    minutes_after_creation?: SortOrder
  }

  export type escalation_policy_rulesMaxOrderByAggregateInput = {
    id?: SortOrder
    team_escalationpolicyId?: SortOrder
    alert_status?: SortOrder
    minutes_after_creation?: SortOrder
    notification_type?: SortOrder
    userId?: SortOrder
    scheudleId?: SortOrder
    teamId?: SortOrder
    is_active?: SortOrder
  }

  export type escalation_policy_rulesMinOrderByAggregateInput = {
    id?: SortOrder
    team_escalationpolicyId?: SortOrder
    alert_status?: SortOrder
    minutes_after_creation?: SortOrder
    notification_type?: SortOrder
    userId?: SortOrder
    scheudleId?: SortOrder
    teamId?: SortOrder
    is_active?: SortOrder
  }

  export type escalation_policy_rulesSumOrderByAggregateInput = {
    minutes_after_creation?: SortOrder
  }

  export type Enumnotification_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type | Enumnotification_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type[] | ListEnumnotification_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.notification_type[] | ListEnumnotification_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumnotification_typeWithAggregatesFilter<$PrismaModel> | $Enums.notification_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumnotification_typeFilter<$PrismaModel>
    _max?: NestedEnumnotification_typeFilter<$PrismaModel>
  }

  export type Team_schedule_overrideListRelationFilter = {
    every?: team_schedule_overrideWhereInput
    some?: team_schedule_overrideWhereInput
    none?: team_schedule_overrideWhereInput
  }

  export type team_schedule_overrideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type team_scheduleCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type team_scheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type team_scheduleMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Frequency | EnumFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyFilter<$PrismaModel> | $Enums.Frequency
  }

  export type EnumRestrictionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Restriction | EnumRestrictionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Restriction[] | ListEnumRestrictionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Restriction[] | ListEnumRestrictionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRestrictionNullableFilter<$PrismaModel> | $Enums.Restriction | null
    isSet?: boolean
  }

  export type Team_scheduleScalarRelationFilter = {
    is?: team_scheduleWhereInput
    isNot?: team_scheduleWhereInput
  }

  export type team_schedule_rotationCountOrderByAggregateInput = {
    id?: SortOrder
    team_scheduleId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    starts_on?: SortOrder
    frequency?: SortOrder
    ends_on?: SortOrder
    custom_start_date_time?: SortOrder
    custom_end_date_time?: SortOrder
    restrict_time_type?: SortOrder
    restrict_time_start?: SortOrder
    restrict_time_end?: SortOrder
  }

  export type team_schedule_rotationMaxOrderByAggregateInput = {
    id?: SortOrder
    team_scheduleId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    starts_on?: SortOrder
    frequency?: SortOrder
    ends_on?: SortOrder
    custom_start_date_time?: SortOrder
    custom_end_date_time?: SortOrder
    restrict_time_type?: SortOrder
    restrict_time_start?: SortOrder
    restrict_time_end?: SortOrder
  }

  export type team_schedule_rotationMinOrderByAggregateInput = {
    id?: SortOrder
    team_scheduleId?: SortOrder
    name?: SortOrder
    userId?: SortOrder
    starts_on?: SortOrder
    frequency?: SortOrder
    ends_on?: SortOrder
    custom_start_date_time?: SortOrder
    custom_end_date_time?: SortOrder
    restrict_time_type?: SortOrder
    restrict_time_start?: SortOrder
    restrict_time_end?: SortOrder
  }

  export type EnumFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Frequency | EnumFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.Frequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFrequencyFilter<$PrismaModel>
    _max?: NestedEnumFrequencyFilter<$PrismaModel>
  }

  export type EnumRestrictionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Restriction | EnumRestrictionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Restriction[] | ListEnumRestrictionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Restriction[] | ListEnumRestrictionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRestrictionNullableWithAggregatesFilter<$PrismaModel> | $Enums.Restriction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRestrictionNullableFilter<$PrismaModel>
    _max?: NestedEnumRestrictionNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type team_schedule_overrideCountOrderByAggregateInput = {
    id?: SortOrder
    team_scheduleId?: SortOrder
    name?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type team_schedule_overrideMaxOrderByAggregateInput = {
    id?: SortOrder
    team_scheduleId?: SortOrder
    name?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type team_schedule_overrideMinOrderByAggregateInput = {
    id?: SortOrder
    team_scheduleId?: SortOrder
    name?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
  }

  export type contactUsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type contactUsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type contactUsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    phoneNumber?: SortOrder
    email?: SortOrder
    createdAt?: SortOrder
  }

  export type Monitor_configCreateNestedManyWithoutUserInput = {
    create?: XOR<Monitor_configCreateWithoutUserInput, Monitor_configUncheckedCreateWithoutUserInput> | Monitor_configCreateWithoutUserInput[] | Monitor_configUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutUserInput | Monitor_configCreateOrConnectWithoutUserInput[]
    createMany?: Monitor_configCreateManyUserInputEnvelope
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
  }

  export type WorkSpaceCreateNestedManyWithoutOwnerInput = {
    create?: XOR<WorkSpaceCreateWithoutOwnerInput, WorkSpaceUncheckedCreateWithoutOwnerInput> | WorkSpaceCreateWithoutOwnerInput[] | WorkSpaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutOwnerInput | WorkSpaceCreateOrConnectWithoutOwnerInput[]
    createMany?: WorkSpaceCreateManyOwnerInputEnvelope
    connect?: WorkSpaceWhereUniqueInput | WorkSpaceWhereUniqueInput[]
  }

  export type WorkSpace_usersCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkSpace_usersCreateWithoutUserInput, WorkSpace_usersUncheckedCreateWithoutUserInput> | WorkSpace_usersCreateWithoutUserInput[] | WorkSpace_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkSpace_usersCreateOrConnectWithoutUserInput | WorkSpace_usersCreateOrConnectWithoutUserInput[]
    createMany?: WorkSpace_usersCreateManyUserInputEnvelope
    connect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
  }

  export type teamCreateNestedManyWithoutCreatorInput = {
    create?: XOR<teamCreateWithoutCreatorInput, teamUncheckedCreateWithoutCreatorInput> | teamCreateWithoutCreatorInput[] | teamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: teamCreateOrConnectWithoutCreatorInput | teamCreateOrConnectWithoutCreatorInput[]
    createMany?: teamCreateManyCreatorInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type alertCreateNestedManyWithoutUserInput = {
    create?: XOR<alertCreateWithoutUserInput, alertUncheckedCreateWithoutUserInput> | alertCreateWithoutUserInput[] | alertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: alertCreateOrConnectWithoutUserInput | alertCreateOrConnectWithoutUserInput[]
    createMany?: alertCreateManyUserInputEnvelope
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
  }

  export type escalation_policy_rulesCreateNestedManyWithoutUserInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutUserInput, escalation_policy_rulesUncheckedCreateWithoutUserInput> | escalation_policy_rulesCreateWithoutUserInput[] | escalation_policy_rulesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutUserInput | escalation_policy_rulesCreateOrConnectWithoutUserInput[]
    createMany?: escalation_policy_rulesCreateManyUserInputEnvelope
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
  }

  export type user_otpCreateNestedManyWithoutUserInput = {
    create?: XOR<user_otpCreateWithoutUserInput, user_otpUncheckedCreateWithoutUserInput> | user_otpCreateWithoutUserInput[] | user_otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_otpCreateOrConnectWithoutUserInput | user_otpCreateOrConnectWithoutUserInput[]
    createMany?: user_otpCreateManyUserInputEnvelope
    connect?: user_otpWhereUniqueInput | user_otpWhereUniqueInput[]
  }

  export type team_schedule_rotationCreateNestedManyWithoutUserInput = {
    create?: XOR<team_schedule_rotationCreateWithoutUserInput, team_schedule_rotationUncheckedCreateWithoutUserInput> | team_schedule_rotationCreateWithoutUserInput[] | team_schedule_rotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: team_schedule_rotationCreateOrConnectWithoutUserInput | team_schedule_rotationCreateOrConnectWithoutUserInput[]
    createMany?: team_schedule_rotationCreateManyUserInputEnvelope
    connect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
  }

  export type Monitor_configUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Monitor_configCreateWithoutUserInput, Monitor_configUncheckedCreateWithoutUserInput> | Monitor_configCreateWithoutUserInput[] | Monitor_configUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutUserInput | Monitor_configCreateOrConnectWithoutUserInput[]
    createMany?: Monitor_configCreateManyUserInputEnvelope
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
  }

  export type WorkSpaceUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<WorkSpaceCreateWithoutOwnerInput, WorkSpaceUncheckedCreateWithoutOwnerInput> | WorkSpaceCreateWithoutOwnerInput[] | WorkSpaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutOwnerInput | WorkSpaceCreateOrConnectWithoutOwnerInput[]
    createMany?: WorkSpaceCreateManyOwnerInputEnvelope
    connect?: WorkSpaceWhereUniqueInput | WorkSpaceWhereUniqueInput[]
  }

  export type WorkSpace_usersUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<WorkSpace_usersCreateWithoutUserInput, WorkSpace_usersUncheckedCreateWithoutUserInput> | WorkSpace_usersCreateWithoutUserInput[] | WorkSpace_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkSpace_usersCreateOrConnectWithoutUserInput | WorkSpace_usersCreateOrConnectWithoutUserInput[]
    createMany?: WorkSpace_usersCreateManyUserInputEnvelope
    connect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
  }

  export type teamUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<teamCreateWithoutCreatorInput, teamUncheckedCreateWithoutCreatorInput> | teamCreateWithoutCreatorInput[] | teamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: teamCreateOrConnectWithoutCreatorInput | teamCreateOrConnectWithoutCreatorInput[]
    createMany?: teamCreateManyCreatorInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type alertUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<alertCreateWithoutUserInput, alertUncheckedCreateWithoutUserInput> | alertCreateWithoutUserInput[] | alertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: alertCreateOrConnectWithoutUserInput | alertCreateOrConnectWithoutUserInput[]
    createMany?: alertCreateManyUserInputEnvelope
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
  }

  export type escalation_policy_rulesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutUserInput, escalation_policy_rulesUncheckedCreateWithoutUserInput> | escalation_policy_rulesCreateWithoutUserInput[] | escalation_policy_rulesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutUserInput | escalation_policy_rulesCreateOrConnectWithoutUserInput[]
    createMany?: escalation_policy_rulesCreateManyUserInputEnvelope
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
  }

  export type user_otpUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<user_otpCreateWithoutUserInput, user_otpUncheckedCreateWithoutUserInput> | user_otpCreateWithoutUserInput[] | user_otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_otpCreateOrConnectWithoutUserInput | user_otpCreateOrConnectWithoutUserInput[]
    createMany?: user_otpCreateManyUserInputEnvelope
    connect?: user_otpWhereUniqueInput | user_otpWhereUniqueInput[]
  }

  export type team_schedule_rotationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<team_schedule_rotationCreateWithoutUserInput, team_schedule_rotationUncheckedCreateWithoutUserInput> | team_schedule_rotationCreateWithoutUserInput[] | team_schedule_rotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: team_schedule_rotationCreateOrConnectWithoutUserInput | team_schedule_rotationCreateOrConnectWithoutUserInput[]
    createMany?: team_schedule_rotationCreateManyUserInputEnvelope
    connect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type Monitor_configUpdateManyWithoutUserNestedInput = {
    create?: XOR<Monitor_configCreateWithoutUserInput, Monitor_configUncheckedCreateWithoutUserInput> | Monitor_configCreateWithoutUserInput[] | Monitor_configUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutUserInput | Monitor_configCreateOrConnectWithoutUserInput[]
    upsert?: Monitor_configUpsertWithWhereUniqueWithoutUserInput | Monitor_configUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Monitor_configCreateManyUserInputEnvelope
    set?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    disconnect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    delete?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    update?: Monitor_configUpdateWithWhereUniqueWithoutUserInput | Monitor_configUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Monitor_configUpdateManyWithWhereWithoutUserInput | Monitor_configUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Monitor_configScalarWhereInput | Monitor_configScalarWhereInput[]
  }

  export type WorkSpaceUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<WorkSpaceCreateWithoutOwnerInput, WorkSpaceUncheckedCreateWithoutOwnerInput> | WorkSpaceCreateWithoutOwnerInput[] | WorkSpaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutOwnerInput | WorkSpaceCreateOrConnectWithoutOwnerInput[]
    upsert?: WorkSpaceUpsertWithWhereUniqueWithoutOwnerInput | WorkSpaceUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: WorkSpaceCreateManyOwnerInputEnvelope
    set?: WorkSpaceWhereUniqueInput | WorkSpaceWhereUniqueInput[]
    disconnect?: WorkSpaceWhereUniqueInput | WorkSpaceWhereUniqueInput[]
    delete?: WorkSpaceWhereUniqueInput | WorkSpaceWhereUniqueInput[]
    connect?: WorkSpaceWhereUniqueInput | WorkSpaceWhereUniqueInput[]
    update?: WorkSpaceUpdateWithWhereUniqueWithoutOwnerInput | WorkSpaceUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: WorkSpaceUpdateManyWithWhereWithoutOwnerInput | WorkSpaceUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: WorkSpaceScalarWhereInput | WorkSpaceScalarWhereInput[]
  }

  export type WorkSpace_usersUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkSpace_usersCreateWithoutUserInput, WorkSpace_usersUncheckedCreateWithoutUserInput> | WorkSpace_usersCreateWithoutUserInput[] | WorkSpace_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkSpace_usersCreateOrConnectWithoutUserInput | WorkSpace_usersCreateOrConnectWithoutUserInput[]
    upsert?: WorkSpace_usersUpsertWithWhereUniqueWithoutUserInput | WorkSpace_usersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkSpace_usersCreateManyUserInputEnvelope
    set?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    disconnect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    delete?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    connect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    update?: WorkSpace_usersUpdateWithWhereUniqueWithoutUserInput | WorkSpace_usersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkSpace_usersUpdateManyWithWhereWithoutUserInput | WorkSpace_usersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkSpace_usersScalarWhereInput | WorkSpace_usersScalarWhereInput[]
  }

  export type teamUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<teamCreateWithoutCreatorInput, teamUncheckedCreateWithoutCreatorInput> | teamCreateWithoutCreatorInput[] | teamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: teamCreateOrConnectWithoutCreatorInput | teamCreateOrConnectWithoutCreatorInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutCreatorInput | teamUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: teamCreateManyCreatorInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutCreatorInput | teamUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: teamUpdateManyWithWhereWithoutCreatorInput | teamUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type alertUpdateManyWithoutUserNestedInput = {
    create?: XOR<alertCreateWithoutUserInput, alertUncheckedCreateWithoutUserInput> | alertCreateWithoutUserInput[] | alertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: alertCreateOrConnectWithoutUserInput | alertCreateOrConnectWithoutUserInput[]
    upsert?: alertUpsertWithWhereUniqueWithoutUserInput | alertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: alertCreateManyUserInputEnvelope
    set?: alertWhereUniqueInput | alertWhereUniqueInput[]
    disconnect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    delete?: alertWhereUniqueInput | alertWhereUniqueInput[]
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    update?: alertUpdateWithWhereUniqueWithoutUserInput | alertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: alertUpdateManyWithWhereWithoutUserInput | alertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: alertScalarWhereInput | alertScalarWhereInput[]
  }

  export type escalation_policy_rulesUpdateManyWithoutUserNestedInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutUserInput, escalation_policy_rulesUncheckedCreateWithoutUserInput> | escalation_policy_rulesCreateWithoutUserInput[] | escalation_policy_rulesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutUserInput | escalation_policy_rulesCreateOrConnectWithoutUserInput[]
    upsert?: escalation_policy_rulesUpsertWithWhereUniqueWithoutUserInput | escalation_policy_rulesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: escalation_policy_rulesCreateManyUserInputEnvelope
    set?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    disconnect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    delete?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    update?: escalation_policy_rulesUpdateWithWhereUniqueWithoutUserInput | escalation_policy_rulesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: escalation_policy_rulesUpdateManyWithWhereWithoutUserInput | escalation_policy_rulesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: escalation_policy_rulesScalarWhereInput | escalation_policy_rulesScalarWhereInput[]
  }

  export type user_otpUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_otpCreateWithoutUserInput, user_otpUncheckedCreateWithoutUserInput> | user_otpCreateWithoutUserInput[] | user_otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_otpCreateOrConnectWithoutUserInput | user_otpCreateOrConnectWithoutUserInput[]
    upsert?: user_otpUpsertWithWhereUniqueWithoutUserInput | user_otpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_otpCreateManyUserInputEnvelope
    set?: user_otpWhereUniqueInput | user_otpWhereUniqueInput[]
    disconnect?: user_otpWhereUniqueInput | user_otpWhereUniqueInput[]
    delete?: user_otpWhereUniqueInput | user_otpWhereUniqueInput[]
    connect?: user_otpWhereUniqueInput | user_otpWhereUniqueInput[]
    update?: user_otpUpdateWithWhereUniqueWithoutUserInput | user_otpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_otpUpdateManyWithWhereWithoutUserInput | user_otpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_otpScalarWhereInput | user_otpScalarWhereInput[]
  }

  export type team_schedule_rotationUpdateManyWithoutUserNestedInput = {
    create?: XOR<team_schedule_rotationCreateWithoutUserInput, team_schedule_rotationUncheckedCreateWithoutUserInput> | team_schedule_rotationCreateWithoutUserInput[] | team_schedule_rotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: team_schedule_rotationCreateOrConnectWithoutUserInput | team_schedule_rotationCreateOrConnectWithoutUserInput[]
    upsert?: team_schedule_rotationUpsertWithWhereUniqueWithoutUserInput | team_schedule_rotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: team_schedule_rotationCreateManyUserInputEnvelope
    set?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    disconnect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    delete?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    connect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    update?: team_schedule_rotationUpdateWithWhereUniqueWithoutUserInput | team_schedule_rotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: team_schedule_rotationUpdateManyWithWhereWithoutUserInput | team_schedule_rotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: team_schedule_rotationScalarWhereInput | team_schedule_rotationScalarWhereInput[]
  }

  export type Monitor_configUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Monitor_configCreateWithoutUserInput, Monitor_configUncheckedCreateWithoutUserInput> | Monitor_configCreateWithoutUserInput[] | Monitor_configUncheckedCreateWithoutUserInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutUserInput | Monitor_configCreateOrConnectWithoutUserInput[]
    upsert?: Monitor_configUpsertWithWhereUniqueWithoutUserInput | Monitor_configUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: Monitor_configCreateManyUserInputEnvelope
    set?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    disconnect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    delete?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    update?: Monitor_configUpdateWithWhereUniqueWithoutUserInput | Monitor_configUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: Monitor_configUpdateManyWithWhereWithoutUserInput | Monitor_configUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: Monitor_configScalarWhereInput | Monitor_configScalarWhereInput[]
  }

  export type WorkSpaceUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<WorkSpaceCreateWithoutOwnerInput, WorkSpaceUncheckedCreateWithoutOwnerInput> | WorkSpaceCreateWithoutOwnerInput[] | WorkSpaceUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutOwnerInput | WorkSpaceCreateOrConnectWithoutOwnerInput[]
    upsert?: WorkSpaceUpsertWithWhereUniqueWithoutOwnerInput | WorkSpaceUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: WorkSpaceCreateManyOwnerInputEnvelope
    set?: WorkSpaceWhereUniqueInput | WorkSpaceWhereUniqueInput[]
    disconnect?: WorkSpaceWhereUniqueInput | WorkSpaceWhereUniqueInput[]
    delete?: WorkSpaceWhereUniqueInput | WorkSpaceWhereUniqueInput[]
    connect?: WorkSpaceWhereUniqueInput | WorkSpaceWhereUniqueInput[]
    update?: WorkSpaceUpdateWithWhereUniqueWithoutOwnerInput | WorkSpaceUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: WorkSpaceUpdateManyWithWhereWithoutOwnerInput | WorkSpaceUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: WorkSpaceScalarWhereInput | WorkSpaceScalarWhereInput[]
  }

  export type WorkSpace_usersUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<WorkSpace_usersCreateWithoutUserInput, WorkSpace_usersUncheckedCreateWithoutUserInput> | WorkSpace_usersCreateWithoutUserInput[] | WorkSpace_usersUncheckedCreateWithoutUserInput[]
    connectOrCreate?: WorkSpace_usersCreateOrConnectWithoutUserInput | WorkSpace_usersCreateOrConnectWithoutUserInput[]
    upsert?: WorkSpace_usersUpsertWithWhereUniqueWithoutUserInput | WorkSpace_usersUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: WorkSpace_usersCreateManyUserInputEnvelope
    set?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    disconnect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    delete?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    connect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    update?: WorkSpace_usersUpdateWithWhereUniqueWithoutUserInput | WorkSpace_usersUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: WorkSpace_usersUpdateManyWithWhereWithoutUserInput | WorkSpace_usersUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: WorkSpace_usersScalarWhereInput | WorkSpace_usersScalarWhereInput[]
  }

  export type teamUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<teamCreateWithoutCreatorInput, teamUncheckedCreateWithoutCreatorInput> | teamCreateWithoutCreatorInput[] | teamUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: teamCreateOrConnectWithoutCreatorInput | teamCreateOrConnectWithoutCreatorInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutCreatorInput | teamUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: teamCreateManyCreatorInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutCreatorInput | teamUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: teamUpdateManyWithWhereWithoutCreatorInput | teamUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type alertUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<alertCreateWithoutUserInput, alertUncheckedCreateWithoutUserInput> | alertCreateWithoutUserInput[] | alertUncheckedCreateWithoutUserInput[]
    connectOrCreate?: alertCreateOrConnectWithoutUserInput | alertCreateOrConnectWithoutUserInput[]
    upsert?: alertUpsertWithWhereUniqueWithoutUserInput | alertUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: alertCreateManyUserInputEnvelope
    set?: alertWhereUniqueInput | alertWhereUniqueInput[]
    disconnect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    delete?: alertWhereUniqueInput | alertWhereUniqueInput[]
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    update?: alertUpdateWithWhereUniqueWithoutUserInput | alertUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: alertUpdateManyWithWhereWithoutUserInput | alertUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: alertScalarWhereInput | alertScalarWhereInput[]
  }

  export type escalation_policy_rulesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutUserInput, escalation_policy_rulesUncheckedCreateWithoutUserInput> | escalation_policy_rulesCreateWithoutUserInput[] | escalation_policy_rulesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutUserInput | escalation_policy_rulesCreateOrConnectWithoutUserInput[]
    upsert?: escalation_policy_rulesUpsertWithWhereUniqueWithoutUserInput | escalation_policy_rulesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: escalation_policy_rulesCreateManyUserInputEnvelope
    set?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    disconnect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    delete?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    update?: escalation_policy_rulesUpdateWithWhereUniqueWithoutUserInput | escalation_policy_rulesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: escalation_policy_rulesUpdateManyWithWhereWithoutUserInput | escalation_policy_rulesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: escalation_policy_rulesScalarWhereInput | escalation_policy_rulesScalarWhereInput[]
  }

  export type user_otpUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<user_otpCreateWithoutUserInput, user_otpUncheckedCreateWithoutUserInput> | user_otpCreateWithoutUserInput[] | user_otpUncheckedCreateWithoutUserInput[]
    connectOrCreate?: user_otpCreateOrConnectWithoutUserInput | user_otpCreateOrConnectWithoutUserInput[]
    upsert?: user_otpUpsertWithWhereUniqueWithoutUserInput | user_otpUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: user_otpCreateManyUserInputEnvelope
    set?: user_otpWhereUniqueInput | user_otpWhereUniqueInput[]
    disconnect?: user_otpWhereUniqueInput | user_otpWhereUniqueInput[]
    delete?: user_otpWhereUniqueInput | user_otpWhereUniqueInput[]
    connect?: user_otpWhereUniqueInput | user_otpWhereUniqueInput[]
    update?: user_otpUpdateWithWhereUniqueWithoutUserInput | user_otpUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: user_otpUpdateManyWithWhereWithoutUserInput | user_otpUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: user_otpScalarWhereInput | user_otpScalarWhereInput[]
  }

  export type team_schedule_rotationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<team_schedule_rotationCreateWithoutUserInput, team_schedule_rotationUncheckedCreateWithoutUserInput> | team_schedule_rotationCreateWithoutUserInput[] | team_schedule_rotationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: team_schedule_rotationCreateOrConnectWithoutUserInput | team_schedule_rotationCreateOrConnectWithoutUserInput[]
    upsert?: team_schedule_rotationUpsertWithWhereUniqueWithoutUserInput | team_schedule_rotationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: team_schedule_rotationCreateManyUserInputEnvelope
    set?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    disconnect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    delete?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    connect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    update?: team_schedule_rotationUpdateWithWhereUniqueWithoutUserInput | team_schedule_rotationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: team_schedule_rotationUpdateManyWithWhereWithoutUserInput | team_schedule_rotationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: team_schedule_rotationScalarWhereInput | team_schedule_rotationScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutUser_otpInput = {
    create?: XOR<UserCreateWithoutUser_otpInput, UserUncheckedCreateWithoutUser_otpInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_otpInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutUser_otpNestedInput = {
    create?: XOR<UserCreateWithoutUser_otpInput, UserUncheckedCreateWithoutUser_otpInput>
    connectOrCreate?: UserCreateOrConnectWithoutUser_otpInput
    upsert?: UserUpsertWithoutUser_otpInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutUser_otpInput, UserUpdateWithoutUser_otpInput>, UserUncheckedUpdateWithoutUser_otpInput>
  }

  export type UserCreateNestedOneWithoutMonitor_configInput = {
    create?: XOR<UserCreateWithoutMonitor_configInput, UserUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: UserCreateOrConnectWithoutMonitor_configInput
    connect?: UserWhereUniqueInput
  }

  export type WorkSpaceCreateNestedOneWithoutMonitor_configInput = {
    create?: XOR<WorkSpaceCreateWithoutMonitor_configInput, WorkSpaceUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutMonitor_configInput
    connect?: WorkSpaceWhereUniqueInput
  }

  export type Monitor_HTTP_gPRC_configCreateNestedOneWithoutMonitor_configInput = {
    create?: XOR<Monitor_HTTP_gPRC_configCreateWithoutMonitor_configInput, Monitor_HTTP_gPRC_configUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_HTTP_gPRC_configCreateOrConnectWithoutMonitor_configInput
    connect?: Monitor_HTTP_gPRC_configWhereUniqueInput
  }

  export type Monitor_SSL_configCreateNestedOneWithoutMonitor_configInput = {
    create?: XOR<Monitor_SSL_configCreateWithoutMonitor_configInput, Monitor_SSL_configUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_SSL_configCreateOrConnectWithoutMonitor_configInput
    connect?: Monitor_SSL_configWhereUniqueInput
  }

  export type Monitor_System_componentsCreateNestedOneWithoutMonitor_configInput = {
    create?: XOR<Monitor_System_componentsCreateWithoutMonitor_configInput, Monitor_System_componentsUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_System_componentsCreateOrConnectWithoutMonitor_configInput
    connect?: Monitor_System_componentsWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutMonitor_configInput = {
    create?: XOR<teamCreateWithoutMonitor_configInput, teamUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: teamCreateOrConnectWithoutMonitor_configInput
    connect?: teamWhereUniqueInput
  }

  export type alertCreateNestedManyWithoutMonitor_configInput = {
    create?: XOR<alertCreateWithoutMonitor_configInput, alertUncheckedCreateWithoutMonitor_configInput> | alertCreateWithoutMonitor_configInput[] | alertUncheckedCreateWithoutMonitor_configInput[]
    connectOrCreate?: alertCreateOrConnectWithoutMonitor_configInput | alertCreateOrConnectWithoutMonitor_configInput[]
    createMany?: alertCreateManyMonitor_configInputEnvelope
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
  }

  export type Monitor_HTTP_gPRC_configUncheckedCreateNestedOneWithoutMonitor_configInput = {
    create?: XOR<Monitor_HTTP_gPRC_configCreateWithoutMonitor_configInput, Monitor_HTTP_gPRC_configUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_HTTP_gPRC_configCreateOrConnectWithoutMonitor_configInput
    connect?: Monitor_HTTP_gPRC_configWhereUniqueInput
  }

  export type Monitor_SSL_configUncheckedCreateNestedOneWithoutMonitor_configInput = {
    create?: XOR<Monitor_SSL_configCreateWithoutMonitor_configInput, Monitor_SSL_configUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_SSL_configCreateOrConnectWithoutMonitor_configInput
    connect?: Monitor_SSL_configWhereUniqueInput
  }

  export type Monitor_System_componentsUncheckedCreateNestedOneWithoutMonitor_configInput = {
    create?: XOR<Monitor_System_componentsCreateWithoutMonitor_configInput, Monitor_System_componentsUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_System_componentsCreateOrConnectWithoutMonitor_configInput
    connect?: Monitor_System_componentsWhereUniqueInput
  }

  export type alertUncheckedCreateNestedManyWithoutMonitor_configInput = {
    create?: XOR<alertCreateWithoutMonitor_configInput, alertUncheckedCreateWithoutMonitor_configInput> | alertCreateWithoutMonitor_configInput[] | alertUncheckedCreateWithoutMonitor_configInput[]
    connectOrCreate?: alertCreateOrConnectWithoutMonitor_configInput | alertCreateOrConnectWithoutMonitor_configInput[]
    createMany?: alertCreateManyMonitor_configInputEnvelope
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMonitor_configNestedInput = {
    create?: XOR<UserCreateWithoutMonitor_configInput, UserUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: UserCreateOrConnectWithoutMonitor_configInput
    upsert?: UserUpsertWithoutMonitor_configInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMonitor_configInput, UserUpdateWithoutMonitor_configInput>, UserUncheckedUpdateWithoutMonitor_configInput>
  }

  export type WorkSpaceUpdateOneWithoutMonitor_configNestedInput = {
    create?: XOR<WorkSpaceCreateWithoutMonitor_configInput, WorkSpaceUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutMonitor_configInput
    upsert?: WorkSpaceUpsertWithoutMonitor_configInput
    disconnect?: boolean
    delete?: WorkSpaceWhereInput | boolean
    connect?: WorkSpaceWhereUniqueInput
    update?: XOR<XOR<WorkSpaceUpdateToOneWithWhereWithoutMonitor_configInput, WorkSpaceUpdateWithoutMonitor_configInput>, WorkSpaceUncheckedUpdateWithoutMonitor_configInput>
  }

  export type Monitor_HTTP_gPRC_configUpdateOneWithoutMonitor_configNestedInput = {
    create?: XOR<Monitor_HTTP_gPRC_configCreateWithoutMonitor_configInput, Monitor_HTTP_gPRC_configUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_HTTP_gPRC_configCreateOrConnectWithoutMonitor_configInput
    upsert?: Monitor_HTTP_gPRC_configUpsertWithoutMonitor_configInput
    disconnect?: Monitor_HTTP_gPRC_configWhereInput | boolean
    delete?: Monitor_HTTP_gPRC_configWhereInput | boolean
    connect?: Monitor_HTTP_gPRC_configWhereUniqueInput
    update?: XOR<XOR<Monitor_HTTP_gPRC_configUpdateToOneWithWhereWithoutMonitor_configInput, Monitor_HTTP_gPRC_configUpdateWithoutMonitor_configInput>, Monitor_HTTP_gPRC_configUncheckedUpdateWithoutMonitor_configInput>
  }

  export type Monitor_SSL_configUpdateOneWithoutMonitor_configNestedInput = {
    create?: XOR<Monitor_SSL_configCreateWithoutMonitor_configInput, Monitor_SSL_configUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_SSL_configCreateOrConnectWithoutMonitor_configInput
    upsert?: Monitor_SSL_configUpsertWithoutMonitor_configInput
    disconnect?: Monitor_SSL_configWhereInput | boolean
    delete?: Monitor_SSL_configWhereInput | boolean
    connect?: Monitor_SSL_configWhereUniqueInput
    update?: XOR<XOR<Monitor_SSL_configUpdateToOneWithWhereWithoutMonitor_configInput, Monitor_SSL_configUpdateWithoutMonitor_configInput>, Monitor_SSL_configUncheckedUpdateWithoutMonitor_configInput>
  }

  export type Monitor_System_componentsUpdateOneWithoutMonitor_configNestedInput = {
    create?: XOR<Monitor_System_componentsCreateWithoutMonitor_configInput, Monitor_System_componentsUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_System_componentsCreateOrConnectWithoutMonitor_configInput
    upsert?: Monitor_System_componentsUpsertWithoutMonitor_configInput
    disconnect?: Monitor_System_componentsWhereInput | boolean
    delete?: Monitor_System_componentsWhereInput | boolean
    connect?: Monitor_System_componentsWhereUniqueInput
    update?: XOR<XOR<Monitor_System_componentsUpdateToOneWithWhereWithoutMonitor_configInput, Monitor_System_componentsUpdateWithoutMonitor_configInput>, Monitor_System_componentsUncheckedUpdateWithoutMonitor_configInput>
  }

  export type teamUpdateOneWithoutMonitor_configNestedInput = {
    create?: XOR<teamCreateWithoutMonitor_configInput, teamUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: teamCreateOrConnectWithoutMonitor_configInput
    upsert?: teamUpsertWithoutMonitor_configInput
    disconnect?: boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutMonitor_configInput, teamUpdateWithoutMonitor_configInput>, teamUncheckedUpdateWithoutMonitor_configInput>
  }

  export type alertUpdateManyWithoutMonitor_configNestedInput = {
    create?: XOR<alertCreateWithoutMonitor_configInput, alertUncheckedCreateWithoutMonitor_configInput> | alertCreateWithoutMonitor_configInput[] | alertUncheckedCreateWithoutMonitor_configInput[]
    connectOrCreate?: alertCreateOrConnectWithoutMonitor_configInput | alertCreateOrConnectWithoutMonitor_configInput[]
    upsert?: alertUpsertWithWhereUniqueWithoutMonitor_configInput | alertUpsertWithWhereUniqueWithoutMonitor_configInput[]
    createMany?: alertCreateManyMonitor_configInputEnvelope
    set?: alertWhereUniqueInput | alertWhereUniqueInput[]
    disconnect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    delete?: alertWhereUniqueInput | alertWhereUniqueInput[]
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    update?: alertUpdateWithWhereUniqueWithoutMonitor_configInput | alertUpdateWithWhereUniqueWithoutMonitor_configInput[]
    updateMany?: alertUpdateManyWithWhereWithoutMonitor_configInput | alertUpdateManyWithWhereWithoutMonitor_configInput[]
    deleteMany?: alertScalarWhereInput | alertScalarWhereInput[]
  }

  export type Monitor_HTTP_gPRC_configUncheckedUpdateOneWithoutMonitor_configNestedInput = {
    create?: XOR<Monitor_HTTP_gPRC_configCreateWithoutMonitor_configInput, Monitor_HTTP_gPRC_configUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_HTTP_gPRC_configCreateOrConnectWithoutMonitor_configInput
    upsert?: Monitor_HTTP_gPRC_configUpsertWithoutMonitor_configInput
    disconnect?: Monitor_HTTP_gPRC_configWhereInput | boolean
    delete?: Monitor_HTTP_gPRC_configWhereInput | boolean
    connect?: Monitor_HTTP_gPRC_configWhereUniqueInput
    update?: XOR<XOR<Monitor_HTTP_gPRC_configUpdateToOneWithWhereWithoutMonitor_configInput, Monitor_HTTP_gPRC_configUpdateWithoutMonitor_configInput>, Monitor_HTTP_gPRC_configUncheckedUpdateWithoutMonitor_configInput>
  }

  export type Monitor_SSL_configUncheckedUpdateOneWithoutMonitor_configNestedInput = {
    create?: XOR<Monitor_SSL_configCreateWithoutMonitor_configInput, Monitor_SSL_configUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_SSL_configCreateOrConnectWithoutMonitor_configInput
    upsert?: Monitor_SSL_configUpsertWithoutMonitor_configInput
    disconnect?: Monitor_SSL_configWhereInput | boolean
    delete?: Monitor_SSL_configWhereInput | boolean
    connect?: Monitor_SSL_configWhereUniqueInput
    update?: XOR<XOR<Monitor_SSL_configUpdateToOneWithWhereWithoutMonitor_configInput, Monitor_SSL_configUpdateWithoutMonitor_configInput>, Monitor_SSL_configUncheckedUpdateWithoutMonitor_configInput>
  }

  export type Monitor_System_componentsUncheckedUpdateOneWithoutMonitor_configNestedInput = {
    create?: XOR<Monitor_System_componentsCreateWithoutMonitor_configInput, Monitor_System_componentsUncheckedCreateWithoutMonitor_configInput>
    connectOrCreate?: Monitor_System_componentsCreateOrConnectWithoutMonitor_configInput
    upsert?: Monitor_System_componentsUpsertWithoutMonitor_configInput
    disconnect?: Monitor_System_componentsWhereInput | boolean
    delete?: Monitor_System_componentsWhereInput | boolean
    connect?: Monitor_System_componentsWhereUniqueInput
    update?: XOR<XOR<Monitor_System_componentsUpdateToOneWithWhereWithoutMonitor_configInput, Monitor_System_componentsUpdateWithoutMonitor_configInput>, Monitor_System_componentsUncheckedUpdateWithoutMonitor_configInput>
  }

  export type alertUncheckedUpdateManyWithoutMonitor_configNestedInput = {
    create?: XOR<alertCreateWithoutMonitor_configInput, alertUncheckedCreateWithoutMonitor_configInput> | alertCreateWithoutMonitor_configInput[] | alertUncheckedCreateWithoutMonitor_configInput[]
    connectOrCreate?: alertCreateOrConnectWithoutMonitor_configInput | alertCreateOrConnectWithoutMonitor_configInput[]
    upsert?: alertUpsertWithWhereUniqueWithoutMonitor_configInput | alertUpsertWithWhereUniqueWithoutMonitor_configInput[]
    createMany?: alertCreateManyMonitor_configInputEnvelope
    set?: alertWhereUniqueInput | alertWhereUniqueInput[]
    disconnect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    delete?: alertWhereUniqueInput | alertWhereUniqueInput[]
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    update?: alertUpdateWithWhereUniqueWithoutMonitor_configInput | alertUpdateWithWhereUniqueWithoutMonitor_configInput[]
    updateMany?: alertUpdateManyWithWhereWithoutMonitor_configInput | alertUpdateManyWithWhereWithoutMonitor_configInput[]
    deleteMany?: alertScalarWhereInput | alertScalarWhereInput[]
  }

  export type Monitor_configCreateNestedOneWithoutMonitor_HTTP_gPRC_configInput = {
    create?: XOR<Monitor_configCreateWithoutMonitor_HTTP_gPRC_configInput, Monitor_configUncheckedCreateWithoutMonitor_HTTP_gPRC_configInput>
    connectOrCreate?: Monitor_configCreateOrConnectWithoutMonitor_HTTP_gPRC_configInput
    connect?: Monitor_configWhereUniqueInput
  }

  export type Monitor_configUpdateOneRequiredWithoutMonitor_HTTP_gPRC_configNestedInput = {
    create?: XOR<Monitor_configCreateWithoutMonitor_HTTP_gPRC_configInput, Monitor_configUncheckedCreateWithoutMonitor_HTTP_gPRC_configInput>
    connectOrCreate?: Monitor_configCreateOrConnectWithoutMonitor_HTTP_gPRC_configInput
    upsert?: Monitor_configUpsertWithoutMonitor_HTTP_gPRC_configInput
    connect?: Monitor_configWhereUniqueInput
    update?: XOR<XOR<Monitor_configUpdateToOneWithWhereWithoutMonitor_HTTP_gPRC_configInput, Monitor_configUpdateWithoutMonitor_HTTP_gPRC_configInput>, Monitor_configUncheckedUpdateWithoutMonitor_HTTP_gPRC_configInput>
  }

  export type Monitor_configCreateNestedOneWithoutMonitor_SSL_configInput = {
    create?: XOR<Monitor_configCreateWithoutMonitor_SSL_configInput, Monitor_configUncheckedCreateWithoutMonitor_SSL_configInput>
    connectOrCreate?: Monitor_configCreateOrConnectWithoutMonitor_SSL_configInput
    connect?: Monitor_configWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
    unset?: boolean
  }

  export type Monitor_configUpdateOneRequiredWithoutMonitor_SSL_configNestedInput = {
    create?: XOR<Monitor_configCreateWithoutMonitor_SSL_configInput, Monitor_configUncheckedCreateWithoutMonitor_SSL_configInput>
    connectOrCreate?: Monitor_configCreateOrConnectWithoutMonitor_SSL_configInput
    upsert?: Monitor_configUpsertWithoutMonitor_SSL_configInput
    connect?: Monitor_configWhereUniqueInput
    update?: XOR<XOR<Monitor_configUpdateToOneWithWhereWithoutMonitor_SSL_configInput, Monitor_configUpdateWithoutMonitor_SSL_configInput>, Monitor_configUncheckedUpdateWithoutMonitor_SSL_configInput>
  }

  export type Monitor_System_componentsCreatecomponents_listsInput = {
    set: string[]
  }

  export type Monitor_configCreateNestedOneWithoutMonitor_System_componentsInput = {
    create?: XOR<Monitor_configCreateWithoutMonitor_System_componentsInput, Monitor_configUncheckedCreateWithoutMonitor_System_componentsInput>
    connectOrCreate?: Monitor_configCreateOrConnectWithoutMonitor_System_componentsInput
    connect?: Monitor_configWhereUniqueInput
  }

  export type Monitor_System_componentsUpdatecomponents_listsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type Monitor_configUpdateOneRequiredWithoutMonitor_System_componentsNestedInput = {
    create?: XOR<Monitor_configCreateWithoutMonitor_System_componentsInput, Monitor_configUncheckedCreateWithoutMonitor_System_componentsInput>
    connectOrCreate?: Monitor_configCreateOrConnectWithoutMonitor_System_componentsInput
    upsert?: Monitor_configUpsertWithoutMonitor_System_componentsInput
    connect?: Monitor_configWhereUniqueInput
    update?: XOR<XOR<Monitor_configUpdateToOneWithWhereWithoutMonitor_System_componentsInput, Monitor_configUpdateWithoutMonitor_System_componentsInput>, Monitor_configUncheckedUpdateWithoutMonitor_System_componentsInput>
  }

  export type UserCreateNestedOneWithoutWorkspaceInput = {
    create?: XOR<UserCreateWithoutWorkspaceInput, UserUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspaceInput
    connect?: UserWhereUniqueInput
  }

  export type Monitor_configCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Monitor_configCreateWithoutWorkspaceInput, Monitor_configUncheckedCreateWithoutWorkspaceInput> | Monitor_configCreateWithoutWorkspaceInput[] | Monitor_configUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutWorkspaceInput | Monitor_configCreateOrConnectWithoutWorkspaceInput[]
    createMany?: Monitor_configCreateManyWorkspaceInputEnvelope
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
  }

  export type WorkSpace_usersCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkSpace_usersCreateWithoutWorkspaceInput, WorkSpace_usersUncheckedCreateWithoutWorkspaceInput> | WorkSpace_usersCreateWithoutWorkspaceInput[] | WorkSpace_usersUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkSpace_usersCreateOrConnectWithoutWorkspaceInput | WorkSpace_usersCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkSpace_usersCreateManyWorkspaceInputEnvelope
    connect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
  }

  export type invited_usersCreateNestedManyWithoutWokspaceInput = {
    create?: XOR<invited_usersCreateWithoutWokspaceInput, invited_usersUncheckedCreateWithoutWokspaceInput> | invited_usersCreateWithoutWokspaceInput[] | invited_usersUncheckedCreateWithoutWokspaceInput[]
    connectOrCreate?: invited_usersCreateOrConnectWithoutWokspaceInput | invited_usersCreateOrConnectWithoutWokspaceInput[]
    createMany?: invited_usersCreateManyWokspaceInputEnvelope
    connect?: invited_usersWhereUniqueInput | invited_usersWhereUniqueInput[]
  }

  export type teamCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<teamCreateWithoutWorkspaceInput, teamUncheckedCreateWithoutWorkspaceInput> | teamCreateWithoutWorkspaceInput[] | teamUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: teamCreateOrConnectWithoutWorkspaceInput | teamCreateOrConnectWithoutWorkspaceInput[]
    createMany?: teamCreateManyWorkspaceInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type team_memberCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<team_memberCreateWithoutWorkspaceInput, team_memberUncheckedCreateWithoutWorkspaceInput> | team_memberCreateWithoutWorkspaceInput[] | team_memberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutWorkspaceInput | team_memberCreateOrConnectWithoutWorkspaceInput[]
    createMany?: team_memberCreateManyWorkspaceInputEnvelope
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
  }

  export type alertCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<alertCreateWithoutWorkspaceInput, alertUncheckedCreateWithoutWorkspaceInput> | alertCreateWithoutWorkspaceInput[] | alertUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: alertCreateOrConnectWithoutWorkspaceInput | alertCreateOrConnectWithoutWorkspaceInput[]
    createMany?: alertCreateManyWorkspaceInputEnvelope
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
  }

  export type Monitor_configUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<Monitor_configCreateWithoutWorkspaceInput, Monitor_configUncheckedCreateWithoutWorkspaceInput> | Monitor_configCreateWithoutWorkspaceInput[] | Monitor_configUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutWorkspaceInput | Monitor_configCreateOrConnectWithoutWorkspaceInput[]
    createMany?: Monitor_configCreateManyWorkspaceInputEnvelope
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
  }

  export type WorkSpace_usersUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<WorkSpace_usersCreateWithoutWorkspaceInput, WorkSpace_usersUncheckedCreateWithoutWorkspaceInput> | WorkSpace_usersCreateWithoutWorkspaceInput[] | WorkSpace_usersUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkSpace_usersCreateOrConnectWithoutWorkspaceInput | WorkSpace_usersCreateOrConnectWithoutWorkspaceInput[]
    createMany?: WorkSpace_usersCreateManyWorkspaceInputEnvelope
    connect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
  }

  export type invited_usersUncheckedCreateNestedManyWithoutWokspaceInput = {
    create?: XOR<invited_usersCreateWithoutWokspaceInput, invited_usersUncheckedCreateWithoutWokspaceInput> | invited_usersCreateWithoutWokspaceInput[] | invited_usersUncheckedCreateWithoutWokspaceInput[]
    connectOrCreate?: invited_usersCreateOrConnectWithoutWokspaceInput | invited_usersCreateOrConnectWithoutWokspaceInput[]
    createMany?: invited_usersCreateManyWokspaceInputEnvelope
    connect?: invited_usersWhereUniqueInput | invited_usersWhereUniqueInput[]
  }

  export type teamUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<teamCreateWithoutWorkspaceInput, teamUncheckedCreateWithoutWorkspaceInput> | teamCreateWithoutWorkspaceInput[] | teamUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: teamCreateOrConnectWithoutWorkspaceInput | teamCreateOrConnectWithoutWorkspaceInput[]
    createMany?: teamCreateManyWorkspaceInputEnvelope
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
  }

  export type team_memberUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<team_memberCreateWithoutWorkspaceInput, team_memberUncheckedCreateWithoutWorkspaceInput> | team_memberCreateWithoutWorkspaceInput[] | team_memberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutWorkspaceInput | team_memberCreateOrConnectWithoutWorkspaceInput[]
    createMany?: team_memberCreateManyWorkspaceInputEnvelope
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
  }

  export type alertUncheckedCreateNestedManyWithoutWorkspaceInput = {
    create?: XOR<alertCreateWithoutWorkspaceInput, alertUncheckedCreateWithoutWorkspaceInput> | alertCreateWithoutWorkspaceInput[] | alertUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: alertCreateOrConnectWithoutWorkspaceInput | alertCreateOrConnectWithoutWorkspaceInput[]
    createMany?: alertCreateManyWorkspaceInputEnvelope
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWorkspaceNestedInput = {
    create?: XOR<UserCreateWithoutWorkspaceInput, UserUncheckedCreateWithoutWorkspaceInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspaceInput
    upsert?: UserUpsertWithoutWorkspaceInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspaceInput, UserUpdateWithoutWorkspaceInput>, UserUncheckedUpdateWithoutWorkspaceInput>
  }

  export type Monitor_configUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Monitor_configCreateWithoutWorkspaceInput, Monitor_configUncheckedCreateWithoutWorkspaceInput> | Monitor_configCreateWithoutWorkspaceInput[] | Monitor_configUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutWorkspaceInput | Monitor_configCreateOrConnectWithoutWorkspaceInput[]
    upsert?: Monitor_configUpsertWithWhereUniqueWithoutWorkspaceInput | Monitor_configUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: Monitor_configCreateManyWorkspaceInputEnvelope
    set?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    disconnect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    delete?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    update?: Monitor_configUpdateWithWhereUniqueWithoutWorkspaceInput | Monitor_configUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: Monitor_configUpdateManyWithWhereWithoutWorkspaceInput | Monitor_configUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: Monitor_configScalarWhereInput | Monitor_configScalarWhereInput[]
  }

  export type WorkSpace_usersUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkSpace_usersCreateWithoutWorkspaceInput, WorkSpace_usersUncheckedCreateWithoutWorkspaceInput> | WorkSpace_usersCreateWithoutWorkspaceInput[] | WorkSpace_usersUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkSpace_usersCreateOrConnectWithoutWorkspaceInput | WorkSpace_usersCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkSpace_usersUpsertWithWhereUniqueWithoutWorkspaceInput | WorkSpace_usersUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkSpace_usersCreateManyWorkspaceInputEnvelope
    set?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    disconnect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    delete?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    connect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    update?: WorkSpace_usersUpdateWithWhereUniqueWithoutWorkspaceInput | WorkSpace_usersUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkSpace_usersUpdateManyWithWhereWithoutWorkspaceInput | WorkSpace_usersUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkSpace_usersScalarWhereInput | WorkSpace_usersScalarWhereInput[]
  }

  export type invited_usersUpdateManyWithoutWokspaceNestedInput = {
    create?: XOR<invited_usersCreateWithoutWokspaceInput, invited_usersUncheckedCreateWithoutWokspaceInput> | invited_usersCreateWithoutWokspaceInput[] | invited_usersUncheckedCreateWithoutWokspaceInput[]
    connectOrCreate?: invited_usersCreateOrConnectWithoutWokspaceInput | invited_usersCreateOrConnectWithoutWokspaceInput[]
    upsert?: invited_usersUpsertWithWhereUniqueWithoutWokspaceInput | invited_usersUpsertWithWhereUniqueWithoutWokspaceInput[]
    createMany?: invited_usersCreateManyWokspaceInputEnvelope
    set?: invited_usersWhereUniqueInput | invited_usersWhereUniqueInput[]
    disconnect?: invited_usersWhereUniqueInput | invited_usersWhereUniqueInput[]
    delete?: invited_usersWhereUniqueInput | invited_usersWhereUniqueInput[]
    connect?: invited_usersWhereUniqueInput | invited_usersWhereUniqueInput[]
    update?: invited_usersUpdateWithWhereUniqueWithoutWokspaceInput | invited_usersUpdateWithWhereUniqueWithoutWokspaceInput[]
    updateMany?: invited_usersUpdateManyWithWhereWithoutWokspaceInput | invited_usersUpdateManyWithWhereWithoutWokspaceInput[]
    deleteMany?: invited_usersScalarWhereInput | invited_usersScalarWhereInput[]
  }

  export type teamUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<teamCreateWithoutWorkspaceInput, teamUncheckedCreateWithoutWorkspaceInput> | teamCreateWithoutWorkspaceInput[] | teamUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: teamCreateOrConnectWithoutWorkspaceInput | teamCreateOrConnectWithoutWorkspaceInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutWorkspaceInput | teamUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: teamCreateManyWorkspaceInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutWorkspaceInput | teamUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: teamUpdateManyWithWhereWithoutWorkspaceInput | teamUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type team_memberUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<team_memberCreateWithoutWorkspaceInput, team_memberUncheckedCreateWithoutWorkspaceInput> | team_memberCreateWithoutWorkspaceInput[] | team_memberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutWorkspaceInput | team_memberCreateOrConnectWithoutWorkspaceInput[]
    upsert?: team_memberUpsertWithWhereUniqueWithoutWorkspaceInput | team_memberUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: team_memberCreateManyWorkspaceInputEnvelope
    set?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    disconnect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    delete?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    update?: team_memberUpdateWithWhereUniqueWithoutWorkspaceInput | team_memberUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: team_memberUpdateManyWithWhereWithoutWorkspaceInput | team_memberUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: team_memberScalarWhereInput | team_memberScalarWhereInput[]
  }

  export type alertUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<alertCreateWithoutWorkspaceInput, alertUncheckedCreateWithoutWorkspaceInput> | alertCreateWithoutWorkspaceInput[] | alertUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: alertCreateOrConnectWithoutWorkspaceInput | alertCreateOrConnectWithoutWorkspaceInput[]
    upsert?: alertUpsertWithWhereUniqueWithoutWorkspaceInput | alertUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: alertCreateManyWorkspaceInputEnvelope
    set?: alertWhereUniqueInput | alertWhereUniqueInput[]
    disconnect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    delete?: alertWhereUniqueInput | alertWhereUniqueInput[]
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    update?: alertUpdateWithWhereUniqueWithoutWorkspaceInput | alertUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: alertUpdateManyWithWhereWithoutWorkspaceInput | alertUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: alertScalarWhereInput | alertScalarWhereInput[]
  }

  export type Monitor_configUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<Monitor_configCreateWithoutWorkspaceInput, Monitor_configUncheckedCreateWithoutWorkspaceInput> | Monitor_configCreateWithoutWorkspaceInput[] | Monitor_configUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutWorkspaceInput | Monitor_configCreateOrConnectWithoutWorkspaceInput[]
    upsert?: Monitor_configUpsertWithWhereUniqueWithoutWorkspaceInput | Monitor_configUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: Monitor_configCreateManyWorkspaceInputEnvelope
    set?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    disconnect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    delete?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    update?: Monitor_configUpdateWithWhereUniqueWithoutWorkspaceInput | Monitor_configUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: Monitor_configUpdateManyWithWhereWithoutWorkspaceInput | Monitor_configUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: Monitor_configScalarWhereInput | Monitor_configScalarWhereInput[]
  }

  export type WorkSpace_usersUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<WorkSpace_usersCreateWithoutWorkspaceInput, WorkSpace_usersUncheckedCreateWithoutWorkspaceInput> | WorkSpace_usersCreateWithoutWorkspaceInput[] | WorkSpace_usersUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: WorkSpace_usersCreateOrConnectWithoutWorkspaceInput | WorkSpace_usersCreateOrConnectWithoutWorkspaceInput[]
    upsert?: WorkSpace_usersUpsertWithWhereUniqueWithoutWorkspaceInput | WorkSpace_usersUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: WorkSpace_usersCreateManyWorkspaceInputEnvelope
    set?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    disconnect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    delete?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    connect?: WorkSpace_usersWhereUniqueInput | WorkSpace_usersWhereUniqueInput[]
    update?: WorkSpace_usersUpdateWithWhereUniqueWithoutWorkspaceInput | WorkSpace_usersUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: WorkSpace_usersUpdateManyWithWhereWithoutWorkspaceInput | WorkSpace_usersUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: WorkSpace_usersScalarWhereInput | WorkSpace_usersScalarWhereInput[]
  }

  export type invited_usersUncheckedUpdateManyWithoutWokspaceNestedInput = {
    create?: XOR<invited_usersCreateWithoutWokspaceInput, invited_usersUncheckedCreateWithoutWokspaceInput> | invited_usersCreateWithoutWokspaceInput[] | invited_usersUncheckedCreateWithoutWokspaceInput[]
    connectOrCreate?: invited_usersCreateOrConnectWithoutWokspaceInput | invited_usersCreateOrConnectWithoutWokspaceInput[]
    upsert?: invited_usersUpsertWithWhereUniqueWithoutWokspaceInput | invited_usersUpsertWithWhereUniqueWithoutWokspaceInput[]
    createMany?: invited_usersCreateManyWokspaceInputEnvelope
    set?: invited_usersWhereUniqueInput | invited_usersWhereUniqueInput[]
    disconnect?: invited_usersWhereUniqueInput | invited_usersWhereUniqueInput[]
    delete?: invited_usersWhereUniqueInput | invited_usersWhereUniqueInput[]
    connect?: invited_usersWhereUniqueInput | invited_usersWhereUniqueInput[]
    update?: invited_usersUpdateWithWhereUniqueWithoutWokspaceInput | invited_usersUpdateWithWhereUniqueWithoutWokspaceInput[]
    updateMany?: invited_usersUpdateManyWithWhereWithoutWokspaceInput | invited_usersUpdateManyWithWhereWithoutWokspaceInput[]
    deleteMany?: invited_usersScalarWhereInput | invited_usersScalarWhereInput[]
  }

  export type teamUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<teamCreateWithoutWorkspaceInput, teamUncheckedCreateWithoutWorkspaceInput> | teamCreateWithoutWorkspaceInput[] | teamUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: teamCreateOrConnectWithoutWorkspaceInput | teamCreateOrConnectWithoutWorkspaceInput[]
    upsert?: teamUpsertWithWhereUniqueWithoutWorkspaceInput | teamUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: teamCreateManyWorkspaceInputEnvelope
    set?: teamWhereUniqueInput | teamWhereUniqueInput[]
    disconnect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    delete?: teamWhereUniqueInput | teamWhereUniqueInput[]
    connect?: teamWhereUniqueInput | teamWhereUniqueInput[]
    update?: teamUpdateWithWhereUniqueWithoutWorkspaceInput | teamUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: teamUpdateManyWithWhereWithoutWorkspaceInput | teamUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: teamScalarWhereInput | teamScalarWhereInput[]
  }

  export type team_memberUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<team_memberCreateWithoutWorkspaceInput, team_memberUncheckedCreateWithoutWorkspaceInput> | team_memberCreateWithoutWorkspaceInput[] | team_memberUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutWorkspaceInput | team_memberCreateOrConnectWithoutWorkspaceInput[]
    upsert?: team_memberUpsertWithWhereUniqueWithoutWorkspaceInput | team_memberUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: team_memberCreateManyWorkspaceInputEnvelope
    set?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    disconnect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    delete?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    update?: team_memberUpdateWithWhereUniqueWithoutWorkspaceInput | team_memberUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: team_memberUpdateManyWithWhereWithoutWorkspaceInput | team_memberUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: team_memberScalarWhereInput | team_memberScalarWhereInput[]
  }

  export type alertUncheckedUpdateManyWithoutWorkspaceNestedInput = {
    create?: XOR<alertCreateWithoutWorkspaceInput, alertUncheckedCreateWithoutWorkspaceInput> | alertCreateWithoutWorkspaceInput[] | alertUncheckedCreateWithoutWorkspaceInput[]
    connectOrCreate?: alertCreateOrConnectWithoutWorkspaceInput | alertCreateOrConnectWithoutWorkspaceInput[]
    upsert?: alertUpsertWithWhereUniqueWithoutWorkspaceInput | alertUpsertWithWhereUniqueWithoutWorkspaceInput[]
    createMany?: alertCreateManyWorkspaceInputEnvelope
    set?: alertWhereUniqueInput | alertWhereUniqueInput[]
    disconnect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    delete?: alertWhereUniqueInput | alertWhereUniqueInput[]
    connect?: alertWhereUniqueInput | alertWhereUniqueInput[]
    update?: alertUpdateWithWhereUniqueWithoutWorkspaceInput | alertUpdateWithWhereUniqueWithoutWorkspaceInput[]
    updateMany?: alertUpdateManyWithWhereWithoutWorkspaceInput | alertUpdateManyWithWhereWithoutWorkspaceInput[]
    deleteMany?: alertScalarWhereInput | alertScalarWhereInput[]
  }

  export type WorkSpaceCreateNestedOneWithoutInvited_usersInput = {
    create?: XOR<WorkSpaceCreateWithoutInvited_usersInput, WorkSpaceUncheckedCreateWithoutInvited_usersInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutInvited_usersInput
    connect?: WorkSpaceWhereUniqueInput
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type EnumstatusFieldUpdateOperationsInput = {
    set?: $Enums.status
  }

  export type WorkSpaceUpdateOneRequiredWithoutInvited_usersNestedInput = {
    create?: XOR<WorkSpaceCreateWithoutInvited_usersInput, WorkSpaceUncheckedCreateWithoutInvited_usersInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutInvited_usersInput
    upsert?: WorkSpaceUpsertWithoutInvited_usersInput
    connect?: WorkSpaceWhereUniqueInput
    update?: XOR<XOR<WorkSpaceUpdateToOneWithWhereWithoutInvited_usersInput, WorkSpaceUpdateWithoutInvited_usersInput>, WorkSpaceUncheckedUpdateWithoutInvited_usersInput>
  }

  export type UserCreateNestedOneWithoutWorkspace_usersInput = {
    create?: XOR<UserCreateWithoutWorkspace_usersInput, UserUncheckedCreateWithoutWorkspace_usersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspace_usersInput
    connect?: UserWhereUniqueInput
  }

  export type WorkSpaceCreateNestedOneWithoutWorkspace_usersInput = {
    create?: XOR<WorkSpaceCreateWithoutWorkspace_usersInput, WorkSpaceUncheckedCreateWithoutWorkspace_usersInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutWorkspace_usersInput
    connect?: WorkSpaceWhereUniqueInput
  }

  export type team_memberCreateNestedManyWithoutWorkspace_userInput = {
    create?: XOR<team_memberCreateWithoutWorkspace_userInput, team_memberUncheckedCreateWithoutWorkspace_userInput> | team_memberCreateWithoutWorkspace_userInput[] | team_memberUncheckedCreateWithoutWorkspace_userInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutWorkspace_userInput | team_memberCreateOrConnectWithoutWorkspace_userInput[]
    createMany?: team_memberCreateManyWorkspace_userInputEnvelope
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
  }

  export type team_memberUncheckedCreateNestedManyWithoutWorkspace_userInput = {
    create?: XOR<team_memberCreateWithoutWorkspace_userInput, team_memberUncheckedCreateWithoutWorkspace_userInput> | team_memberCreateWithoutWorkspace_userInput[] | team_memberUncheckedCreateWithoutWorkspace_userInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutWorkspace_userInput | team_memberCreateOrConnectWithoutWorkspace_userInput[]
    createMany?: team_memberCreateManyWorkspace_userInputEnvelope
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutWorkspace_usersNestedInput = {
    create?: XOR<UserCreateWithoutWorkspace_usersInput, UserUncheckedCreateWithoutWorkspace_usersInput>
    connectOrCreate?: UserCreateOrConnectWithoutWorkspace_usersInput
    upsert?: UserUpsertWithoutWorkspace_usersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkspace_usersInput, UserUpdateWithoutWorkspace_usersInput>, UserUncheckedUpdateWithoutWorkspace_usersInput>
  }

  export type WorkSpaceUpdateOneRequiredWithoutWorkspace_usersNestedInput = {
    create?: XOR<WorkSpaceCreateWithoutWorkspace_usersInput, WorkSpaceUncheckedCreateWithoutWorkspace_usersInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutWorkspace_usersInput
    upsert?: WorkSpaceUpsertWithoutWorkspace_usersInput
    connect?: WorkSpaceWhereUniqueInput
    update?: XOR<XOR<WorkSpaceUpdateToOneWithWhereWithoutWorkspace_usersInput, WorkSpaceUpdateWithoutWorkspace_usersInput>, WorkSpaceUncheckedUpdateWithoutWorkspace_usersInput>
  }

  export type team_memberUpdateManyWithoutWorkspace_userNestedInput = {
    create?: XOR<team_memberCreateWithoutWorkspace_userInput, team_memberUncheckedCreateWithoutWorkspace_userInput> | team_memberCreateWithoutWorkspace_userInput[] | team_memberUncheckedCreateWithoutWorkspace_userInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutWorkspace_userInput | team_memberCreateOrConnectWithoutWorkspace_userInput[]
    upsert?: team_memberUpsertWithWhereUniqueWithoutWorkspace_userInput | team_memberUpsertWithWhereUniqueWithoutWorkspace_userInput[]
    createMany?: team_memberCreateManyWorkspace_userInputEnvelope
    set?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    disconnect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    delete?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    update?: team_memberUpdateWithWhereUniqueWithoutWorkspace_userInput | team_memberUpdateWithWhereUniqueWithoutWorkspace_userInput[]
    updateMany?: team_memberUpdateManyWithWhereWithoutWorkspace_userInput | team_memberUpdateManyWithWhereWithoutWorkspace_userInput[]
    deleteMany?: team_memberScalarWhereInput | team_memberScalarWhereInput[]
  }

  export type team_memberUncheckedUpdateManyWithoutWorkspace_userNestedInput = {
    create?: XOR<team_memberCreateWithoutWorkspace_userInput, team_memberUncheckedCreateWithoutWorkspace_userInput> | team_memberCreateWithoutWorkspace_userInput[] | team_memberUncheckedCreateWithoutWorkspace_userInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutWorkspace_userInput | team_memberCreateOrConnectWithoutWorkspace_userInput[]
    upsert?: team_memberUpsertWithWhereUniqueWithoutWorkspace_userInput | team_memberUpsertWithWhereUniqueWithoutWorkspace_userInput[]
    createMany?: team_memberCreateManyWorkspace_userInputEnvelope
    set?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    disconnect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    delete?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    update?: team_memberUpdateWithWhereUniqueWithoutWorkspace_userInput | team_memberUpdateWithWhereUniqueWithoutWorkspace_userInput[]
    updateMany?: team_memberUpdateManyWithWhereWithoutWorkspace_userInput | team_memberUpdateManyWithWhereWithoutWorkspace_userInput[]
    deleteMany?: team_memberScalarWhereInput | team_memberScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTeamsInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    connect?: UserWhereUniqueInput
  }

  export type WorkSpaceCreateNestedOneWithoutTeamInput = {
    create?: XOR<WorkSpaceCreateWithoutTeamInput, WorkSpaceUncheckedCreateWithoutTeamInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutTeamInput
    connect?: WorkSpaceWhereUniqueInput
  }

  export type team_memberCreateNestedManyWithoutTeamInput = {
    create?: XOR<team_memberCreateWithoutTeamInput, team_memberUncheckedCreateWithoutTeamInput> | team_memberCreateWithoutTeamInput[] | team_memberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutTeamInput | team_memberCreateOrConnectWithoutTeamInput[]
    createMany?: team_memberCreateManyTeamInputEnvelope
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
  }

  export type Monitor_configCreateNestedManyWithoutTeamInput = {
    create?: XOR<Monitor_configCreateWithoutTeamInput, Monitor_configUncheckedCreateWithoutTeamInput> | Monitor_configCreateWithoutTeamInput[] | Monitor_configUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutTeamInput | Monitor_configCreateOrConnectWithoutTeamInput[]
    createMany?: Monitor_configCreateManyTeamInputEnvelope
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
  }

  export type team_escalationpolicyCreateNestedManyWithoutTeamInput = {
    create?: XOR<team_escalationpolicyCreateWithoutTeamInput, team_escalationpolicyUncheckedCreateWithoutTeamInput> | team_escalationpolicyCreateWithoutTeamInput[] | team_escalationpolicyUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_escalationpolicyCreateOrConnectWithoutTeamInput | team_escalationpolicyCreateOrConnectWithoutTeamInput[]
    createMany?: team_escalationpolicyCreateManyTeamInputEnvelope
    connect?: team_escalationpolicyWhereUniqueInput | team_escalationpolicyWhereUniqueInput[]
  }

  export type escalation_policy_rulesCreateNestedManyWithoutTeamInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutTeamInput, escalation_policy_rulesUncheckedCreateWithoutTeamInput> | escalation_policy_rulesCreateWithoutTeamInput[] | escalation_policy_rulesUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutTeamInput | escalation_policy_rulesCreateOrConnectWithoutTeamInput[]
    createMany?: escalation_policy_rulesCreateManyTeamInputEnvelope
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
  }

  export type team_scheduleCreateNestedManyWithoutTeamInput = {
    create?: XOR<team_scheduleCreateWithoutTeamInput, team_scheduleUncheckedCreateWithoutTeamInput> | team_scheduleCreateWithoutTeamInput[] | team_scheduleUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_scheduleCreateOrConnectWithoutTeamInput | team_scheduleCreateOrConnectWithoutTeamInput[]
    createMany?: team_scheduleCreateManyTeamInputEnvelope
    connect?: team_scheduleWhereUniqueInput | team_scheduleWhereUniqueInput[]
  }

  export type team_memberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<team_memberCreateWithoutTeamInput, team_memberUncheckedCreateWithoutTeamInput> | team_memberCreateWithoutTeamInput[] | team_memberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutTeamInput | team_memberCreateOrConnectWithoutTeamInput[]
    createMany?: team_memberCreateManyTeamInputEnvelope
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
  }

  export type Monitor_configUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<Monitor_configCreateWithoutTeamInput, Monitor_configUncheckedCreateWithoutTeamInput> | Monitor_configCreateWithoutTeamInput[] | Monitor_configUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutTeamInput | Monitor_configCreateOrConnectWithoutTeamInput[]
    createMany?: Monitor_configCreateManyTeamInputEnvelope
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
  }

  export type team_escalationpolicyUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<team_escalationpolicyCreateWithoutTeamInput, team_escalationpolicyUncheckedCreateWithoutTeamInput> | team_escalationpolicyCreateWithoutTeamInput[] | team_escalationpolicyUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_escalationpolicyCreateOrConnectWithoutTeamInput | team_escalationpolicyCreateOrConnectWithoutTeamInput[]
    createMany?: team_escalationpolicyCreateManyTeamInputEnvelope
    connect?: team_escalationpolicyWhereUniqueInput | team_escalationpolicyWhereUniqueInput[]
  }

  export type escalation_policy_rulesUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutTeamInput, escalation_policy_rulesUncheckedCreateWithoutTeamInput> | escalation_policy_rulesCreateWithoutTeamInput[] | escalation_policy_rulesUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutTeamInput | escalation_policy_rulesCreateOrConnectWithoutTeamInput[]
    createMany?: escalation_policy_rulesCreateManyTeamInputEnvelope
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
  }

  export type team_scheduleUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<team_scheduleCreateWithoutTeamInput, team_scheduleUncheckedCreateWithoutTeamInput> | team_scheduleCreateWithoutTeamInput[] | team_scheduleUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_scheduleCreateOrConnectWithoutTeamInput | team_scheduleCreateOrConnectWithoutTeamInput[]
    createMany?: team_scheduleCreateManyTeamInputEnvelope
    connect?: team_scheduleWhereUniqueInput | team_scheduleWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsInput
    upsert?: UserUpsertWithoutTeamsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamsInput, UserUpdateWithoutTeamsInput>, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type WorkSpaceUpdateOneRequiredWithoutTeamNestedInput = {
    create?: XOR<WorkSpaceCreateWithoutTeamInput, WorkSpaceUncheckedCreateWithoutTeamInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutTeamInput
    upsert?: WorkSpaceUpsertWithoutTeamInput
    connect?: WorkSpaceWhereUniqueInput
    update?: XOR<XOR<WorkSpaceUpdateToOneWithWhereWithoutTeamInput, WorkSpaceUpdateWithoutTeamInput>, WorkSpaceUncheckedUpdateWithoutTeamInput>
  }

  export type team_memberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<team_memberCreateWithoutTeamInput, team_memberUncheckedCreateWithoutTeamInput> | team_memberCreateWithoutTeamInput[] | team_memberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutTeamInput | team_memberCreateOrConnectWithoutTeamInput[]
    upsert?: team_memberUpsertWithWhereUniqueWithoutTeamInput | team_memberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: team_memberCreateManyTeamInputEnvelope
    set?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    disconnect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    delete?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    update?: team_memberUpdateWithWhereUniqueWithoutTeamInput | team_memberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: team_memberUpdateManyWithWhereWithoutTeamInput | team_memberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: team_memberScalarWhereInput | team_memberScalarWhereInput[]
  }

  export type Monitor_configUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Monitor_configCreateWithoutTeamInput, Monitor_configUncheckedCreateWithoutTeamInput> | Monitor_configCreateWithoutTeamInput[] | Monitor_configUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutTeamInput | Monitor_configCreateOrConnectWithoutTeamInput[]
    upsert?: Monitor_configUpsertWithWhereUniqueWithoutTeamInput | Monitor_configUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: Monitor_configCreateManyTeamInputEnvelope
    set?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    disconnect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    delete?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    update?: Monitor_configUpdateWithWhereUniqueWithoutTeamInput | Monitor_configUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: Monitor_configUpdateManyWithWhereWithoutTeamInput | Monitor_configUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: Monitor_configScalarWhereInput | Monitor_configScalarWhereInput[]
  }

  export type team_escalationpolicyUpdateManyWithoutTeamNestedInput = {
    create?: XOR<team_escalationpolicyCreateWithoutTeamInput, team_escalationpolicyUncheckedCreateWithoutTeamInput> | team_escalationpolicyCreateWithoutTeamInput[] | team_escalationpolicyUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_escalationpolicyCreateOrConnectWithoutTeamInput | team_escalationpolicyCreateOrConnectWithoutTeamInput[]
    upsert?: team_escalationpolicyUpsertWithWhereUniqueWithoutTeamInput | team_escalationpolicyUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: team_escalationpolicyCreateManyTeamInputEnvelope
    set?: team_escalationpolicyWhereUniqueInput | team_escalationpolicyWhereUniqueInput[]
    disconnect?: team_escalationpolicyWhereUniqueInput | team_escalationpolicyWhereUniqueInput[]
    delete?: team_escalationpolicyWhereUniqueInput | team_escalationpolicyWhereUniqueInput[]
    connect?: team_escalationpolicyWhereUniqueInput | team_escalationpolicyWhereUniqueInput[]
    update?: team_escalationpolicyUpdateWithWhereUniqueWithoutTeamInput | team_escalationpolicyUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: team_escalationpolicyUpdateManyWithWhereWithoutTeamInput | team_escalationpolicyUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: team_escalationpolicyScalarWhereInput | team_escalationpolicyScalarWhereInput[]
  }

  export type escalation_policy_rulesUpdateManyWithoutTeamNestedInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutTeamInput, escalation_policy_rulesUncheckedCreateWithoutTeamInput> | escalation_policy_rulesCreateWithoutTeamInput[] | escalation_policy_rulesUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutTeamInput | escalation_policy_rulesCreateOrConnectWithoutTeamInput[]
    upsert?: escalation_policy_rulesUpsertWithWhereUniqueWithoutTeamInput | escalation_policy_rulesUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: escalation_policy_rulesCreateManyTeamInputEnvelope
    set?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    disconnect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    delete?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    update?: escalation_policy_rulesUpdateWithWhereUniqueWithoutTeamInput | escalation_policy_rulesUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: escalation_policy_rulesUpdateManyWithWhereWithoutTeamInput | escalation_policy_rulesUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: escalation_policy_rulesScalarWhereInput | escalation_policy_rulesScalarWhereInput[]
  }

  export type team_scheduleUpdateManyWithoutTeamNestedInput = {
    create?: XOR<team_scheduleCreateWithoutTeamInput, team_scheduleUncheckedCreateWithoutTeamInput> | team_scheduleCreateWithoutTeamInput[] | team_scheduleUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_scheduleCreateOrConnectWithoutTeamInput | team_scheduleCreateOrConnectWithoutTeamInput[]
    upsert?: team_scheduleUpsertWithWhereUniqueWithoutTeamInput | team_scheduleUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: team_scheduleCreateManyTeamInputEnvelope
    set?: team_scheduleWhereUniqueInput | team_scheduleWhereUniqueInput[]
    disconnect?: team_scheduleWhereUniqueInput | team_scheduleWhereUniqueInput[]
    delete?: team_scheduleWhereUniqueInput | team_scheduleWhereUniqueInput[]
    connect?: team_scheduleWhereUniqueInput | team_scheduleWhereUniqueInput[]
    update?: team_scheduleUpdateWithWhereUniqueWithoutTeamInput | team_scheduleUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: team_scheduleUpdateManyWithWhereWithoutTeamInput | team_scheduleUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: team_scheduleScalarWhereInput | team_scheduleScalarWhereInput[]
  }

  export type team_memberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<team_memberCreateWithoutTeamInput, team_memberUncheckedCreateWithoutTeamInput> | team_memberCreateWithoutTeamInput[] | team_memberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_memberCreateOrConnectWithoutTeamInput | team_memberCreateOrConnectWithoutTeamInput[]
    upsert?: team_memberUpsertWithWhereUniqueWithoutTeamInput | team_memberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: team_memberCreateManyTeamInputEnvelope
    set?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    disconnect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    delete?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    connect?: team_memberWhereUniqueInput | team_memberWhereUniqueInput[]
    update?: team_memberUpdateWithWhereUniqueWithoutTeamInput | team_memberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: team_memberUpdateManyWithWhereWithoutTeamInput | team_memberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: team_memberScalarWhereInput | team_memberScalarWhereInput[]
  }

  export type Monitor_configUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<Monitor_configCreateWithoutTeamInput, Monitor_configUncheckedCreateWithoutTeamInput> | Monitor_configCreateWithoutTeamInput[] | Monitor_configUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: Monitor_configCreateOrConnectWithoutTeamInput | Monitor_configCreateOrConnectWithoutTeamInput[]
    upsert?: Monitor_configUpsertWithWhereUniqueWithoutTeamInput | Monitor_configUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: Monitor_configCreateManyTeamInputEnvelope
    set?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    disconnect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    delete?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    connect?: Monitor_configWhereUniqueInput | Monitor_configWhereUniqueInput[]
    update?: Monitor_configUpdateWithWhereUniqueWithoutTeamInput | Monitor_configUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: Monitor_configUpdateManyWithWhereWithoutTeamInput | Monitor_configUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: Monitor_configScalarWhereInput | Monitor_configScalarWhereInput[]
  }

  export type team_escalationpolicyUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<team_escalationpolicyCreateWithoutTeamInput, team_escalationpolicyUncheckedCreateWithoutTeamInput> | team_escalationpolicyCreateWithoutTeamInput[] | team_escalationpolicyUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_escalationpolicyCreateOrConnectWithoutTeamInput | team_escalationpolicyCreateOrConnectWithoutTeamInput[]
    upsert?: team_escalationpolicyUpsertWithWhereUniqueWithoutTeamInput | team_escalationpolicyUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: team_escalationpolicyCreateManyTeamInputEnvelope
    set?: team_escalationpolicyWhereUniqueInput | team_escalationpolicyWhereUniqueInput[]
    disconnect?: team_escalationpolicyWhereUniqueInput | team_escalationpolicyWhereUniqueInput[]
    delete?: team_escalationpolicyWhereUniqueInput | team_escalationpolicyWhereUniqueInput[]
    connect?: team_escalationpolicyWhereUniqueInput | team_escalationpolicyWhereUniqueInput[]
    update?: team_escalationpolicyUpdateWithWhereUniqueWithoutTeamInput | team_escalationpolicyUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: team_escalationpolicyUpdateManyWithWhereWithoutTeamInput | team_escalationpolicyUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: team_escalationpolicyScalarWhereInput | team_escalationpolicyScalarWhereInput[]
  }

  export type escalation_policy_rulesUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutTeamInput, escalation_policy_rulesUncheckedCreateWithoutTeamInput> | escalation_policy_rulesCreateWithoutTeamInput[] | escalation_policy_rulesUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutTeamInput | escalation_policy_rulesCreateOrConnectWithoutTeamInput[]
    upsert?: escalation_policy_rulesUpsertWithWhereUniqueWithoutTeamInput | escalation_policy_rulesUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: escalation_policy_rulesCreateManyTeamInputEnvelope
    set?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    disconnect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    delete?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    update?: escalation_policy_rulesUpdateWithWhereUniqueWithoutTeamInput | escalation_policy_rulesUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: escalation_policy_rulesUpdateManyWithWhereWithoutTeamInput | escalation_policy_rulesUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: escalation_policy_rulesScalarWhereInput | escalation_policy_rulesScalarWhereInput[]
  }

  export type team_scheduleUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<team_scheduleCreateWithoutTeamInput, team_scheduleUncheckedCreateWithoutTeamInput> | team_scheduleCreateWithoutTeamInput[] | team_scheduleUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: team_scheduleCreateOrConnectWithoutTeamInput | team_scheduleCreateOrConnectWithoutTeamInput[]
    upsert?: team_scheduleUpsertWithWhereUniqueWithoutTeamInput | team_scheduleUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: team_scheduleCreateManyTeamInputEnvelope
    set?: team_scheduleWhereUniqueInput | team_scheduleWhereUniqueInput[]
    disconnect?: team_scheduleWhereUniqueInput | team_scheduleWhereUniqueInput[]
    delete?: team_scheduleWhereUniqueInput | team_scheduleWhereUniqueInput[]
    connect?: team_scheduleWhereUniqueInput | team_scheduleWhereUniqueInput[]
    update?: team_scheduleUpdateWithWhereUniqueWithoutTeamInput | team_scheduleUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: team_scheduleUpdateManyWithWhereWithoutTeamInput | team_scheduleUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: team_scheduleScalarWhereInput | team_scheduleScalarWhereInput[]
  }

  export type teamCreateNestedOneWithoutTeam_memberInput = {
    create?: XOR<teamCreateWithoutTeam_memberInput, teamUncheckedCreateWithoutTeam_memberInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeam_memberInput
    connect?: teamWhereUniqueInput
  }

  export type WorkSpace_usersCreateNestedOneWithoutTeam_memberInput = {
    create?: XOR<WorkSpace_usersCreateWithoutTeam_memberInput, WorkSpace_usersUncheckedCreateWithoutTeam_memberInput>
    connectOrCreate?: WorkSpace_usersCreateOrConnectWithoutTeam_memberInput
    connect?: WorkSpace_usersWhereUniqueInput
  }

  export type WorkSpaceCreateNestedOneWithoutTeam_memberInput = {
    create?: XOR<WorkSpaceCreateWithoutTeam_memberInput, WorkSpaceUncheckedCreateWithoutTeam_memberInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutTeam_memberInput
    connect?: WorkSpaceWhereUniqueInput
  }

  export type teamUpdateOneRequiredWithoutTeam_memberNestedInput = {
    create?: XOR<teamCreateWithoutTeam_memberInput, teamUncheckedCreateWithoutTeam_memberInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeam_memberInput
    upsert?: teamUpsertWithoutTeam_memberInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutTeam_memberInput, teamUpdateWithoutTeam_memberInput>, teamUncheckedUpdateWithoutTeam_memberInput>
  }

  export type WorkSpace_usersUpdateOneRequiredWithoutTeam_memberNestedInput = {
    create?: XOR<WorkSpace_usersCreateWithoutTeam_memberInput, WorkSpace_usersUncheckedCreateWithoutTeam_memberInput>
    connectOrCreate?: WorkSpace_usersCreateOrConnectWithoutTeam_memberInput
    upsert?: WorkSpace_usersUpsertWithoutTeam_memberInput
    connect?: WorkSpace_usersWhereUniqueInput
    update?: XOR<XOR<WorkSpace_usersUpdateToOneWithWhereWithoutTeam_memberInput, WorkSpace_usersUpdateWithoutTeam_memberInput>, WorkSpace_usersUncheckedUpdateWithoutTeam_memberInput>
  }

  export type WorkSpaceUpdateOneRequiredWithoutTeam_memberNestedInput = {
    create?: XOR<WorkSpaceCreateWithoutTeam_memberInput, WorkSpaceUncheckedCreateWithoutTeam_memberInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutTeam_memberInput
    upsert?: WorkSpaceUpsertWithoutTeam_memberInput
    connect?: WorkSpaceWhereUniqueInput
    update?: XOR<XOR<WorkSpaceUpdateToOneWithWhereWithoutTeam_memberInput, WorkSpaceUpdateWithoutTeam_memberInput>, WorkSpaceUncheckedUpdateWithoutTeam_memberInput>
  }

  export type Monitor_configCreateNestedOneWithoutAlertInput = {
    create?: XOR<Monitor_configCreateWithoutAlertInput, Monitor_configUncheckedCreateWithoutAlertInput>
    connectOrCreate?: Monitor_configCreateOrConnectWithoutAlertInput
    connect?: Monitor_configWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAlertInput = {
    create?: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertInput
    connect?: UserWhereUniqueInput
  }

  export type WorkSpaceCreateNestedOneWithoutAlertInput = {
    create?: XOR<WorkSpaceCreateWithoutAlertInput, WorkSpaceUncheckedCreateWithoutAlertInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutAlertInput
    connect?: WorkSpaceWhereUniqueInput
  }

  export type Monitor_configUpdateOneRequiredWithoutAlertNestedInput = {
    create?: XOR<Monitor_configCreateWithoutAlertInput, Monitor_configUncheckedCreateWithoutAlertInput>
    connectOrCreate?: Monitor_configCreateOrConnectWithoutAlertInput
    upsert?: Monitor_configUpsertWithoutAlertInput
    connect?: Monitor_configWhereUniqueInput
    update?: XOR<XOR<Monitor_configUpdateToOneWithWhereWithoutAlertInput, Monitor_configUpdateWithoutAlertInput>, Monitor_configUncheckedUpdateWithoutAlertInput>
  }

  export type UserUpdateOneWithoutAlertNestedInput = {
    create?: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
    connectOrCreate?: UserCreateOrConnectWithoutAlertInput
    upsert?: UserUpsertWithoutAlertInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAlertInput, UserUpdateWithoutAlertInput>, UserUncheckedUpdateWithoutAlertInput>
  }

  export type WorkSpaceUpdateOneRequiredWithoutAlertNestedInput = {
    create?: XOR<WorkSpaceCreateWithoutAlertInput, WorkSpaceUncheckedCreateWithoutAlertInput>
    connectOrCreate?: WorkSpaceCreateOrConnectWithoutAlertInput
    upsert?: WorkSpaceUpsertWithoutAlertInput
    connect?: WorkSpaceWhereUniqueInput
    update?: XOR<XOR<WorkSpaceUpdateToOneWithWhereWithoutAlertInput, WorkSpaceUpdateWithoutAlertInput>, WorkSpaceUncheckedUpdateWithoutAlertInput>
  }

  export type teamCreateNestedOneWithoutTeam_escalationpolicyInput = {
    create?: XOR<teamCreateWithoutTeam_escalationpolicyInput, teamUncheckedCreateWithoutTeam_escalationpolicyInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeam_escalationpolicyInput
    connect?: teamWhereUniqueInput
  }

  export type escalation_policy_rulesCreateNestedManyWithoutTeam_escalation_policyInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutTeam_escalation_policyInput, escalation_policy_rulesUncheckedCreateWithoutTeam_escalation_policyInput> | escalation_policy_rulesCreateWithoutTeam_escalation_policyInput[] | escalation_policy_rulesUncheckedCreateWithoutTeam_escalation_policyInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutTeam_escalation_policyInput | escalation_policy_rulesCreateOrConnectWithoutTeam_escalation_policyInput[]
    createMany?: escalation_policy_rulesCreateManyTeam_escalation_policyInputEnvelope
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
  }

  export type escalation_policy_rulesUncheckedCreateNestedManyWithoutTeam_escalation_policyInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutTeam_escalation_policyInput, escalation_policy_rulesUncheckedCreateWithoutTeam_escalation_policyInput> | escalation_policy_rulesCreateWithoutTeam_escalation_policyInput[] | escalation_policy_rulesUncheckedCreateWithoutTeam_escalation_policyInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutTeam_escalation_policyInput | escalation_policy_rulesCreateOrConnectWithoutTeam_escalation_policyInput[]
    createMany?: escalation_policy_rulesCreateManyTeam_escalation_policyInputEnvelope
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
  }

  export type teamUpdateOneRequiredWithoutTeam_escalationpolicyNestedInput = {
    create?: XOR<teamCreateWithoutTeam_escalationpolicyInput, teamUncheckedCreateWithoutTeam_escalationpolicyInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeam_escalationpolicyInput
    upsert?: teamUpsertWithoutTeam_escalationpolicyInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutTeam_escalationpolicyInput, teamUpdateWithoutTeam_escalationpolicyInput>, teamUncheckedUpdateWithoutTeam_escalationpolicyInput>
  }

  export type escalation_policy_rulesUpdateManyWithoutTeam_escalation_policyNestedInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutTeam_escalation_policyInput, escalation_policy_rulesUncheckedCreateWithoutTeam_escalation_policyInput> | escalation_policy_rulesCreateWithoutTeam_escalation_policyInput[] | escalation_policy_rulesUncheckedCreateWithoutTeam_escalation_policyInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutTeam_escalation_policyInput | escalation_policy_rulesCreateOrConnectWithoutTeam_escalation_policyInput[]
    upsert?: escalation_policy_rulesUpsertWithWhereUniqueWithoutTeam_escalation_policyInput | escalation_policy_rulesUpsertWithWhereUniqueWithoutTeam_escalation_policyInput[]
    createMany?: escalation_policy_rulesCreateManyTeam_escalation_policyInputEnvelope
    set?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    disconnect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    delete?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    update?: escalation_policy_rulesUpdateWithWhereUniqueWithoutTeam_escalation_policyInput | escalation_policy_rulesUpdateWithWhereUniqueWithoutTeam_escalation_policyInput[]
    updateMany?: escalation_policy_rulesUpdateManyWithWhereWithoutTeam_escalation_policyInput | escalation_policy_rulesUpdateManyWithWhereWithoutTeam_escalation_policyInput[]
    deleteMany?: escalation_policy_rulesScalarWhereInput | escalation_policy_rulesScalarWhereInput[]
  }

  export type escalation_policy_rulesUncheckedUpdateManyWithoutTeam_escalation_policyNestedInput = {
    create?: XOR<escalation_policy_rulesCreateWithoutTeam_escalation_policyInput, escalation_policy_rulesUncheckedCreateWithoutTeam_escalation_policyInput> | escalation_policy_rulesCreateWithoutTeam_escalation_policyInput[] | escalation_policy_rulesUncheckedCreateWithoutTeam_escalation_policyInput[]
    connectOrCreate?: escalation_policy_rulesCreateOrConnectWithoutTeam_escalation_policyInput | escalation_policy_rulesCreateOrConnectWithoutTeam_escalation_policyInput[]
    upsert?: escalation_policy_rulesUpsertWithWhereUniqueWithoutTeam_escalation_policyInput | escalation_policy_rulesUpsertWithWhereUniqueWithoutTeam_escalation_policyInput[]
    createMany?: escalation_policy_rulesCreateManyTeam_escalation_policyInputEnvelope
    set?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    disconnect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    delete?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    connect?: escalation_policy_rulesWhereUniqueInput | escalation_policy_rulesWhereUniqueInput[]
    update?: escalation_policy_rulesUpdateWithWhereUniqueWithoutTeam_escalation_policyInput | escalation_policy_rulesUpdateWithWhereUniqueWithoutTeam_escalation_policyInput[]
    updateMany?: escalation_policy_rulesUpdateManyWithWhereWithoutTeam_escalation_policyInput | escalation_policy_rulesUpdateManyWithWhereWithoutTeam_escalation_policyInput[]
    deleteMany?: escalation_policy_rulesScalarWhereInput | escalation_policy_rulesScalarWhereInput[]
  }

  export type team_escalationpolicyCreateNestedOneWithoutEscalation_policy_rulesInput = {
    create?: XOR<team_escalationpolicyCreateWithoutEscalation_policy_rulesInput, team_escalationpolicyUncheckedCreateWithoutEscalation_policy_rulesInput>
    connectOrCreate?: team_escalationpolicyCreateOrConnectWithoutEscalation_policy_rulesInput
    connect?: team_escalationpolicyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEscalation_policy_rulesInput = {
    create?: XOR<UserCreateWithoutEscalation_policy_rulesInput, UserUncheckedCreateWithoutEscalation_policy_rulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEscalation_policy_rulesInput
    connect?: UserWhereUniqueInput
  }

  export type teamCreateNestedOneWithoutEscalation_policy_rulesInput = {
    create?: XOR<teamCreateWithoutEscalation_policy_rulesInput, teamUncheckedCreateWithoutEscalation_policy_rulesInput>
    connectOrCreate?: teamCreateOrConnectWithoutEscalation_policy_rulesInput
    connect?: teamWhereUniqueInput
  }

  export type Enumnotification_typeFieldUpdateOperationsInput = {
    set?: $Enums.notification_type
  }

  export type team_escalationpolicyUpdateOneRequiredWithoutEscalation_policy_rulesNestedInput = {
    create?: XOR<team_escalationpolicyCreateWithoutEscalation_policy_rulesInput, team_escalationpolicyUncheckedCreateWithoutEscalation_policy_rulesInput>
    connectOrCreate?: team_escalationpolicyCreateOrConnectWithoutEscalation_policy_rulesInput
    upsert?: team_escalationpolicyUpsertWithoutEscalation_policy_rulesInput
    connect?: team_escalationpolicyWhereUniqueInput
    update?: XOR<XOR<team_escalationpolicyUpdateToOneWithWhereWithoutEscalation_policy_rulesInput, team_escalationpolicyUpdateWithoutEscalation_policy_rulesInput>, team_escalationpolicyUncheckedUpdateWithoutEscalation_policy_rulesInput>
  }

  export type UserUpdateOneWithoutEscalation_policy_rulesNestedInput = {
    create?: XOR<UserCreateWithoutEscalation_policy_rulesInput, UserUncheckedCreateWithoutEscalation_policy_rulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutEscalation_policy_rulesInput
    upsert?: UserUpsertWithoutEscalation_policy_rulesInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEscalation_policy_rulesInput, UserUpdateWithoutEscalation_policy_rulesInput>, UserUncheckedUpdateWithoutEscalation_policy_rulesInput>
  }

  export type teamUpdateOneWithoutEscalation_policy_rulesNestedInput = {
    create?: XOR<teamCreateWithoutEscalation_policy_rulesInput, teamUncheckedCreateWithoutEscalation_policy_rulesInput>
    connectOrCreate?: teamCreateOrConnectWithoutEscalation_policy_rulesInput
    upsert?: teamUpsertWithoutEscalation_policy_rulesInput
    disconnect?: boolean
    delete?: teamWhereInput | boolean
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutEscalation_policy_rulesInput, teamUpdateWithoutEscalation_policy_rulesInput>, teamUncheckedUpdateWithoutEscalation_policy_rulesInput>
  }

  export type teamCreateNestedOneWithoutTeam_scheduleInput = {
    create?: XOR<teamCreateWithoutTeam_scheduleInput, teamUncheckedCreateWithoutTeam_scheduleInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeam_scheduleInput
    connect?: teamWhereUniqueInput
  }

  export type team_schedule_rotationCreateNestedManyWithoutTeam_scheduleInput = {
    create?: XOR<team_schedule_rotationCreateWithoutTeam_scheduleInput, team_schedule_rotationUncheckedCreateWithoutTeam_scheduleInput> | team_schedule_rotationCreateWithoutTeam_scheduleInput[] | team_schedule_rotationUncheckedCreateWithoutTeam_scheduleInput[]
    connectOrCreate?: team_schedule_rotationCreateOrConnectWithoutTeam_scheduleInput | team_schedule_rotationCreateOrConnectWithoutTeam_scheduleInput[]
    createMany?: team_schedule_rotationCreateManyTeam_scheduleInputEnvelope
    connect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
  }

  export type team_schedule_overrideCreateNestedManyWithoutTeam_scheduleInput = {
    create?: XOR<team_schedule_overrideCreateWithoutTeam_scheduleInput, team_schedule_overrideUncheckedCreateWithoutTeam_scheduleInput> | team_schedule_overrideCreateWithoutTeam_scheduleInput[] | team_schedule_overrideUncheckedCreateWithoutTeam_scheduleInput[]
    connectOrCreate?: team_schedule_overrideCreateOrConnectWithoutTeam_scheduleInput | team_schedule_overrideCreateOrConnectWithoutTeam_scheduleInput[]
    createMany?: team_schedule_overrideCreateManyTeam_scheduleInputEnvelope
    connect?: team_schedule_overrideWhereUniqueInput | team_schedule_overrideWhereUniqueInput[]
  }

  export type team_schedule_rotationUncheckedCreateNestedManyWithoutTeam_scheduleInput = {
    create?: XOR<team_schedule_rotationCreateWithoutTeam_scheduleInput, team_schedule_rotationUncheckedCreateWithoutTeam_scheduleInput> | team_schedule_rotationCreateWithoutTeam_scheduleInput[] | team_schedule_rotationUncheckedCreateWithoutTeam_scheduleInput[]
    connectOrCreate?: team_schedule_rotationCreateOrConnectWithoutTeam_scheduleInput | team_schedule_rotationCreateOrConnectWithoutTeam_scheduleInput[]
    createMany?: team_schedule_rotationCreateManyTeam_scheduleInputEnvelope
    connect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
  }

  export type team_schedule_overrideUncheckedCreateNestedManyWithoutTeam_scheduleInput = {
    create?: XOR<team_schedule_overrideCreateWithoutTeam_scheduleInput, team_schedule_overrideUncheckedCreateWithoutTeam_scheduleInput> | team_schedule_overrideCreateWithoutTeam_scheduleInput[] | team_schedule_overrideUncheckedCreateWithoutTeam_scheduleInput[]
    connectOrCreate?: team_schedule_overrideCreateOrConnectWithoutTeam_scheduleInput | team_schedule_overrideCreateOrConnectWithoutTeam_scheduleInput[]
    createMany?: team_schedule_overrideCreateManyTeam_scheduleInputEnvelope
    connect?: team_schedule_overrideWhereUniqueInput | team_schedule_overrideWhereUniqueInput[]
  }

  export type teamUpdateOneRequiredWithoutTeam_scheduleNestedInput = {
    create?: XOR<teamCreateWithoutTeam_scheduleInput, teamUncheckedCreateWithoutTeam_scheduleInput>
    connectOrCreate?: teamCreateOrConnectWithoutTeam_scheduleInput
    upsert?: teamUpsertWithoutTeam_scheduleInput
    connect?: teamWhereUniqueInput
    update?: XOR<XOR<teamUpdateToOneWithWhereWithoutTeam_scheduleInput, teamUpdateWithoutTeam_scheduleInput>, teamUncheckedUpdateWithoutTeam_scheduleInput>
  }

  export type team_schedule_rotationUpdateManyWithoutTeam_scheduleNestedInput = {
    create?: XOR<team_schedule_rotationCreateWithoutTeam_scheduleInput, team_schedule_rotationUncheckedCreateWithoutTeam_scheduleInput> | team_schedule_rotationCreateWithoutTeam_scheduleInput[] | team_schedule_rotationUncheckedCreateWithoutTeam_scheduleInput[]
    connectOrCreate?: team_schedule_rotationCreateOrConnectWithoutTeam_scheduleInput | team_schedule_rotationCreateOrConnectWithoutTeam_scheduleInput[]
    upsert?: team_schedule_rotationUpsertWithWhereUniqueWithoutTeam_scheduleInput | team_schedule_rotationUpsertWithWhereUniqueWithoutTeam_scheduleInput[]
    createMany?: team_schedule_rotationCreateManyTeam_scheduleInputEnvelope
    set?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    disconnect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    delete?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    connect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    update?: team_schedule_rotationUpdateWithWhereUniqueWithoutTeam_scheduleInput | team_schedule_rotationUpdateWithWhereUniqueWithoutTeam_scheduleInput[]
    updateMany?: team_schedule_rotationUpdateManyWithWhereWithoutTeam_scheduleInput | team_schedule_rotationUpdateManyWithWhereWithoutTeam_scheduleInput[]
    deleteMany?: team_schedule_rotationScalarWhereInput | team_schedule_rotationScalarWhereInput[]
  }

  export type team_schedule_overrideUpdateManyWithoutTeam_scheduleNestedInput = {
    create?: XOR<team_schedule_overrideCreateWithoutTeam_scheduleInput, team_schedule_overrideUncheckedCreateWithoutTeam_scheduleInput> | team_schedule_overrideCreateWithoutTeam_scheduleInput[] | team_schedule_overrideUncheckedCreateWithoutTeam_scheduleInput[]
    connectOrCreate?: team_schedule_overrideCreateOrConnectWithoutTeam_scheduleInput | team_schedule_overrideCreateOrConnectWithoutTeam_scheduleInput[]
    upsert?: team_schedule_overrideUpsertWithWhereUniqueWithoutTeam_scheduleInput | team_schedule_overrideUpsertWithWhereUniqueWithoutTeam_scheduleInput[]
    createMany?: team_schedule_overrideCreateManyTeam_scheduleInputEnvelope
    set?: team_schedule_overrideWhereUniqueInput | team_schedule_overrideWhereUniqueInput[]
    disconnect?: team_schedule_overrideWhereUniqueInput | team_schedule_overrideWhereUniqueInput[]
    delete?: team_schedule_overrideWhereUniqueInput | team_schedule_overrideWhereUniqueInput[]
    connect?: team_schedule_overrideWhereUniqueInput | team_schedule_overrideWhereUniqueInput[]
    update?: team_schedule_overrideUpdateWithWhereUniqueWithoutTeam_scheduleInput | team_schedule_overrideUpdateWithWhereUniqueWithoutTeam_scheduleInput[]
    updateMany?: team_schedule_overrideUpdateManyWithWhereWithoutTeam_scheduleInput | team_schedule_overrideUpdateManyWithWhereWithoutTeam_scheduleInput[]
    deleteMany?: team_schedule_overrideScalarWhereInput | team_schedule_overrideScalarWhereInput[]
  }

  export type team_schedule_rotationUncheckedUpdateManyWithoutTeam_scheduleNestedInput = {
    create?: XOR<team_schedule_rotationCreateWithoutTeam_scheduleInput, team_schedule_rotationUncheckedCreateWithoutTeam_scheduleInput> | team_schedule_rotationCreateWithoutTeam_scheduleInput[] | team_schedule_rotationUncheckedCreateWithoutTeam_scheduleInput[]
    connectOrCreate?: team_schedule_rotationCreateOrConnectWithoutTeam_scheduleInput | team_schedule_rotationCreateOrConnectWithoutTeam_scheduleInput[]
    upsert?: team_schedule_rotationUpsertWithWhereUniqueWithoutTeam_scheduleInput | team_schedule_rotationUpsertWithWhereUniqueWithoutTeam_scheduleInput[]
    createMany?: team_schedule_rotationCreateManyTeam_scheduleInputEnvelope
    set?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    disconnect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    delete?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    connect?: team_schedule_rotationWhereUniqueInput | team_schedule_rotationWhereUniqueInput[]
    update?: team_schedule_rotationUpdateWithWhereUniqueWithoutTeam_scheduleInput | team_schedule_rotationUpdateWithWhereUniqueWithoutTeam_scheduleInput[]
    updateMany?: team_schedule_rotationUpdateManyWithWhereWithoutTeam_scheduleInput | team_schedule_rotationUpdateManyWithWhereWithoutTeam_scheduleInput[]
    deleteMany?: team_schedule_rotationScalarWhereInput | team_schedule_rotationScalarWhereInput[]
  }

  export type team_schedule_overrideUncheckedUpdateManyWithoutTeam_scheduleNestedInput = {
    create?: XOR<team_schedule_overrideCreateWithoutTeam_scheduleInput, team_schedule_overrideUncheckedCreateWithoutTeam_scheduleInput> | team_schedule_overrideCreateWithoutTeam_scheduleInput[] | team_schedule_overrideUncheckedCreateWithoutTeam_scheduleInput[]
    connectOrCreate?: team_schedule_overrideCreateOrConnectWithoutTeam_scheduleInput | team_schedule_overrideCreateOrConnectWithoutTeam_scheduleInput[]
    upsert?: team_schedule_overrideUpsertWithWhereUniqueWithoutTeam_scheduleInput | team_schedule_overrideUpsertWithWhereUniqueWithoutTeam_scheduleInput[]
    createMany?: team_schedule_overrideCreateManyTeam_scheduleInputEnvelope
    set?: team_schedule_overrideWhereUniqueInput | team_schedule_overrideWhereUniqueInput[]
    disconnect?: team_schedule_overrideWhereUniqueInput | team_schedule_overrideWhereUniqueInput[]
    delete?: team_schedule_overrideWhereUniqueInput | team_schedule_overrideWhereUniqueInput[]
    connect?: team_schedule_overrideWhereUniqueInput | team_schedule_overrideWhereUniqueInput[]
    update?: team_schedule_overrideUpdateWithWhereUniqueWithoutTeam_scheduleInput | team_schedule_overrideUpdateWithWhereUniqueWithoutTeam_scheduleInput[]
    updateMany?: team_schedule_overrideUpdateManyWithWhereWithoutTeam_scheduleInput | team_schedule_overrideUpdateManyWithWhereWithoutTeam_scheduleInput[]
    deleteMany?: team_schedule_overrideScalarWhereInput | team_schedule_overrideScalarWhereInput[]
  }

  export type team_scheduleCreateNestedOneWithoutTeam_schedule_rotationInput = {
    create?: XOR<team_scheduleCreateWithoutTeam_schedule_rotationInput, team_scheduleUncheckedCreateWithoutTeam_schedule_rotationInput>
    connectOrCreate?: team_scheduleCreateOrConnectWithoutTeam_schedule_rotationInput
    connect?: team_scheduleWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeam_schedule_rotationInput = {
    create?: XOR<UserCreateWithoutTeam_schedule_rotationInput, UserUncheckedCreateWithoutTeam_schedule_rotationInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeam_schedule_rotationInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.Frequency
  }

  export type NullableEnumRestrictionFieldUpdateOperationsInput = {
    set?: $Enums.Restriction | null
    unset?: boolean
  }

  export type team_scheduleUpdateOneRequiredWithoutTeam_schedule_rotationNestedInput = {
    create?: XOR<team_scheduleCreateWithoutTeam_schedule_rotationInput, team_scheduleUncheckedCreateWithoutTeam_schedule_rotationInput>
    connectOrCreate?: team_scheduleCreateOrConnectWithoutTeam_schedule_rotationInput
    upsert?: team_scheduleUpsertWithoutTeam_schedule_rotationInput
    connect?: team_scheduleWhereUniqueInput
    update?: XOR<XOR<team_scheduleUpdateToOneWithWhereWithoutTeam_schedule_rotationInput, team_scheduleUpdateWithoutTeam_schedule_rotationInput>, team_scheduleUncheckedUpdateWithoutTeam_schedule_rotationInput>
  }

  export type UserUpdateOneRequiredWithoutTeam_schedule_rotationNestedInput = {
    create?: XOR<UserCreateWithoutTeam_schedule_rotationInput, UserUncheckedCreateWithoutTeam_schedule_rotationInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeam_schedule_rotationInput
    upsert?: UserUpsertWithoutTeam_schedule_rotationInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeam_schedule_rotationInput, UserUpdateWithoutTeam_schedule_rotationInput>, UserUncheckedUpdateWithoutTeam_schedule_rotationInput>
  }

  export type team_scheduleCreateNestedOneWithoutTeam_schedule_overrideInput = {
    create?: XOR<team_scheduleCreateWithoutTeam_schedule_overrideInput, team_scheduleUncheckedCreateWithoutTeam_schedule_overrideInput>
    connectOrCreate?: team_scheduleCreateOrConnectWithoutTeam_schedule_overrideInput
    connect?: team_scheduleWhereUniqueInput
  }

  export type team_scheduleUpdateOneRequiredWithoutTeam_schedule_overrideNestedInput = {
    create?: XOR<team_scheduleCreateWithoutTeam_schedule_overrideInput, team_scheduleUncheckedCreateWithoutTeam_schedule_overrideInput>
    connectOrCreate?: team_scheduleCreateOrConnectWithoutTeam_schedule_overrideInput
    upsert?: team_scheduleUpsertWithoutTeam_schedule_overrideInput
    connect?: team_scheduleWhereUniqueInput
    update?: XOR<XOR<team_scheduleUpdateToOneWithWhereWithoutTeam_schedule_overrideInput, team_scheduleUpdateWithoutTeam_schedule_overrideInput>, team_scheduleUncheckedUpdateWithoutTeam_schedule_overrideInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
    isSet?: boolean
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedEnumstatusFilter<$PrismaModel = never> = {
    equals?: $Enums.status | EnumstatusFieldRefInput<$PrismaModel>
    in?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumstatusFilter<$PrismaModel> | $Enums.status
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedEnumstatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.status | EnumstatusFieldRefInput<$PrismaModel>
    in?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.status[] | ListEnumstatusFieldRefInput<$PrismaModel>
    not?: NestedEnumstatusWithAggregatesFilter<$PrismaModel> | $Enums.status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumstatusFilter<$PrismaModel>
    _max?: NestedEnumstatusFilter<$PrismaModel>
  }

  export type NestedEnumnotification_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type | Enumnotification_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type[] | ListEnumnotification_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.notification_type[] | ListEnumnotification_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumnotification_typeFilter<$PrismaModel> | $Enums.notification_type
  }

  export type NestedEnumnotification_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.notification_type | Enumnotification_typeFieldRefInput<$PrismaModel>
    in?: $Enums.notification_type[] | ListEnumnotification_typeFieldRefInput<$PrismaModel>
    notIn?: $Enums.notification_type[] | ListEnumnotification_typeFieldRefInput<$PrismaModel>
    not?: NestedEnumnotification_typeWithAggregatesFilter<$PrismaModel> | $Enums.notification_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumnotification_typeFilter<$PrismaModel>
    _max?: NestedEnumnotification_typeFilter<$PrismaModel>
  }

  export type NestedEnumFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.Frequency | EnumFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyFilter<$PrismaModel> | $Enums.Frequency
  }

  export type NestedEnumRestrictionNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Restriction | EnumRestrictionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Restriction[] | ListEnumRestrictionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Restriction[] | ListEnumRestrictionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRestrictionNullableFilter<$PrismaModel> | $Enums.Restriction | null
    isSet?: boolean
  }

  export type NestedEnumFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Frequency | EnumFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    notIn?: $Enums.Frequency[] | ListEnumFrequencyFieldRefInput<$PrismaModel>
    not?: NestedEnumFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.Frequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFrequencyFilter<$PrismaModel>
    _max?: NestedEnumFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumRestrictionNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Restriction | EnumRestrictionFieldRefInput<$PrismaModel> | null
    in?: $Enums.Restriction[] | ListEnumRestrictionFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Restriction[] | ListEnumRestrictionFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRestrictionNullableWithAggregatesFilter<$PrismaModel> | $Enums.Restriction | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRestrictionNullableFilter<$PrismaModel>
    _max?: NestedEnumRestrictionNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type Monitor_configCreateWithoutUserInput = {
    id?: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    createdAt?: Date | string
    workspace?: WorkSpaceCreateNestedOneWithoutMonitor_configInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsCreateNestedOneWithoutMonitor_configInput
    team?: teamCreateNestedOneWithoutMonitor_configInput
    alert?: alertCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configUncheckedCreateWithoutUserInput = {
    id?: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    workspaceId?: string | null
    teamId?: string | null
    createdAt?: Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsUncheckedCreateNestedOneWithoutMonitor_configInput
    alert?: alertUncheckedCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configCreateOrConnectWithoutUserInput = {
    where: Monitor_configWhereUniqueInput
    create: XOR<Monitor_configCreateWithoutUserInput, Monitor_configUncheckedCreateWithoutUserInput>
  }

  export type Monitor_configCreateManyUserInputEnvelope = {
    data: Monitor_configCreateManyUserInput | Monitor_configCreateManyUserInput[]
  }

  export type WorkSpaceCreateWithoutOwnerInput = {
    id?: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    monitor_config?: Monitor_configCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersCreateNestedManyWithoutWokspaceInput
    team?: teamCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberCreateNestedManyWithoutWorkspaceInput
    alert?: alertCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceUncheckedCreateWithoutOwnerInput = {
    id?: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersUncheckedCreateNestedManyWithoutWokspaceInput
    team?: teamUncheckedCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberUncheckedCreateNestedManyWithoutWorkspaceInput
    alert?: alertUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceCreateOrConnectWithoutOwnerInput = {
    where: WorkSpaceWhereUniqueInput
    create: XOR<WorkSpaceCreateWithoutOwnerInput, WorkSpaceUncheckedCreateWithoutOwnerInput>
  }

  export type WorkSpaceCreateManyOwnerInputEnvelope = {
    data: WorkSpaceCreateManyOwnerInput | WorkSpaceCreateManyOwnerInput[]
  }

  export type WorkSpace_usersCreateWithoutUserInput = {
    id?: string
    role?: $Enums.Role
    createdAt?: Date | string
    workspace: WorkSpaceCreateNestedOneWithoutWorkspace_usersInput
    team_member?: team_memberCreateNestedManyWithoutWorkspace_userInput
  }

  export type WorkSpace_usersUncheckedCreateWithoutUserInput = {
    id?: string
    workspaceId: string
    role?: $Enums.Role
    createdAt?: Date | string
    team_member?: team_memberUncheckedCreateNestedManyWithoutWorkspace_userInput
  }

  export type WorkSpace_usersCreateOrConnectWithoutUserInput = {
    where: WorkSpace_usersWhereUniqueInput
    create: XOR<WorkSpace_usersCreateWithoutUserInput, WorkSpace_usersUncheckedCreateWithoutUserInput>
  }

  export type WorkSpace_usersCreateManyUserInputEnvelope = {
    data: WorkSpace_usersCreateManyUserInput | WorkSpace_usersCreateManyUserInput[]
  }

  export type teamCreateWithoutCreatorInput = {
    id?: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    workspace: WorkSpaceCreateNestedOneWithoutTeamInput
    team_member?: team_memberCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutCreatorInput = {
    id?: string
    workspaceId: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    team_member?: team_memberUncheckedCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyUncheckedCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutCreatorInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutCreatorInput, teamUncheckedCreateWithoutCreatorInput>
  }

  export type teamCreateManyCreatorInputEnvelope = {
    data: teamCreateManyCreatorInput | teamCreateManyCreatorInput[]
  }

  export type alertCreateWithoutUserInput = {
    id?: string
    acknowledged?: boolean
    createdAt?: Date | string
    monitor_config: Monitor_configCreateNestedOneWithoutAlertInput
    workspace: WorkSpaceCreateNestedOneWithoutAlertInput
  }

  export type alertUncheckedCreateWithoutUserInput = {
    id?: string
    acknowledged?: boolean
    monitor_configId: string
    workspaceId: string
    createdAt?: Date | string
  }

  export type alertCreateOrConnectWithoutUserInput = {
    where: alertWhereUniqueInput
    create: XOR<alertCreateWithoutUserInput, alertUncheckedCreateWithoutUserInput>
  }

  export type alertCreateManyUserInputEnvelope = {
    data: alertCreateManyUserInput | alertCreateManyUserInput[]
  }

  export type escalation_policy_rulesCreateWithoutUserInput = {
    id?: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    scheudleId?: string | null
    is_active?: boolean
    team_escalation_policy: team_escalationpolicyCreateNestedOneWithoutEscalation_policy_rulesInput
    team?: teamCreateNestedOneWithoutEscalation_policy_rulesInput
  }

  export type escalation_policy_rulesUncheckedCreateWithoutUserInput = {
    id?: string
    team_escalationpolicyId: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    scheudleId?: string | null
    teamId?: string | null
    is_active?: boolean
  }

  export type escalation_policy_rulesCreateOrConnectWithoutUserInput = {
    where: escalation_policy_rulesWhereUniqueInput
    create: XOR<escalation_policy_rulesCreateWithoutUserInput, escalation_policy_rulesUncheckedCreateWithoutUserInput>
  }

  export type escalation_policy_rulesCreateManyUserInputEnvelope = {
    data: escalation_policy_rulesCreateManyUserInput | escalation_policy_rulesCreateManyUserInput[]
  }

  export type user_otpCreateWithoutUserInput = {
    id?: string
    otp: string
    invalid?: boolean
    expiresAt: number
    createdAt?: Date | string
  }

  export type user_otpUncheckedCreateWithoutUserInput = {
    id?: string
    otp: string
    invalid?: boolean
    expiresAt: number
    createdAt?: Date | string
  }

  export type user_otpCreateOrConnectWithoutUserInput = {
    where: user_otpWhereUniqueInput
    create: XOR<user_otpCreateWithoutUserInput, user_otpUncheckedCreateWithoutUserInput>
  }

  export type user_otpCreateManyUserInputEnvelope = {
    data: user_otpCreateManyUserInput | user_otpCreateManyUserInput[]
  }

  export type team_schedule_rotationCreateWithoutUserInput = {
    id?: string
    name: string
    starts_on?: Date | string
    frequency: $Enums.Frequency
    ends_on?: Date | string | null
    custom_start_date_time?: Date | string | null
    custom_end_date_time?: Date | string | null
    restrict_time_type?: $Enums.Restriction | null
    restrict_time_start?: Date | string | null
    restrict_time_end?: Date | string | null
    team_schedule: team_scheduleCreateNestedOneWithoutTeam_schedule_rotationInput
  }

  export type team_schedule_rotationUncheckedCreateWithoutUserInput = {
    id?: string
    team_scheduleId: string
    name: string
    starts_on?: Date | string
    frequency: $Enums.Frequency
    ends_on?: Date | string | null
    custom_start_date_time?: Date | string | null
    custom_end_date_time?: Date | string | null
    restrict_time_type?: $Enums.Restriction | null
    restrict_time_start?: Date | string | null
    restrict_time_end?: Date | string | null
  }

  export type team_schedule_rotationCreateOrConnectWithoutUserInput = {
    where: team_schedule_rotationWhereUniqueInput
    create: XOR<team_schedule_rotationCreateWithoutUserInput, team_schedule_rotationUncheckedCreateWithoutUserInput>
  }

  export type team_schedule_rotationCreateManyUserInputEnvelope = {
    data: team_schedule_rotationCreateManyUserInput | team_schedule_rotationCreateManyUserInput[]
  }

  export type Monitor_configUpsertWithWhereUniqueWithoutUserInput = {
    where: Monitor_configWhereUniqueInput
    update: XOR<Monitor_configUpdateWithoutUserInput, Monitor_configUncheckedUpdateWithoutUserInput>
    create: XOR<Monitor_configCreateWithoutUserInput, Monitor_configUncheckedCreateWithoutUserInput>
  }

  export type Monitor_configUpdateWithWhereUniqueWithoutUserInput = {
    where: Monitor_configWhereUniqueInput
    data: XOR<Monitor_configUpdateWithoutUserInput, Monitor_configUncheckedUpdateWithoutUserInput>
  }

  export type Monitor_configUpdateManyWithWhereWithoutUserInput = {
    where: Monitor_configScalarWhereInput
    data: XOR<Monitor_configUpdateManyMutationInput, Monitor_configUncheckedUpdateManyWithoutUserInput>
  }

  export type Monitor_configScalarWhereInput = {
    AND?: Monitor_configScalarWhereInput | Monitor_configScalarWhereInput[]
    OR?: Monitor_configScalarWhereInput[]
    NOT?: Monitor_configScalarWhereInput | Monitor_configScalarWhereInput[]
    id?: StringFilter<"Monitor_config"> | string
    userId?: StringFilter<"Monitor_config"> | string
    name?: StringNullableFilter<"Monitor_config"> | string | null
    monitorType?: StringFilter<"Monitor_config"> | string
    is_active?: BoolFilter<"Monitor_config"> | boolean
    workspaceId?: StringNullableFilter<"Monitor_config"> | string | null
    teamId?: StringNullableFilter<"Monitor_config"> | string | null
    createdAt?: DateTimeFilter<"Monitor_config"> | Date | string
  }

  export type WorkSpaceUpsertWithWhereUniqueWithoutOwnerInput = {
    where: WorkSpaceWhereUniqueInput
    update: XOR<WorkSpaceUpdateWithoutOwnerInput, WorkSpaceUncheckedUpdateWithoutOwnerInput>
    create: XOR<WorkSpaceCreateWithoutOwnerInput, WorkSpaceUncheckedCreateWithoutOwnerInput>
  }

  export type WorkSpaceUpdateWithWhereUniqueWithoutOwnerInput = {
    where: WorkSpaceWhereUniqueInput
    data: XOR<WorkSpaceUpdateWithoutOwnerInput, WorkSpaceUncheckedUpdateWithoutOwnerInput>
  }

  export type WorkSpaceUpdateManyWithWhereWithoutOwnerInput = {
    where: WorkSpaceScalarWhereInput
    data: XOR<WorkSpaceUpdateManyMutationInput, WorkSpaceUncheckedUpdateManyWithoutOwnerInput>
  }

  export type WorkSpaceScalarWhereInput = {
    AND?: WorkSpaceScalarWhereInput | WorkSpaceScalarWhereInput[]
    OR?: WorkSpaceScalarWhereInput[]
    NOT?: WorkSpaceScalarWhereInput | WorkSpaceScalarWhereInput[]
    id?: StringFilter<"WorkSpace"> | string
    ownerId?: StringFilter<"WorkSpace"> | string
    workspace_name?: StringFilter<"WorkSpace"> | string
    trial_startDate?: DateTimeFilter<"WorkSpace"> | Date | string
    trial_endDate?: DateTimeFilter<"WorkSpace"> | Date | string
    subscription_start?: DateTimeNullableFilter<"WorkSpace"> | Date | string | null
    subscription_end?: DateTimeNullableFilter<"WorkSpace"> | Date | string | null
  }

  export type WorkSpace_usersUpsertWithWhereUniqueWithoutUserInput = {
    where: WorkSpace_usersWhereUniqueInput
    update: XOR<WorkSpace_usersUpdateWithoutUserInput, WorkSpace_usersUncheckedUpdateWithoutUserInput>
    create: XOR<WorkSpace_usersCreateWithoutUserInput, WorkSpace_usersUncheckedCreateWithoutUserInput>
  }

  export type WorkSpace_usersUpdateWithWhereUniqueWithoutUserInput = {
    where: WorkSpace_usersWhereUniqueInput
    data: XOR<WorkSpace_usersUpdateWithoutUserInput, WorkSpace_usersUncheckedUpdateWithoutUserInput>
  }

  export type WorkSpace_usersUpdateManyWithWhereWithoutUserInput = {
    where: WorkSpace_usersScalarWhereInput
    data: XOR<WorkSpace_usersUpdateManyMutationInput, WorkSpace_usersUncheckedUpdateManyWithoutUserInput>
  }

  export type WorkSpace_usersScalarWhereInput = {
    AND?: WorkSpace_usersScalarWhereInput | WorkSpace_usersScalarWhereInput[]
    OR?: WorkSpace_usersScalarWhereInput[]
    NOT?: WorkSpace_usersScalarWhereInput | WorkSpace_usersScalarWhereInput[]
    id?: StringFilter<"WorkSpace_users"> | string
    userId?: StringFilter<"WorkSpace_users"> | string
    workspaceId?: StringFilter<"WorkSpace_users"> | string
    role?: EnumRoleFilter<"WorkSpace_users"> | $Enums.Role
    createdAt?: DateTimeFilter<"WorkSpace_users"> | Date | string
  }

  export type teamUpsertWithWhereUniqueWithoutCreatorInput = {
    where: teamWhereUniqueInput
    update: XOR<teamUpdateWithoutCreatorInput, teamUncheckedUpdateWithoutCreatorInput>
    create: XOR<teamCreateWithoutCreatorInput, teamUncheckedCreateWithoutCreatorInput>
  }

  export type teamUpdateWithWhereUniqueWithoutCreatorInput = {
    where: teamWhereUniqueInput
    data: XOR<teamUpdateWithoutCreatorInput, teamUncheckedUpdateWithoutCreatorInput>
  }

  export type teamUpdateManyWithWhereWithoutCreatorInput = {
    where: teamScalarWhereInput
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyWithoutCreatorInput>
  }

  export type teamScalarWhereInput = {
    AND?: teamScalarWhereInput | teamScalarWhereInput[]
    OR?: teamScalarWhereInput[]
    NOT?: teamScalarWhereInput | teamScalarWhereInput[]
    id?: StringFilter<"team"> | string
    creatorId?: StringFilter<"team"> | string
    workspaceId?: StringFilter<"team"> | string
    teamName?: StringFilter<"team"> | string
    description?: StringNullableFilter<"team"> | string | null
    createdAt?: DateTimeFilter<"team"> | Date | string
  }

  export type alertUpsertWithWhereUniqueWithoutUserInput = {
    where: alertWhereUniqueInput
    update: XOR<alertUpdateWithoutUserInput, alertUncheckedUpdateWithoutUserInput>
    create: XOR<alertCreateWithoutUserInput, alertUncheckedCreateWithoutUserInput>
  }

  export type alertUpdateWithWhereUniqueWithoutUserInput = {
    where: alertWhereUniqueInput
    data: XOR<alertUpdateWithoutUserInput, alertUncheckedUpdateWithoutUserInput>
  }

  export type alertUpdateManyWithWhereWithoutUserInput = {
    where: alertScalarWhereInput
    data: XOR<alertUpdateManyMutationInput, alertUncheckedUpdateManyWithoutUserInput>
  }

  export type alertScalarWhereInput = {
    AND?: alertScalarWhereInput | alertScalarWhereInput[]
    OR?: alertScalarWhereInput[]
    NOT?: alertScalarWhereInput | alertScalarWhereInput[]
    id?: StringFilter<"alert"> | string
    acknowledged?: BoolFilter<"alert"> | boolean
    monitor_configId?: StringFilter<"alert"> | string
    userId?: StringNullableFilter<"alert"> | string | null
    workspaceId?: StringFilter<"alert"> | string
    createdAt?: DateTimeFilter<"alert"> | Date | string
  }

  export type escalation_policy_rulesUpsertWithWhereUniqueWithoutUserInput = {
    where: escalation_policy_rulesWhereUniqueInput
    update: XOR<escalation_policy_rulesUpdateWithoutUserInput, escalation_policy_rulesUncheckedUpdateWithoutUserInput>
    create: XOR<escalation_policy_rulesCreateWithoutUserInput, escalation_policy_rulesUncheckedCreateWithoutUserInput>
  }

  export type escalation_policy_rulesUpdateWithWhereUniqueWithoutUserInput = {
    where: escalation_policy_rulesWhereUniqueInput
    data: XOR<escalation_policy_rulesUpdateWithoutUserInput, escalation_policy_rulesUncheckedUpdateWithoutUserInput>
  }

  export type escalation_policy_rulesUpdateManyWithWhereWithoutUserInput = {
    where: escalation_policy_rulesScalarWhereInput
    data: XOR<escalation_policy_rulesUpdateManyMutationInput, escalation_policy_rulesUncheckedUpdateManyWithoutUserInput>
  }

  export type escalation_policy_rulesScalarWhereInput = {
    AND?: escalation_policy_rulesScalarWhereInput | escalation_policy_rulesScalarWhereInput[]
    OR?: escalation_policy_rulesScalarWhereInput[]
    NOT?: escalation_policy_rulesScalarWhereInput | escalation_policy_rulesScalarWhereInput[]
    id?: StringFilter<"escalation_policy_rules"> | string
    team_escalationpolicyId?: StringFilter<"escalation_policy_rules"> | string
    alert_status?: StringFilter<"escalation_policy_rules"> | string
    minutes_after_creation?: IntFilter<"escalation_policy_rules"> | number
    notification_type?: Enumnotification_typeFilter<"escalation_policy_rules"> | $Enums.notification_type
    userId?: StringNullableFilter<"escalation_policy_rules"> | string | null
    scheudleId?: StringNullableFilter<"escalation_policy_rules"> | string | null
    teamId?: StringNullableFilter<"escalation_policy_rules"> | string | null
    is_active?: BoolFilter<"escalation_policy_rules"> | boolean
  }

  export type user_otpUpsertWithWhereUniqueWithoutUserInput = {
    where: user_otpWhereUniqueInput
    update: XOR<user_otpUpdateWithoutUserInput, user_otpUncheckedUpdateWithoutUserInput>
    create: XOR<user_otpCreateWithoutUserInput, user_otpUncheckedCreateWithoutUserInput>
  }

  export type user_otpUpdateWithWhereUniqueWithoutUserInput = {
    where: user_otpWhereUniqueInput
    data: XOR<user_otpUpdateWithoutUserInput, user_otpUncheckedUpdateWithoutUserInput>
  }

  export type user_otpUpdateManyWithWhereWithoutUserInput = {
    where: user_otpScalarWhereInput
    data: XOR<user_otpUpdateManyMutationInput, user_otpUncheckedUpdateManyWithoutUserInput>
  }

  export type user_otpScalarWhereInput = {
    AND?: user_otpScalarWhereInput | user_otpScalarWhereInput[]
    OR?: user_otpScalarWhereInput[]
    NOT?: user_otpScalarWhereInput | user_otpScalarWhereInput[]
    id?: StringFilter<"user_otp"> | string
    userId?: StringFilter<"user_otp"> | string
    otp?: StringFilter<"user_otp"> | string
    invalid?: BoolFilter<"user_otp"> | boolean
    expiresAt?: IntFilter<"user_otp"> | number
    createdAt?: DateTimeFilter<"user_otp"> | Date | string
  }

  export type team_schedule_rotationUpsertWithWhereUniqueWithoutUserInput = {
    where: team_schedule_rotationWhereUniqueInput
    update: XOR<team_schedule_rotationUpdateWithoutUserInput, team_schedule_rotationUncheckedUpdateWithoutUserInput>
    create: XOR<team_schedule_rotationCreateWithoutUserInput, team_schedule_rotationUncheckedCreateWithoutUserInput>
  }

  export type team_schedule_rotationUpdateWithWhereUniqueWithoutUserInput = {
    where: team_schedule_rotationWhereUniqueInput
    data: XOR<team_schedule_rotationUpdateWithoutUserInput, team_schedule_rotationUncheckedUpdateWithoutUserInput>
  }

  export type team_schedule_rotationUpdateManyWithWhereWithoutUserInput = {
    where: team_schedule_rotationScalarWhereInput
    data: XOR<team_schedule_rotationUpdateManyMutationInput, team_schedule_rotationUncheckedUpdateManyWithoutUserInput>
  }

  export type team_schedule_rotationScalarWhereInput = {
    AND?: team_schedule_rotationScalarWhereInput | team_schedule_rotationScalarWhereInput[]
    OR?: team_schedule_rotationScalarWhereInput[]
    NOT?: team_schedule_rotationScalarWhereInput | team_schedule_rotationScalarWhereInput[]
    id?: StringFilter<"team_schedule_rotation"> | string
    team_scheduleId?: StringFilter<"team_schedule_rotation"> | string
    name?: StringFilter<"team_schedule_rotation"> | string
    userId?: StringFilter<"team_schedule_rotation"> | string
    starts_on?: DateTimeFilter<"team_schedule_rotation"> | Date | string
    frequency?: EnumFrequencyFilter<"team_schedule_rotation"> | $Enums.Frequency
    ends_on?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    custom_start_date_time?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    custom_end_date_time?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    restrict_time_type?: EnumRestrictionNullableFilter<"team_schedule_rotation"> | $Enums.Restriction | null
    restrict_time_start?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
    restrict_time_end?: DateTimeNullableFilter<"team_schedule_rotation"> | Date | string | null
  }

  export type UserCreateWithoutUser_otpInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutUserInput
    teams?: teamCreateNestedManyWithoutCreatorInput
    alert?: alertCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutUser_otpInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceUncheckedCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutUserInput
    teams?: teamUncheckedCreateNestedManyWithoutCreatorInput
    alert?: alertUncheckedCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutUser_otpInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutUser_otpInput, UserUncheckedCreateWithoutUser_otpInput>
  }

  export type UserUpsertWithoutUser_otpInput = {
    update: XOR<UserUpdateWithoutUser_otpInput, UserUncheckedUpdateWithoutUser_otpInput>
    create: XOR<UserCreateWithoutUser_otpInput, UserUncheckedCreateWithoutUser_otpInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutUser_otpInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutUser_otpInput, UserUncheckedUpdateWithoutUser_otpInput>
  }

  export type UserUpdateWithoutUser_otpInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutUserNestedInput
    teams?: teamUpdateManyWithoutCreatorNestedInput
    alert?: alertUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutUser_otpInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUncheckedUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUncheckedUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutUserNestedInput
    teams?: teamUncheckedUpdateManyWithoutCreatorNestedInput
    alert?: alertUncheckedUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMonitor_configInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    workspace?: WorkSpaceCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutUserInput
    teams?: teamCreateNestedManyWithoutCreatorInput
    alert?: alertCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutUserInput
    user_otp?: user_otpCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMonitor_configInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    workspace?: WorkSpaceUncheckedCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutUserInput
    teams?: teamUncheckedCreateNestedManyWithoutCreatorInput
    alert?: alertUncheckedCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutUserInput
    user_otp?: user_otpUncheckedCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMonitor_configInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMonitor_configInput, UserUncheckedCreateWithoutMonitor_configInput>
  }

  export type WorkSpaceCreateWithoutMonitor_configInput = {
    id?: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    owner: UserCreateNestedOneWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersCreateNestedManyWithoutWokspaceInput
    team?: teamCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberCreateNestedManyWithoutWorkspaceInput
    alert?: alertCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceUncheckedCreateWithoutMonitor_configInput = {
    id?: string
    ownerId: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersUncheckedCreateNestedManyWithoutWokspaceInput
    team?: teamUncheckedCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberUncheckedCreateNestedManyWithoutWorkspaceInput
    alert?: alertUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceCreateOrConnectWithoutMonitor_configInput = {
    where: WorkSpaceWhereUniqueInput
    create: XOR<WorkSpaceCreateWithoutMonitor_configInput, WorkSpaceUncheckedCreateWithoutMonitor_configInput>
  }

  export type Monitor_HTTP_gPRC_configCreateWithoutMonitor_configInput = {
    id?: string
    authType: string
    interval_check?: string | null
    userName?: string | null
    password?: string | null
    inital_token?: string | null
    refresh_token?: string | null
    header_key?: string | null
    header_value?: string | null
    endpoint_url?: string | null
    failure_count?: string | null
    success_count?: string | null
    success_response_code?: string | null
  }

  export type Monitor_HTTP_gPRC_configUncheckedCreateWithoutMonitor_configInput = {
    id?: string
    authType: string
    interval_check?: string | null
    userName?: string | null
    password?: string | null
    inital_token?: string | null
    refresh_token?: string | null
    header_key?: string | null
    header_value?: string | null
    endpoint_url?: string | null
    failure_count?: string | null
    success_count?: string | null
    success_response_code?: string | null
  }

  export type Monitor_HTTP_gPRC_configCreateOrConnectWithoutMonitor_configInput = {
    where: Monitor_HTTP_gPRC_configWhereUniqueInput
    create: XOR<Monitor_HTTP_gPRC_configCreateWithoutMonitor_configInput, Monitor_HTTP_gPRC_configUncheckedCreateWithoutMonitor_configInput>
  }

  export type Monitor_SSL_configCreateWithoutMonitor_configInput = {
    id?: string
    endpoint_url?: string | null
    alt_names?: string | null
    is_wildcard?: boolean
    wildcard_url?: string | null
    certifcate_issue?: Date | string | null
    certificate_tenure?: string | null
    expiry_reminder?: string | null
  }

  export type Monitor_SSL_configUncheckedCreateWithoutMonitor_configInput = {
    id?: string
    endpoint_url?: string | null
    alt_names?: string | null
    is_wildcard?: boolean
    wildcard_url?: string | null
    certifcate_issue?: Date | string | null
    certificate_tenure?: string | null
    expiry_reminder?: string | null
  }

  export type Monitor_SSL_configCreateOrConnectWithoutMonitor_configInput = {
    where: Monitor_SSL_configWhereUniqueInput
    create: XOR<Monitor_SSL_configCreateWithoutMonitor_configInput, Monitor_SSL_configUncheckedCreateWithoutMonitor_configInput>
  }

  export type Monitor_System_componentsCreateWithoutMonitor_configInput = {
    id?: string
    components_lists?: Monitor_System_componentsCreatecomponents_listsInput | string[]
    is_cloud?: boolean
    cloud_service_url?: string | null
    cloud_userName?: string | null
    cloud_password?: string | null
    cloud_downloadUrl?: string | null
  }

  export type Monitor_System_componentsUncheckedCreateWithoutMonitor_configInput = {
    id?: string
    components_lists?: Monitor_System_componentsCreatecomponents_listsInput | string[]
    is_cloud?: boolean
    cloud_service_url?: string | null
    cloud_userName?: string | null
    cloud_password?: string | null
    cloud_downloadUrl?: string | null
  }

  export type Monitor_System_componentsCreateOrConnectWithoutMonitor_configInput = {
    where: Monitor_System_componentsWhereUniqueInput
    create: XOR<Monitor_System_componentsCreateWithoutMonitor_configInput, Monitor_System_componentsUncheckedCreateWithoutMonitor_configInput>
  }

  export type teamCreateWithoutMonitor_configInput = {
    id?: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutTeamsInput
    workspace: WorkSpaceCreateNestedOneWithoutTeamInput
    team_member?: team_memberCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutMonitor_configInput = {
    id?: string
    creatorId: string
    workspaceId: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    team_member?: team_memberUncheckedCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyUncheckedCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutMonitor_configInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutMonitor_configInput, teamUncheckedCreateWithoutMonitor_configInput>
  }

  export type alertCreateWithoutMonitor_configInput = {
    id?: string
    acknowledged?: boolean
    createdAt?: Date | string
    user?: UserCreateNestedOneWithoutAlertInput
    workspace: WorkSpaceCreateNestedOneWithoutAlertInput
  }

  export type alertUncheckedCreateWithoutMonitor_configInput = {
    id?: string
    acknowledged?: boolean
    userId?: string | null
    workspaceId: string
    createdAt?: Date | string
  }

  export type alertCreateOrConnectWithoutMonitor_configInput = {
    where: alertWhereUniqueInput
    create: XOR<alertCreateWithoutMonitor_configInput, alertUncheckedCreateWithoutMonitor_configInput>
  }

  export type alertCreateManyMonitor_configInputEnvelope = {
    data: alertCreateManyMonitor_configInput | alertCreateManyMonitor_configInput[]
  }

  export type UserUpsertWithoutMonitor_configInput = {
    update: XOR<UserUpdateWithoutMonitor_configInput, UserUncheckedUpdateWithoutMonitor_configInput>
    create: XOR<UserCreateWithoutMonitor_configInput, UserUncheckedCreateWithoutMonitor_configInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMonitor_configInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMonitor_configInput, UserUncheckedUpdateWithoutMonitor_configInput>
  }

  export type UserUpdateWithoutMonitor_configInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    workspace?: WorkSpaceUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutUserNestedInput
    teams?: teamUpdateManyWithoutCreatorNestedInput
    alert?: alertUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMonitor_configInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    workspace?: WorkSpaceUncheckedUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutUserNestedInput
    teams?: teamUncheckedUpdateManyWithoutCreatorNestedInput
    alert?: alertUncheckedUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUncheckedUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkSpaceUpsertWithoutMonitor_configInput = {
    update: XOR<WorkSpaceUpdateWithoutMonitor_configInput, WorkSpaceUncheckedUpdateWithoutMonitor_configInput>
    create: XOR<WorkSpaceCreateWithoutMonitor_configInput, WorkSpaceUncheckedCreateWithoutMonitor_configInput>
    where?: WorkSpaceWhereInput
  }

  export type WorkSpaceUpdateToOneWithWhereWithoutMonitor_configInput = {
    where?: WorkSpaceWhereInput
    data: XOR<WorkSpaceUpdateWithoutMonitor_configInput, WorkSpaceUncheckedUpdateWithoutMonitor_configInput>
  }

  export type WorkSpaceUpdateWithoutMonitor_configInput = {
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUpdateManyWithoutWokspaceNestedInput
    team?: teamUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkSpaceUncheckedUpdateWithoutMonitor_configInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUncheckedUpdateManyWithoutWokspaceNestedInput
    team?: teamUncheckedUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUncheckedUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type Monitor_HTTP_gPRC_configUpsertWithoutMonitor_configInput = {
    update: XOR<Monitor_HTTP_gPRC_configUpdateWithoutMonitor_configInput, Monitor_HTTP_gPRC_configUncheckedUpdateWithoutMonitor_configInput>
    create: XOR<Monitor_HTTP_gPRC_configCreateWithoutMonitor_configInput, Monitor_HTTP_gPRC_configUncheckedCreateWithoutMonitor_configInput>
    where?: Monitor_HTTP_gPRC_configWhereInput
  }

  export type Monitor_HTTP_gPRC_configUpdateToOneWithWhereWithoutMonitor_configInput = {
    where?: Monitor_HTTP_gPRC_configWhereInput
    data: XOR<Monitor_HTTP_gPRC_configUpdateWithoutMonitor_configInput, Monitor_HTTP_gPRC_configUncheckedUpdateWithoutMonitor_configInput>
  }

  export type Monitor_HTTP_gPRC_configUpdateWithoutMonitor_configInput = {
    authType?: StringFieldUpdateOperationsInput | string
    interval_check?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    inital_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    header_key?: NullableStringFieldUpdateOperationsInput | string | null
    header_value?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    failure_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_response_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_HTTP_gPRC_configUncheckedUpdateWithoutMonitor_configInput = {
    authType?: StringFieldUpdateOperationsInput | string
    interval_check?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    inital_token?: NullableStringFieldUpdateOperationsInput | string | null
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    header_key?: NullableStringFieldUpdateOperationsInput | string | null
    header_value?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    failure_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_count?: NullableStringFieldUpdateOperationsInput | string | null
    success_response_code?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_SSL_configUpsertWithoutMonitor_configInput = {
    update: XOR<Monitor_SSL_configUpdateWithoutMonitor_configInput, Monitor_SSL_configUncheckedUpdateWithoutMonitor_configInput>
    create: XOR<Monitor_SSL_configCreateWithoutMonitor_configInput, Monitor_SSL_configUncheckedCreateWithoutMonitor_configInput>
    where?: Monitor_SSL_configWhereInput
  }

  export type Monitor_SSL_configUpdateToOneWithWhereWithoutMonitor_configInput = {
    where?: Monitor_SSL_configWhereInput
    data: XOR<Monitor_SSL_configUpdateWithoutMonitor_configInput, Monitor_SSL_configUncheckedUpdateWithoutMonitor_configInput>
  }

  export type Monitor_SSL_configUpdateWithoutMonitor_configInput = {
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_names?: NullableStringFieldUpdateOperationsInput | string | null
    is_wildcard?: BoolFieldUpdateOperationsInput | boolean
    wildcard_url?: NullableStringFieldUpdateOperationsInput | string | null
    certifcate_issue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_tenure?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_reminder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_SSL_configUncheckedUpdateWithoutMonitor_configInput = {
    endpoint_url?: NullableStringFieldUpdateOperationsInput | string | null
    alt_names?: NullableStringFieldUpdateOperationsInput | string | null
    is_wildcard?: BoolFieldUpdateOperationsInput | boolean
    wildcard_url?: NullableStringFieldUpdateOperationsInput | string | null
    certifcate_issue?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificate_tenure?: NullableStringFieldUpdateOperationsInput | string | null
    expiry_reminder?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_System_componentsUpsertWithoutMonitor_configInput = {
    update: XOR<Monitor_System_componentsUpdateWithoutMonitor_configInput, Monitor_System_componentsUncheckedUpdateWithoutMonitor_configInput>
    create: XOR<Monitor_System_componentsCreateWithoutMonitor_configInput, Monitor_System_componentsUncheckedCreateWithoutMonitor_configInput>
    where?: Monitor_System_componentsWhereInput
  }

  export type Monitor_System_componentsUpdateToOneWithWhereWithoutMonitor_configInput = {
    where?: Monitor_System_componentsWhereInput
    data: XOR<Monitor_System_componentsUpdateWithoutMonitor_configInput, Monitor_System_componentsUncheckedUpdateWithoutMonitor_configInput>
  }

  export type Monitor_System_componentsUpdateWithoutMonitor_configInput = {
    components_lists?: Monitor_System_componentsUpdatecomponents_listsInput | string[]
    is_cloud?: BoolFieldUpdateOperationsInput | boolean
    cloud_service_url?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_userName?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_password?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Monitor_System_componentsUncheckedUpdateWithoutMonitor_configInput = {
    components_lists?: Monitor_System_componentsUpdatecomponents_listsInput | string[]
    is_cloud?: BoolFieldUpdateOperationsInput | boolean
    cloud_service_url?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_userName?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_password?: NullableStringFieldUpdateOperationsInput | string | null
    cloud_downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type teamUpsertWithoutMonitor_configInput = {
    update: XOR<teamUpdateWithoutMonitor_configInput, teamUncheckedUpdateWithoutMonitor_configInput>
    create: XOR<teamCreateWithoutMonitor_configInput, teamUncheckedCreateWithoutMonitor_configInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutMonitor_configInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutMonitor_configInput, teamUncheckedUpdateWithoutMonitor_configInput>
  }

  export type teamUpdateWithoutMonitor_configInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTeamsNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutTeamNestedInput
    team_member?: team_memberUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutMonitor_configInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_member?: team_memberUncheckedUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUncheckedUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type alertUpsertWithWhereUniqueWithoutMonitor_configInput = {
    where: alertWhereUniqueInput
    update: XOR<alertUpdateWithoutMonitor_configInput, alertUncheckedUpdateWithoutMonitor_configInput>
    create: XOR<alertCreateWithoutMonitor_configInput, alertUncheckedCreateWithoutMonitor_configInput>
  }

  export type alertUpdateWithWhereUniqueWithoutMonitor_configInput = {
    where: alertWhereUniqueInput
    data: XOR<alertUpdateWithoutMonitor_configInput, alertUncheckedUpdateWithoutMonitor_configInput>
  }

  export type alertUpdateManyWithWhereWithoutMonitor_configInput = {
    where: alertScalarWhereInput
    data: XOR<alertUpdateManyMutationInput, alertUncheckedUpdateManyWithoutMonitor_configInput>
  }

  export type Monitor_configCreateWithoutMonitor_HTTP_gPRC_configInput = {
    id?: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMonitor_configInput
    workspace?: WorkSpaceCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsCreateNestedOneWithoutMonitor_configInput
    team?: teamCreateNestedOneWithoutMonitor_configInput
    alert?: alertCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configUncheckedCreateWithoutMonitor_HTTP_gPRC_configInput = {
    id?: string
    userId: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    workspaceId?: string | null
    teamId?: string | null
    createdAt?: Date | string
    Monitor_SSL_config?: Monitor_SSL_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsUncheckedCreateNestedOneWithoutMonitor_configInput
    alert?: alertUncheckedCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configCreateOrConnectWithoutMonitor_HTTP_gPRC_configInput = {
    where: Monitor_configWhereUniqueInput
    create: XOR<Monitor_configCreateWithoutMonitor_HTTP_gPRC_configInput, Monitor_configUncheckedCreateWithoutMonitor_HTTP_gPRC_configInput>
  }

  export type Monitor_configUpsertWithoutMonitor_HTTP_gPRC_configInput = {
    update: XOR<Monitor_configUpdateWithoutMonitor_HTTP_gPRC_configInput, Monitor_configUncheckedUpdateWithoutMonitor_HTTP_gPRC_configInput>
    create: XOR<Monitor_configCreateWithoutMonitor_HTTP_gPRC_configInput, Monitor_configUncheckedCreateWithoutMonitor_HTTP_gPRC_configInput>
    where?: Monitor_configWhereInput
  }

  export type Monitor_configUpdateToOneWithWhereWithoutMonitor_HTTP_gPRC_configInput = {
    where?: Monitor_configWhereInput
    data: XOR<Monitor_configUpdateWithoutMonitor_HTTP_gPRC_configInput, Monitor_configUncheckedUpdateWithoutMonitor_HTTP_gPRC_configInput>
  }

  export type Monitor_configUpdateWithoutMonitor_HTTP_gPRC_configInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMonitor_configNestedInput
    workspace?: WorkSpaceUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUpdateOneWithoutMonitor_configNestedInput
    team?: teamUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configUncheckedUpdateWithoutMonitor_HTTP_gPRC_configInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Monitor_SSL_config?: Monitor_SSL_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUncheckedUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUncheckedUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configCreateWithoutMonitor_SSL_configInput = {
    id?: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMonitor_configInput
    workspace?: WorkSpaceCreateNestedOneWithoutMonitor_configInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsCreateNestedOneWithoutMonitor_configInput
    team?: teamCreateNestedOneWithoutMonitor_configInput
    alert?: alertCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configUncheckedCreateWithoutMonitor_SSL_configInput = {
    id?: string
    userId: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    workspaceId?: string | null
    teamId?: string | null
    createdAt?: Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsUncheckedCreateNestedOneWithoutMonitor_configInput
    alert?: alertUncheckedCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configCreateOrConnectWithoutMonitor_SSL_configInput = {
    where: Monitor_configWhereUniqueInput
    create: XOR<Monitor_configCreateWithoutMonitor_SSL_configInput, Monitor_configUncheckedCreateWithoutMonitor_SSL_configInput>
  }

  export type Monitor_configUpsertWithoutMonitor_SSL_configInput = {
    update: XOR<Monitor_configUpdateWithoutMonitor_SSL_configInput, Monitor_configUncheckedUpdateWithoutMonitor_SSL_configInput>
    create: XOR<Monitor_configCreateWithoutMonitor_SSL_configInput, Monitor_configUncheckedCreateWithoutMonitor_SSL_configInput>
    where?: Monitor_configWhereInput
  }

  export type Monitor_configUpdateToOneWithWhereWithoutMonitor_SSL_configInput = {
    where?: Monitor_configWhereInput
    data: XOR<Monitor_configUpdateWithoutMonitor_SSL_configInput, Monitor_configUncheckedUpdateWithoutMonitor_SSL_configInput>
  }

  export type Monitor_configUpdateWithoutMonitor_SSL_configInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMonitor_configNestedInput
    workspace?: WorkSpaceUpdateOneWithoutMonitor_configNestedInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUpdateOneWithoutMonitor_configNestedInput
    team?: teamUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configUncheckedUpdateWithoutMonitor_SSL_configInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUncheckedUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUncheckedUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configCreateWithoutMonitor_System_componentsInput = {
    id?: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMonitor_configInput
    workspace?: WorkSpaceCreateNestedOneWithoutMonitor_configInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configCreateNestedOneWithoutMonitor_configInput
    team?: teamCreateNestedOneWithoutMonitor_configInput
    alert?: alertCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configUncheckedCreateWithoutMonitor_System_componentsInput = {
    id?: string
    userId: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    workspaceId?: string | null
    teamId?: string | null
    createdAt?: Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedCreateNestedOneWithoutMonitor_configInput
    alert?: alertUncheckedCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configCreateOrConnectWithoutMonitor_System_componentsInput = {
    where: Monitor_configWhereUniqueInput
    create: XOR<Monitor_configCreateWithoutMonitor_System_componentsInput, Monitor_configUncheckedCreateWithoutMonitor_System_componentsInput>
  }

  export type Monitor_configUpsertWithoutMonitor_System_componentsInput = {
    update: XOR<Monitor_configUpdateWithoutMonitor_System_componentsInput, Monitor_configUncheckedUpdateWithoutMonitor_System_componentsInput>
    create: XOR<Monitor_configCreateWithoutMonitor_System_componentsInput, Monitor_configUncheckedCreateWithoutMonitor_System_componentsInput>
    where?: Monitor_configWhereInput
  }

  export type Monitor_configUpdateToOneWithWhereWithoutMonitor_System_componentsInput = {
    where?: Monitor_configWhereInput
    data: XOR<Monitor_configUpdateWithoutMonitor_System_componentsInput, Monitor_configUncheckedUpdateWithoutMonitor_System_componentsInput>
  }

  export type Monitor_configUpdateWithoutMonitor_System_componentsInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMonitor_configNestedInput
    workspace?: WorkSpaceUpdateOneWithoutMonitor_configNestedInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUpdateOneWithoutMonitor_configNestedInput
    team?: teamUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configUncheckedUpdateWithoutMonitor_System_componentsInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUncheckedUpdateManyWithoutMonitor_configNestedInput
  }

  export type UserCreateWithoutWorkspaceInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configCreateNestedManyWithoutUserInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutUserInput
    teams?: teamCreateNestedManyWithoutCreatorInput
    alert?: alertCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutUserInput
    user_otp?: user_otpCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutUserInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutUserInput
    teams?: teamUncheckedCreateNestedManyWithoutCreatorInput
    alert?: alertUncheckedCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutUserInput
    user_otp?: user_otpUncheckedCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkspaceInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspaceInput, UserUncheckedCreateWithoutWorkspaceInput>
  }

  export type Monitor_configCreateWithoutWorkspaceInput = {
    id?: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMonitor_configInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsCreateNestedOneWithoutMonitor_configInput
    team?: teamCreateNestedOneWithoutMonitor_configInput
    alert?: alertCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    teamId?: string | null
    createdAt?: Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsUncheckedCreateNestedOneWithoutMonitor_configInput
    alert?: alertUncheckedCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configCreateOrConnectWithoutWorkspaceInput = {
    where: Monitor_configWhereUniqueInput
    create: XOR<Monitor_configCreateWithoutWorkspaceInput, Monitor_configUncheckedCreateWithoutWorkspaceInput>
  }

  export type Monitor_configCreateManyWorkspaceInputEnvelope = {
    data: Monitor_configCreateManyWorkspaceInput | Monitor_configCreateManyWorkspaceInput[]
  }

  export type WorkSpace_usersCreateWithoutWorkspaceInput = {
    id?: string
    role?: $Enums.Role
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspace_usersInput
    team_member?: team_memberCreateNestedManyWithoutWorkspace_userInput
  }

  export type WorkSpace_usersUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    userId: string
    role?: $Enums.Role
    createdAt?: Date | string
    team_member?: team_memberUncheckedCreateNestedManyWithoutWorkspace_userInput
  }

  export type WorkSpace_usersCreateOrConnectWithoutWorkspaceInput = {
    where: WorkSpace_usersWhereUniqueInput
    create: XOR<WorkSpace_usersCreateWithoutWorkspaceInput, WorkSpace_usersUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkSpace_usersCreateManyWorkspaceInputEnvelope = {
    data: WorkSpace_usersCreateManyWorkspaceInput | WorkSpace_usersCreateManyWorkspaceInput[]
  }

  export type invited_usersCreateWithoutWokspaceInput = {
    id?: string
    invited_user_name: string
    invited_user_email_id: string
    invited_by: string
    role: $Enums.Role
    status: $Enums.status
    invited_on?: Date | string
  }

  export type invited_usersUncheckedCreateWithoutWokspaceInput = {
    id?: string
    invited_user_name: string
    invited_user_email_id: string
    invited_by: string
    role: $Enums.Role
    status: $Enums.status
    invited_on?: Date | string
  }

  export type invited_usersCreateOrConnectWithoutWokspaceInput = {
    where: invited_usersWhereUniqueInput
    create: XOR<invited_usersCreateWithoutWokspaceInput, invited_usersUncheckedCreateWithoutWokspaceInput>
  }

  export type invited_usersCreateManyWokspaceInputEnvelope = {
    data: invited_usersCreateManyWokspaceInput | invited_usersCreateManyWokspaceInput[]
  }

  export type teamCreateWithoutWorkspaceInput = {
    id?: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutTeamsInput
    team_member?: team_memberCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    creatorId: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    team_member?: team_memberUncheckedCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyUncheckedCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutWorkspaceInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutWorkspaceInput, teamUncheckedCreateWithoutWorkspaceInput>
  }

  export type teamCreateManyWorkspaceInputEnvelope = {
    data: teamCreateManyWorkspaceInput | teamCreateManyWorkspaceInput[]
  }

  export type team_memberCreateWithoutWorkspaceInput = {
    id?: string
    team: teamCreateNestedOneWithoutTeam_memberInput
    workspace_user: WorkSpace_usersCreateNestedOneWithoutTeam_memberInput
  }

  export type team_memberUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    teamId: string
    workspace_userId: string
  }

  export type team_memberCreateOrConnectWithoutWorkspaceInput = {
    where: team_memberWhereUniqueInput
    create: XOR<team_memberCreateWithoutWorkspaceInput, team_memberUncheckedCreateWithoutWorkspaceInput>
  }

  export type team_memberCreateManyWorkspaceInputEnvelope = {
    data: team_memberCreateManyWorkspaceInput | team_memberCreateManyWorkspaceInput[]
  }

  export type alertCreateWithoutWorkspaceInput = {
    id?: string
    acknowledged?: boolean
    createdAt?: Date | string
    monitor_config: Monitor_configCreateNestedOneWithoutAlertInput
    user?: UserCreateNestedOneWithoutAlertInput
  }

  export type alertUncheckedCreateWithoutWorkspaceInput = {
    id?: string
    acknowledged?: boolean
    monitor_configId: string
    userId?: string | null
    createdAt?: Date | string
  }

  export type alertCreateOrConnectWithoutWorkspaceInput = {
    where: alertWhereUniqueInput
    create: XOR<alertCreateWithoutWorkspaceInput, alertUncheckedCreateWithoutWorkspaceInput>
  }

  export type alertCreateManyWorkspaceInputEnvelope = {
    data: alertCreateManyWorkspaceInput | alertCreateManyWorkspaceInput[]
  }

  export type UserUpsertWithoutWorkspaceInput = {
    update: XOR<UserUpdateWithoutWorkspaceInput, UserUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<UserCreateWithoutWorkspaceInput, UserUncheckedCreateWithoutWorkspaceInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspaceInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspaceInput, UserUncheckedUpdateWithoutWorkspaceInput>
  }

  export type UserUpdateWithoutWorkspaceInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUpdateManyWithoutUserNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutUserNestedInput
    teams?: teamUpdateManyWithoutCreatorNestedInput
    alert?: alertUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspaceInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUncheckedUpdateManyWithoutUserNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutUserNestedInput
    teams?: teamUncheckedUpdateManyWithoutCreatorNestedInput
    alert?: alertUncheckedUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUncheckedUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type Monitor_configUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: Monitor_configWhereUniqueInput
    update: XOR<Monitor_configUpdateWithoutWorkspaceInput, Monitor_configUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<Monitor_configCreateWithoutWorkspaceInput, Monitor_configUncheckedCreateWithoutWorkspaceInput>
  }

  export type Monitor_configUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: Monitor_configWhereUniqueInput
    data: XOR<Monitor_configUpdateWithoutWorkspaceInput, Monitor_configUncheckedUpdateWithoutWorkspaceInput>
  }

  export type Monitor_configUpdateManyWithWhereWithoutWorkspaceInput = {
    where: Monitor_configScalarWhereInput
    data: XOR<Monitor_configUpdateManyMutationInput, Monitor_configUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkSpace_usersUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkSpace_usersWhereUniqueInput
    update: XOR<WorkSpace_usersUpdateWithoutWorkspaceInput, WorkSpace_usersUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<WorkSpace_usersCreateWithoutWorkspaceInput, WorkSpace_usersUncheckedCreateWithoutWorkspaceInput>
  }

  export type WorkSpace_usersUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: WorkSpace_usersWhereUniqueInput
    data: XOR<WorkSpace_usersUpdateWithoutWorkspaceInput, WorkSpace_usersUncheckedUpdateWithoutWorkspaceInput>
  }

  export type WorkSpace_usersUpdateManyWithWhereWithoutWorkspaceInput = {
    where: WorkSpace_usersScalarWhereInput
    data: XOR<WorkSpace_usersUpdateManyMutationInput, WorkSpace_usersUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type invited_usersUpsertWithWhereUniqueWithoutWokspaceInput = {
    where: invited_usersWhereUniqueInput
    update: XOR<invited_usersUpdateWithoutWokspaceInput, invited_usersUncheckedUpdateWithoutWokspaceInput>
    create: XOR<invited_usersCreateWithoutWokspaceInput, invited_usersUncheckedCreateWithoutWokspaceInput>
  }

  export type invited_usersUpdateWithWhereUniqueWithoutWokspaceInput = {
    where: invited_usersWhereUniqueInput
    data: XOR<invited_usersUpdateWithoutWokspaceInput, invited_usersUncheckedUpdateWithoutWokspaceInput>
  }

  export type invited_usersUpdateManyWithWhereWithoutWokspaceInput = {
    where: invited_usersScalarWhereInput
    data: XOR<invited_usersUpdateManyMutationInput, invited_usersUncheckedUpdateManyWithoutWokspaceInput>
  }

  export type invited_usersScalarWhereInput = {
    AND?: invited_usersScalarWhereInput | invited_usersScalarWhereInput[]
    OR?: invited_usersScalarWhereInput[]
    NOT?: invited_usersScalarWhereInput | invited_usersScalarWhereInput[]
    id?: StringFilter<"invited_users"> | string
    invited_user_name?: StringFilter<"invited_users"> | string
    invited_user_email_id?: StringFilter<"invited_users"> | string
    invited_by?: StringFilter<"invited_users"> | string
    workspaceId?: StringFilter<"invited_users"> | string
    role?: EnumRoleFilter<"invited_users"> | $Enums.Role
    status?: EnumstatusFilter<"invited_users"> | $Enums.status
    invited_on?: DateTimeFilter<"invited_users"> | Date | string
  }

  export type teamUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: teamWhereUniqueInput
    update: XOR<teamUpdateWithoutWorkspaceInput, teamUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<teamCreateWithoutWorkspaceInput, teamUncheckedCreateWithoutWorkspaceInput>
  }

  export type teamUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: teamWhereUniqueInput
    data: XOR<teamUpdateWithoutWorkspaceInput, teamUncheckedUpdateWithoutWorkspaceInput>
  }

  export type teamUpdateManyWithWhereWithoutWorkspaceInput = {
    where: teamScalarWhereInput
    data: XOR<teamUpdateManyMutationInput, teamUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type team_memberUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: team_memberWhereUniqueInput
    update: XOR<team_memberUpdateWithoutWorkspaceInput, team_memberUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<team_memberCreateWithoutWorkspaceInput, team_memberUncheckedCreateWithoutWorkspaceInput>
  }

  export type team_memberUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: team_memberWhereUniqueInput
    data: XOR<team_memberUpdateWithoutWorkspaceInput, team_memberUncheckedUpdateWithoutWorkspaceInput>
  }

  export type team_memberUpdateManyWithWhereWithoutWorkspaceInput = {
    where: team_memberScalarWhereInput
    data: XOR<team_memberUpdateManyMutationInput, team_memberUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type team_memberScalarWhereInput = {
    AND?: team_memberScalarWhereInput | team_memberScalarWhereInput[]
    OR?: team_memberScalarWhereInput[]
    NOT?: team_memberScalarWhereInput | team_memberScalarWhereInput[]
    id?: StringFilter<"team_member"> | string
    teamId?: StringFilter<"team_member"> | string
    workspace_userId?: StringFilter<"team_member"> | string
    workspaceId?: StringFilter<"team_member"> | string
  }

  export type alertUpsertWithWhereUniqueWithoutWorkspaceInput = {
    where: alertWhereUniqueInput
    update: XOR<alertUpdateWithoutWorkspaceInput, alertUncheckedUpdateWithoutWorkspaceInput>
    create: XOR<alertCreateWithoutWorkspaceInput, alertUncheckedCreateWithoutWorkspaceInput>
  }

  export type alertUpdateWithWhereUniqueWithoutWorkspaceInput = {
    where: alertWhereUniqueInput
    data: XOR<alertUpdateWithoutWorkspaceInput, alertUncheckedUpdateWithoutWorkspaceInput>
  }

  export type alertUpdateManyWithWhereWithoutWorkspaceInput = {
    where: alertScalarWhereInput
    data: XOR<alertUpdateManyMutationInput, alertUncheckedUpdateManyWithoutWorkspaceInput>
  }

  export type WorkSpaceCreateWithoutInvited_usersInput = {
    id?: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    owner: UserCreateNestedOneWithoutWorkspaceInput
    monitor_config?: Monitor_configCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutWorkspaceInput
    team?: teamCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberCreateNestedManyWithoutWorkspaceInput
    alert?: alertCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceUncheckedCreateWithoutInvited_usersInput = {
    id?: string
    ownerId: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutWorkspaceInput
    team?: teamUncheckedCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberUncheckedCreateNestedManyWithoutWorkspaceInput
    alert?: alertUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceCreateOrConnectWithoutInvited_usersInput = {
    where: WorkSpaceWhereUniqueInput
    create: XOR<WorkSpaceCreateWithoutInvited_usersInput, WorkSpaceUncheckedCreateWithoutInvited_usersInput>
  }

  export type WorkSpaceUpsertWithoutInvited_usersInput = {
    update: XOR<WorkSpaceUpdateWithoutInvited_usersInput, WorkSpaceUncheckedUpdateWithoutInvited_usersInput>
    create: XOR<WorkSpaceCreateWithoutInvited_usersInput, WorkSpaceUncheckedCreateWithoutInvited_usersInput>
    where?: WorkSpaceWhereInput
  }

  export type WorkSpaceUpdateToOneWithWhereWithoutInvited_usersInput = {
    where?: WorkSpaceWhereInput
    data: XOR<WorkSpaceUpdateWithoutInvited_usersInput, WorkSpaceUncheckedUpdateWithoutInvited_usersInput>
  }

  export type WorkSpaceUpdateWithoutInvited_usersInput = {
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutWorkspaceNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutWorkspaceNestedInput
    team?: teamUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkSpaceUncheckedUpdateWithoutInvited_usersInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    team?: teamUncheckedUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUncheckedUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type UserCreateWithoutWorkspace_usersInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceCreateNestedManyWithoutOwnerInput
    teams?: teamCreateNestedManyWithoutCreatorInput
    alert?: alertCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutUserInput
    user_otp?: user_otpCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutWorkspace_usersInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceUncheckedCreateNestedManyWithoutOwnerInput
    teams?: teamUncheckedCreateNestedManyWithoutCreatorInput
    alert?: alertUncheckedCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutUserInput
    user_otp?: user_otpUncheckedCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutWorkspace_usersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutWorkspace_usersInput, UserUncheckedCreateWithoutWorkspace_usersInput>
  }

  export type WorkSpaceCreateWithoutWorkspace_usersInput = {
    id?: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    owner: UserCreateNestedOneWithoutWorkspaceInput
    monitor_config?: Monitor_configCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersCreateNestedManyWithoutWokspaceInput
    team?: teamCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberCreateNestedManyWithoutWorkspaceInput
    alert?: alertCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceUncheckedCreateWithoutWorkspace_usersInput = {
    id?: string
    ownerId: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersUncheckedCreateNestedManyWithoutWokspaceInput
    team?: teamUncheckedCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberUncheckedCreateNestedManyWithoutWorkspaceInput
    alert?: alertUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceCreateOrConnectWithoutWorkspace_usersInput = {
    where: WorkSpaceWhereUniqueInput
    create: XOR<WorkSpaceCreateWithoutWorkspace_usersInput, WorkSpaceUncheckedCreateWithoutWorkspace_usersInput>
  }

  export type team_memberCreateWithoutWorkspace_userInput = {
    id?: string
    team: teamCreateNestedOneWithoutTeam_memberInput
    workspace: WorkSpaceCreateNestedOneWithoutTeam_memberInput
  }

  export type team_memberUncheckedCreateWithoutWorkspace_userInput = {
    id?: string
    teamId: string
    workspaceId: string
  }

  export type team_memberCreateOrConnectWithoutWorkspace_userInput = {
    where: team_memberWhereUniqueInput
    create: XOR<team_memberCreateWithoutWorkspace_userInput, team_memberUncheckedCreateWithoutWorkspace_userInput>
  }

  export type team_memberCreateManyWorkspace_userInputEnvelope = {
    data: team_memberCreateManyWorkspace_userInput | team_memberCreateManyWorkspace_userInput[]
  }

  export type UserUpsertWithoutWorkspace_usersInput = {
    update: XOR<UserUpdateWithoutWorkspace_usersInput, UserUncheckedUpdateWithoutWorkspace_usersInput>
    create: XOR<UserCreateWithoutWorkspace_usersInput, UserUncheckedCreateWithoutWorkspace_usersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutWorkspace_usersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutWorkspace_usersInput, UserUncheckedUpdateWithoutWorkspace_usersInput>
  }

  export type UserUpdateWithoutWorkspace_usersInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUpdateManyWithoutOwnerNestedInput
    teams?: teamUpdateManyWithoutCreatorNestedInput
    alert?: alertUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutWorkspace_usersInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUncheckedUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUncheckedUpdateManyWithoutOwnerNestedInput
    teams?: teamUncheckedUpdateManyWithoutCreatorNestedInput
    alert?: alertUncheckedUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUncheckedUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkSpaceUpsertWithoutWorkspace_usersInput = {
    update: XOR<WorkSpaceUpdateWithoutWorkspace_usersInput, WorkSpaceUncheckedUpdateWithoutWorkspace_usersInput>
    create: XOR<WorkSpaceCreateWithoutWorkspace_usersInput, WorkSpaceUncheckedCreateWithoutWorkspace_usersInput>
    where?: WorkSpaceWhereInput
  }

  export type WorkSpaceUpdateToOneWithWhereWithoutWorkspace_usersInput = {
    where?: WorkSpaceWhereInput
    data: XOR<WorkSpaceUpdateWithoutWorkspace_usersInput, WorkSpaceUncheckedUpdateWithoutWorkspace_usersInput>
  }

  export type WorkSpaceUpdateWithoutWorkspace_usersInput = {
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutWorkspaceNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUpdateManyWithoutWokspaceNestedInput
    team?: teamUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkSpaceUncheckedUpdateWithoutWorkspace_usersInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUncheckedUpdateManyWithoutWokspaceNestedInput
    team?: teamUncheckedUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUncheckedUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type team_memberUpsertWithWhereUniqueWithoutWorkspace_userInput = {
    where: team_memberWhereUniqueInput
    update: XOR<team_memberUpdateWithoutWorkspace_userInput, team_memberUncheckedUpdateWithoutWorkspace_userInput>
    create: XOR<team_memberCreateWithoutWorkspace_userInput, team_memberUncheckedCreateWithoutWorkspace_userInput>
  }

  export type team_memberUpdateWithWhereUniqueWithoutWorkspace_userInput = {
    where: team_memberWhereUniqueInput
    data: XOR<team_memberUpdateWithoutWorkspace_userInput, team_memberUncheckedUpdateWithoutWorkspace_userInput>
  }

  export type team_memberUpdateManyWithWhereWithoutWorkspace_userInput = {
    where: team_memberScalarWhereInput
    data: XOR<team_memberUpdateManyMutationInput, team_memberUncheckedUpdateManyWithoutWorkspace_userInput>
  }

  export type UserCreateWithoutTeamsInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutUserInput
    alert?: alertCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutUserInput
    user_otp?: user_otpCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeamsInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceUncheckedCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutUserInput
    alert?: alertUncheckedCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutUserInput
    user_otp?: user_otpUncheckedCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeamsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
  }

  export type WorkSpaceCreateWithoutTeamInput = {
    id?: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    owner: UserCreateNestedOneWithoutWorkspaceInput
    monitor_config?: Monitor_configCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersCreateNestedManyWithoutWokspaceInput
    team_member?: team_memberCreateNestedManyWithoutWorkspaceInput
    alert?: alertCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceUncheckedCreateWithoutTeamInput = {
    id?: string
    ownerId: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersUncheckedCreateNestedManyWithoutWokspaceInput
    team_member?: team_memberUncheckedCreateNestedManyWithoutWorkspaceInput
    alert?: alertUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceCreateOrConnectWithoutTeamInput = {
    where: WorkSpaceWhereUniqueInput
    create: XOR<WorkSpaceCreateWithoutTeamInput, WorkSpaceUncheckedCreateWithoutTeamInput>
  }

  export type team_memberCreateWithoutTeamInput = {
    id?: string
    workspace_user: WorkSpace_usersCreateNestedOneWithoutTeam_memberInput
    workspace: WorkSpaceCreateNestedOneWithoutTeam_memberInput
  }

  export type team_memberUncheckedCreateWithoutTeamInput = {
    id?: string
    workspace_userId: string
    workspaceId: string
  }

  export type team_memberCreateOrConnectWithoutTeamInput = {
    where: team_memberWhereUniqueInput
    create: XOR<team_memberCreateWithoutTeamInput, team_memberUncheckedCreateWithoutTeamInput>
  }

  export type team_memberCreateManyTeamInputEnvelope = {
    data: team_memberCreateManyTeamInput | team_memberCreateManyTeamInput[]
  }

  export type Monitor_configCreateWithoutTeamInput = {
    id?: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMonitor_configInput
    workspace?: WorkSpaceCreateNestedOneWithoutMonitor_configInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsCreateNestedOneWithoutMonitor_configInput
    alert?: alertCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    workspaceId?: string | null
    createdAt?: Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsUncheckedCreateNestedOneWithoutMonitor_configInput
    alert?: alertUncheckedCreateNestedManyWithoutMonitor_configInput
  }

  export type Monitor_configCreateOrConnectWithoutTeamInput = {
    where: Monitor_configWhereUniqueInput
    create: XOR<Monitor_configCreateWithoutTeamInput, Monitor_configUncheckedCreateWithoutTeamInput>
  }

  export type Monitor_configCreateManyTeamInputEnvelope = {
    data: Monitor_configCreateManyTeamInput | Monitor_configCreateManyTeamInput[]
  }

  export type team_escalationpolicyCreateWithoutTeamInput = {
    id?: string
    escalationplicy_name: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutTeam_escalation_policyInput
  }

  export type team_escalationpolicyUncheckedCreateWithoutTeamInput = {
    id?: string
    escalationplicy_name: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutTeam_escalation_policyInput
  }

  export type team_escalationpolicyCreateOrConnectWithoutTeamInput = {
    where: team_escalationpolicyWhereUniqueInput
    create: XOR<team_escalationpolicyCreateWithoutTeamInput, team_escalationpolicyUncheckedCreateWithoutTeamInput>
  }

  export type team_escalationpolicyCreateManyTeamInputEnvelope = {
    data: team_escalationpolicyCreateManyTeamInput | team_escalationpolicyCreateManyTeamInput[]
  }

  export type escalation_policy_rulesCreateWithoutTeamInput = {
    id?: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    scheudleId?: string | null
    is_active?: boolean
    team_escalation_policy: team_escalationpolicyCreateNestedOneWithoutEscalation_policy_rulesInput
    user?: UserCreateNestedOneWithoutEscalation_policy_rulesInput
  }

  export type escalation_policy_rulesUncheckedCreateWithoutTeamInput = {
    id?: string
    team_escalationpolicyId: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    userId?: string | null
    scheudleId?: string | null
    is_active?: boolean
  }

  export type escalation_policy_rulesCreateOrConnectWithoutTeamInput = {
    where: escalation_policy_rulesWhereUniqueInput
    create: XOR<escalation_policy_rulesCreateWithoutTeamInput, escalation_policy_rulesUncheckedCreateWithoutTeamInput>
  }

  export type escalation_policy_rulesCreateManyTeamInputEnvelope = {
    data: escalation_policy_rulesCreateManyTeamInput | escalation_policy_rulesCreateManyTeamInput[]
  }

  export type team_scheduleCreateWithoutTeamInput = {
    id?: string
    name: string
    createdAt?: Date | string
    team_schedule_rotation?: team_schedule_rotationCreateNestedManyWithoutTeam_scheduleInput
    team_schedule_override?: team_schedule_overrideCreateNestedManyWithoutTeam_scheduleInput
  }

  export type team_scheduleUncheckedCreateWithoutTeamInput = {
    id?: string
    name: string
    createdAt?: Date | string
    team_schedule_rotation?: team_schedule_rotationUncheckedCreateNestedManyWithoutTeam_scheduleInput
    team_schedule_override?: team_schedule_overrideUncheckedCreateNestedManyWithoutTeam_scheduleInput
  }

  export type team_scheduleCreateOrConnectWithoutTeamInput = {
    where: team_scheduleWhereUniqueInput
    create: XOR<team_scheduleCreateWithoutTeamInput, team_scheduleUncheckedCreateWithoutTeamInput>
  }

  export type team_scheduleCreateManyTeamInputEnvelope = {
    data: team_scheduleCreateManyTeamInput | team_scheduleCreateManyTeamInput[]
  }

  export type UserUpsertWithoutTeamsInput = {
    update: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
    create: XOR<UserCreateWithoutTeamsInput, UserUncheckedCreateWithoutTeamsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamsInput, UserUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateWithoutTeamsInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutUserNestedInput
    alert?: alertUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUncheckedUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUncheckedUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutUserNestedInput
    alert?: alertUncheckedUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUncheckedUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkSpaceUpsertWithoutTeamInput = {
    update: XOR<WorkSpaceUpdateWithoutTeamInput, WorkSpaceUncheckedUpdateWithoutTeamInput>
    create: XOR<WorkSpaceCreateWithoutTeamInput, WorkSpaceUncheckedCreateWithoutTeamInput>
    where?: WorkSpaceWhereInput
  }

  export type WorkSpaceUpdateToOneWithWhereWithoutTeamInput = {
    where?: WorkSpaceWhereInput
    data: XOR<WorkSpaceUpdateWithoutTeamInput, WorkSpaceUncheckedUpdateWithoutTeamInput>
  }

  export type WorkSpaceUpdateWithoutTeamInput = {
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutWorkspaceNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUpdateManyWithoutWokspaceNestedInput
    team_member?: team_memberUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkSpaceUncheckedUpdateWithoutTeamInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUncheckedUpdateManyWithoutWokspaceNestedInput
    team_member?: team_memberUncheckedUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type team_memberUpsertWithWhereUniqueWithoutTeamInput = {
    where: team_memberWhereUniqueInput
    update: XOR<team_memberUpdateWithoutTeamInput, team_memberUncheckedUpdateWithoutTeamInput>
    create: XOR<team_memberCreateWithoutTeamInput, team_memberUncheckedCreateWithoutTeamInput>
  }

  export type team_memberUpdateWithWhereUniqueWithoutTeamInput = {
    where: team_memberWhereUniqueInput
    data: XOR<team_memberUpdateWithoutTeamInput, team_memberUncheckedUpdateWithoutTeamInput>
  }

  export type team_memberUpdateManyWithWhereWithoutTeamInput = {
    where: team_memberScalarWhereInput
    data: XOR<team_memberUpdateManyMutationInput, team_memberUncheckedUpdateManyWithoutTeamInput>
  }

  export type Monitor_configUpsertWithWhereUniqueWithoutTeamInput = {
    where: Monitor_configWhereUniqueInput
    update: XOR<Monitor_configUpdateWithoutTeamInput, Monitor_configUncheckedUpdateWithoutTeamInput>
    create: XOR<Monitor_configCreateWithoutTeamInput, Monitor_configUncheckedCreateWithoutTeamInput>
  }

  export type Monitor_configUpdateWithWhereUniqueWithoutTeamInput = {
    where: Monitor_configWhereUniqueInput
    data: XOR<Monitor_configUpdateWithoutTeamInput, Monitor_configUncheckedUpdateWithoutTeamInput>
  }

  export type Monitor_configUpdateManyWithWhereWithoutTeamInput = {
    where: Monitor_configScalarWhereInput
    data: XOR<Monitor_configUpdateManyMutationInput, Monitor_configUncheckedUpdateManyWithoutTeamInput>
  }

  export type team_escalationpolicyUpsertWithWhereUniqueWithoutTeamInput = {
    where: team_escalationpolicyWhereUniqueInput
    update: XOR<team_escalationpolicyUpdateWithoutTeamInput, team_escalationpolicyUncheckedUpdateWithoutTeamInput>
    create: XOR<team_escalationpolicyCreateWithoutTeamInput, team_escalationpolicyUncheckedCreateWithoutTeamInput>
  }

  export type team_escalationpolicyUpdateWithWhereUniqueWithoutTeamInput = {
    where: team_escalationpolicyWhereUniqueInput
    data: XOR<team_escalationpolicyUpdateWithoutTeamInput, team_escalationpolicyUncheckedUpdateWithoutTeamInput>
  }

  export type team_escalationpolicyUpdateManyWithWhereWithoutTeamInput = {
    where: team_escalationpolicyScalarWhereInput
    data: XOR<team_escalationpolicyUpdateManyMutationInput, team_escalationpolicyUncheckedUpdateManyWithoutTeamInput>
  }

  export type team_escalationpolicyScalarWhereInput = {
    AND?: team_escalationpolicyScalarWhereInput | team_escalationpolicyScalarWhereInput[]
    OR?: team_escalationpolicyScalarWhereInput[]
    NOT?: team_escalationpolicyScalarWhereInput | team_escalationpolicyScalarWhereInput[]
    id?: StringFilter<"team_escalationpolicy"> | string
    teamId?: StringFilter<"team_escalationpolicy"> | string
    escalationplicy_name?: StringFilter<"team_escalationpolicy"> | string
    isActive?: BoolFilter<"team_escalationpolicy"> | boolean
    description?: StringNullableFilter<"team_escalationpolicy"> | string | null
    createdAt?: DateTimeFilter<"team_escalationpolicy"> | Date | string
  }

  export type escalation_policy_rulesUpsertWithWhereUniqueWithoutTeamInput = {
    where: escalation_policy_rulesWhereUniqueInput
    update: XOR<escalation_policy_rulesUpdateWithoutTeamInput, escalation_policy_rulesUncheckedUpdateWithoutTeamInput>
    create: XOR<escalation_policy_rulesCreateWithoutTeamInput, escalation_policy_rulesUncheckedCreateWithoutTeamInput>
  }

  export type escalation_policy_rulesUpdateWithWhereUniqueWithoutTeamInput = {
    where: escalation_policy_rulesWhereUniqueInput
    data: XOR<escalation_policy_rulesUpdateWithoutTeamInput, escalation_policy_rulesUncheckedUpdateWithoutTeamInput>
  }

  export type escalation_policy_rulesUpdateManyWithWhereWithoutTeamInput = {
    where: escalation_policy_rulesScalarWhereInput
    data: XOR<escalation_policy_rulesUpdateManyMutationInput, escalation_policy_rulesUncheckedUpdateManyWithoutTeamInput>
  }

  export type team_scheduleUpsertWithWhereUniqueWithoutTeamInput = {
    where: team_scheduleWhereUniqueInput
    update: XOR<team_scheduleUpdateWithoutTeamInput, team_scheduleUncheckedUpdateWithoutTeamInput>
    create: XOR<team_scheduleCreateWithoutTeamInput, team_scheduleUncheckedCreateWithoutTeamInput>
  }

  export type team_scheduleUpdateWithWhereUniqueWithoutTeamInput = {
    where: team_scheduleWhereUniqueInput
    data: XOR<team_scheduleUpdateWithoutTeamInput, team_scheduleUncheckedUpdateWithoutTeamInput>
  }

  export type team_scheduleUpdateManyWithWhereWithoutTeamInput = {
    where: team_scheduleScalarWhereInput
    data: XOR<team_scheduleUpdateManyMutationInput, team_scheduleUncheckedUpdateManyWithoutTeamInput>
  }

  export type team_scheduleScalarWhereInput = {
    AND?: team_scheduleScalarWhereInput | team_scheduleScalarWhereInput[]
    OR?: team_scheduleScalarWhereInput[]
    NOT?: team_scheduleScalarWhereInput | team_scheduleScalarWhereInput[]
    id?: StringFilter<"team_schedule"> | string
    teamId?: StringFilter<"team_schedule"> | string
    name?: StringFilter<"team_schedule"> | string
    createdAt?: DateTimeFilter<"team_schedule"> | Date | string
  }

  export type teamCreateWithoutTeam_memberInput = {
    id?: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutTeamsInput
    workspace: WorkSpaceCreateNestedOneWithoutTeamInput
    monitor_config?: Monitor_configCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutTeam_memberInput = {
    id?: string
    creatorId: string
    workspaceId: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyUncheckedCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutTeam_memberInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutTeam_memberInput, teamUncheckedCreateWithoutTeam_memberInput>
  }

  export type WorkSpace_usersCreateWithoutTeam_memberInput = {
    id?: string
    role?: $Enums.Role
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutWorkspace_usersInput
    workspace: WorkSpaceCreateNestedOneWithoutWorkspace_usersInput
  }

  export type WorkSpace_usersUncheckedCreateWithoutTeam_memberInput = {
    id?: string
    userId: string
    workspaceId: string
    role?: $Enums.Role
    createdAt?: Date | string
  }

  export type WorkSpace_usersCreateOrConnectWithoutTeam_memberInput = {
    where: WorkSpace_usersWhereUniqueInput
    create: XOR<WorkSpace_usersCreateWithoutTeam_memberInput, WorkSpace_usersUncheckedCreateWithoutTeam_memberInput>
  }

  export type WorkSpaceCreateWithoutTeam_memberInput = {
    id?: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    owner: UserCreateNestedOneWithoutWorkspaceInput
    monitor_config?: Monitor_configCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersCreateNestedManyWithoutWokspaceInput
    team?: teamCreateNestedManyWithoutWorkspaceInput
    alert?: alertCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceUncheckedCreateWithoutTeam_memberInput = {
    id?: string
    ownerId: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersUncheckedCreateNestedManyWithoutWokspaceInput
    team?: teamUncheckedCreateNestedManyWithoutWorkspaceInput
    alert?: alertUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceCreateOrConnectWithoutTeam_memberInput = {
    where: WorkSpaceWhereUniqueInput
    create: XOR<WorkSpaceCreateWithoutTeam_memberInput, WorkSpaceUncheckedCreateWithoutTeam_memberInput>
  }

  export type teamUpsertWithoutTeam_memberInput = {
    update: XOR<teamUpdateWithoutTeam_memberInput, teamUncheckedUpdateWithoutTeam_memberInput>
    create: XOR<teamCreateWithoutTeam_memberInput, teamUncheckedCreateWithoutTeam_memberInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutTeam_memberInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutTeam_memberInput, teamUncheckedUpdateWithoutTeam_memberInput>
  }

  export type teamUpdateWithoutTeam_memberInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTeamsNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutTeamNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutTeam_memberInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUncheckedUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type WorkSpace_usersUpsertWithoutTeam_memberInput = {
    update: XOR<WorkSpace_usersUpdateWithoutTeam_memberInput, WorkSpace_usersUncheckedUpdateWithoutTeam_memberInput>
    create: XOR<WorkSpace_usersCreateWithoutTeam_memberInput, WorkSpace_usersUncheckedCreateWithoutTeam_memberInput>
    where?: WorkSpace_usersWhereInput
  }

  export type WorkSpace_usersUpdateToOneWithWhereWithoutTeam_memberInput = {
    where?: WorkSpace_usersWhereInput
    data: XOR<WorkSpace_usersUpdateWithoutTeam_memberInput, WorkSpace_usersUncheckedUpdateWithoutTeam_memberInput>
  }

  export type WorkSpace_usersUpdateWithoutTeam_memberInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspace_usersNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutWorkspace_usersNestedInput
  }

  export type WorkSpace_usersUncheckedUpdateWithoutTeam_memberInput = {
    userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkSpaceUpsertWithoutTeam_memberInput = {
    update: XOR<WorkSpaceUpdateWithoutTeam_memberInput, WorkSpaceUncheckedUpdateWithoutTeam_memberInput>
    create: XOR<WorkSpaceCreateWithoutTeam_memberInput, WorkSpaceUncheckedCreateWithoutTeam_memberInput>
    where?: WorkSpaceWhereInput
  }

  export type WorkSpaceUpdateToOneWithWhereWithoutTeam_memberInput = {
    where?: WorkSpaceWhereInput
    data: XOR<WorkSpaceUpdateWithoutTeam_memberInput, WorkSpaceUncheckedUpdateWithoutTeam_memberInput>
  }

  export type WorkSpaceUpdateWithoutTeam_memberInput = {
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutWorkspaceNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUpdateManyWithoutWokspaceNestedInput
    team?: teamUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkSpaceUncheckedUpdateWithoutTeam_memberInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUncheckedUpdateManyWithoutWokspaceNestedInput
    team?: teamUncheckedUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type Monitor_configCreateWithoutAlertInput = {
    id?: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMonitor_configInput
    workspace?: WorkSpaceCreateNestedOneWithoutMonitor_configInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsCreateNestedOneWithoutMonitor_configInput
    team?: teamCreateNestedOneWithoutMonitor_configInput
  }

  export type Monitor_configUncheckedCreateWithoutAlertInput = {
    id?: string
    userId: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    workspaceId?: string | null
    teamId?: string | null
    createdAt?: Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedCreateNestedOneWithoutMonitor_configInput
    Monitor_System_components?: Monitor_System_componentsUncheckedCreateNestedOneWithoutMonitor_configInput
  }

  export type Monitor_configCreateOrConnectWithoutAlertInput = {
    where: Monitor_configWhereUniqueInput
    create: XOR<Monitor_configCreateWithoutAlertInput, Monitor_configUncheckedCreateWithoutAlertInput>
  }

  export type UserCreateWithoutAlertInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutUserInput
    teams?: teamCreateNestedManyWithoutCreatorInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutUserInput
    user_otp?: user_otpCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAlertInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceUncheckedCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutUserInput
    teams?: teamUncheckedCreateNestedManyWithoutCreatorInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutUserInput
    user_otp?: user_otpUncheckedCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAlertInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
  }

  export type WorkSpaceCreateWithoutAlertInput = {
    id?: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    owner: UserCreateNestedOneWithoutWorkspaceInput
    monitor_config?: Monitor_configCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersCreateNestedManyWithoutWokspaceInput
    team?: teamCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceUncheckedCreateWithoutAlertInput = {
    id?: string
    ownerId: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutWorkspaceInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutWorkspaceInput
    invited_users?: invited_usersUncheckedCreateNestedManyWithoutWokspaceInput
    team?: teamUncheckedCreateNestedManyWithoutWorkspaceInput
    team_member?: team_memberUncheckedCreateNestedManyWithoutWorkspaceInput
  }

  export type WorkSpaceCreateOrConnectWithoutAlertInput = {
    where: WorkSpaceWhereUniqueInput
    create: XOR<WorkSpaceCreateWithoutAlertInput, WorkSpaceUncheckedCreateWithoutAlertInput>
  }

  export type Monitor_configUpsertWithoutAlertInput = {
    update: XOR<Monitor_configUpdateWithoutAlertInput, Monitor_configUncheckedUpdateWithoutAlertInput>
    create: XOR<Monitor_configCreateWithoutAlertInput, Monitor_configUncheckedCreateWithoutAlertInput>
    where?: Monitor_configWhereInput
  }

  export type Monitor_configUpdateToOneWithWhereWithoutAlertInput = {
    where?: Monitor_configWhereInput
    data: XOR<Monitor_configUpdateWithoutAlertInput, Monitor_configUncheckedUpdateWithoutAlertInput>
  }

  export type Monitor_configUpdateWithoutAlertInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMonitor_configNestedInput
    workspace?: WorkSpaceUpdateOneWithoutMonitor_configNestedInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUpdateOneWithoutMonitor_configNestedInput
    team?: teamUpdateOneWithoutMonitor_configNestedInput
  }

  export type Monitor_configUncheckedUpdateWithoutAlertInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUncheckedUpdateOneWithoutMonitor_configNestedInput
  }

  export type UserUpsertWithoutAlertInput = {
    update: XOR<UserUpdateWithoutAlertInput, UserUncheckedUpdateWithoutAlertInput>
    create: XOR<UserCreateWithoutAlertInput, UserUncheckedCreateWithoutAlertInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAlertInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAlertInput, UserUncheckedUpdateWithoutAlertInput>
  }

  export type UserUpdateWithoutAlertInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutUserNestedInput
    teams?: teamUpdateManyWithoutCreatorNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAlertInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUncheckedUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUncheckedUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutUserNestedInput
    teams?: teamUncheckedUpdateManyWithoutCreatorNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUncheckedUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type WorkSpaceUpsertWithoutAlertInput = {
    update: XOR<WorkSpaceUpdateWithoutAlertInput, WorkSpaceUncheckedUpdateWithoutAlertInput>
    create: XOR<WorkSpaceCreateWithoutAlertInput, WorkSpaceUncheckedCreateWithoutAlertInput>
    where?: WorkSpaceWhereInput
  }

  export type WorkSpaceUpdateToOneWithWhereWithoutAlertInput = {
    where?: WorkSpaceWhereInput
    data: XOR<WorkSpaceUpdateWithoutAlertInput, WorkSpaceUncheckedUpdateWithoutAlertInput>
  }

  export type WorkSpaceUpdateWithoutAlertInput = {
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    owner?: UserUpdateOneRequiredWithoutWorkspaceNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUpdateManyWithoutWokspaceNestedInput
    team?: teamUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkSpaceUncheckedUpdateWithoutAlertInput = {
    ownerId?: StringFieldUpdateOperationsInput | string
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUncheckedUpdateManyWithoutWokspaceNestedInput
    team?: teamUncheckedUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type teamCreateWithoutTeam_escalationpolicyInput = {
    id?: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutTeamsInput
    workspace: WorkSpaceCreateNestedOneWithoutTeamInput
    team_member?: team_memberCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutTeam_escalationpolicyInput = {
    id?: string
    creatorId: string
    workspaceId: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    team_member?: team_memberUncheckedCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutTeam_escalationpolicyInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutTeam_escalationpolicyInput, teamUncheckedCreateWithoutTeam_escalationpolicyInput>
  }

  export type escalation_policy_rulesCreateWithoutTeam_escalation_policyInput = {
    id?: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    scheudleId?: string | null
    is_active?: boolean
    user?: UserCreateNestedOneWithoutEscalation_policy_rulesInput
    team?: teamCreateNestedOneWithoutEscalation_policy_rulesInput
  }

  export type escalation_policy_rulesUncheckedCreateWithoutTeam_escalation_policyInput = {
    id?: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    userId?: string | null
    scheudleId?: string | null
    teamId?: string | null
    is_active?: boolean
  }

  export type escalation_policy_rulesCreateOrConnectWithoutTeam_escalation_policyInput = {
    where: escalation_policy_rulesWhereUniqueInput
    create: XOR<escalation_policy_rulesCreateWithoutTeam_escalation_policyInput, escalation_policy_rulesUncheckedCreateWithoutTeam_escalation_policyInput>
  }

  export type escalation_policy_rulesCreateManyTeam_escalation_policyInputEnvelope = {
    data: escalation_policy_rulesCreateManyTeam_escalation_policyInput | escalation_policy_rulesCreateManyTeam_escalation_policyInput[]
  }

  export type teamUpsertWithoutTeam_escalationpolicyInput = {
    update: XOR<teamUpdateWithoutTeam_escalationpolicyInput, teamUncheckedUpdateWithoutTeam_escalationpolicyInput>
    create: XOR<teamCreateWithoutTeam_escalationpolicyInput, teamUncheckedCreateWithoutTeam_escalationpolicyInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutTeam_escalationpolicyInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutTeam_escalationpolicyInput, teamUncheckedUpdateWithoutTeam_escalationpolicyInput>
  }

  export type teamUpdateWithoutTeam_escalationpolicyInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTeamsNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutTeamNestedInput
    team_member?: team_memberUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutTeam_escalationpolicyInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_member?: team_memberUncheckedUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type escalation_policy_rulesUpsertWithWhereUniqueWithoutTeam_escalation_policyInput = {
    where: escalation_policy_rulesWhereUniqueInput
    update: XOR<escalation_policy_rulesUpdateWithoutTeam_escalation_policyInput, escalation_policy_rulesUncheckedUpdateWithoutTeam_escalation_policyInput>
    create: XOR<escalation_policy_rulesCreateWithoutTeam_escalation_policyInput, escalation_policy_rulesUncheckedCreateWithoutTeam_escalation_policyInput>
  }

  export type escalation_policy_rulesUpdateWithWhereUniqueWithoutTeam_escalation_policyInput = {
    where: escalation_policy_rulesWhereUniqueInput
    data: XOR<escalation_policy_rulesUpdateWithoutTeam_escalation_policyInput, escalation_policy_rulesUncheckedUpdateWithoutTeam_escalation_policyInput>
  }

  export type escalation_policy_rulesUpdateManyWithWhereWithoutTeam_escalation_policyInput = {
    where: escalation_policy_rulesScalarWhereInput
    data: XOR<escalation_policy_rulesUpdateManyMutationInput, escalation_policy_rulesUncheckedUpdateManyWithoutTeam_escalation_policyInput>
  }

  export type team_escalationpolicyCreateWithoutEscalation_policy_rulesInput = {
    id?: string
    escalationplicy_name: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
    team: teamCreateNestedOneWithoutTeam_escalationpolicyInput
  }

  export type team_escalationpolicyUncheckedCreateWithoutEscalation_policy_rulesInput = {
    id?: string
    teamId: string
    escalationplicy_name: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type team_escalationpolicyCreateOrConnectWithoutEscalation_policy_rulesInput = {
    where: team_escalationpolicyWhereUniqueInput
    create: XOR<team_escalationpolicyCreateWithoutEscalation_policy_rulesInput, team_escalationpolicyUncheckedCreateWithoutEscalation_policy_rulesInput>
  }

  export type UserCreateWithoutEscalation_policy_rulesInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutUserInput
    teams?: teamCreateNestedManyWithoutCreatorInput
    alert?: alertCreateNestedManyWithoutUserInput
    user_otp?: user_otpCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEscalation_policy_rulesInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceUncheckedCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutUserInput
    teams?: teamUncheckedCreateNestedManyWithoutCreatorInput
    alert?: alertUncheckedCreateNestedManyWithoutUserInput
    user_otp?: user_otpUncheckedCreateNestedManyWithoutUserInput
    team_schedule_rotation?: team_schedule_rotationUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEscalation_policy_rulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEscalation_policy_rulesInput, UserUncheckedCreateWithoutEscalation_policy_rulesInput>
  }

  export type teamCreateWithoutEscalation_policy_rulesInput = {
    id?: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutTeamsInput
    workspace: WorkSpaceCreateNestedOneWithoutTeamInput
    team_member?: team_memberCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutEscalation_policy_rulesInput = {
    id?: string
    creatorId: string
    workspaceId: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    team_member?: team_memberUncheckedCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyUncheckedCreateNestedManyWithoutTeamInput
    team_schedule?: team_scheduleUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutEscalation_policy_rulesInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutEscalation_policy_rulesInput, teamUncheckedCreateWithoutEscalation_policy_rulesInput>
  }

  export type team_escalationpolicyUpsertWithoutEscalation_policy_rulesInput = {
    update: XOR<team_escalationpolicyUpdateWithoutEscalation_policy_rulesInput, team_escalationpolicyUncheckedUpdateWithoutEscalation_policy_rulesInput>
    create: XOR<team_escalationpolicyCreateWithoutEscalation_policy_rulesInput, team_escalationpolicyUncheckedCreateWithoutEscalation_policy_rulesInput>
    where?: team_escalationpolicyWhereInput
  }

  export type team_escalationpolicyUpdateToOneWithWhereWithoutEscalation_policy_rulesInput = {
    where?: team_escalationpolicyWhereInput
    data: XOR<team_escalationpolicyUpdateWithoutEscalation_policy_rulesInput, team_escalationpolicyUncheckedUpdateWithoutEscalation_policy_rulesInput>
  }

  export type team_escalationpolicyUpdateWithoutEscalation_policy_rulesInput = {
    escalationplicy_name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: teamUpdateOneRequiredWithoutTeam_escalationpolicyNestedInput
  }

  export type team_escalationpolicyUncheckedUpdateWithoutEscalation_policy_rulesInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    escalationplicy_name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutEscalation_policy_rulesInput = {
    update: XOR<UserUpdateWithoutEscalation_policy_rulesInput, UserUncheckedUpdateWithoutEscalation_policy_rulesInput>
    create: XOR<UserCreateWithoutEscalation_policy_rulesInput, UserUncheckedCreateWithoutEscalation_policy_rulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEscalation_policy_rulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEscalation_policy_rulesInput, UserUncheckedUpdateWithoutEscalation_policy_rulesInput>
  }

  export type UserUpdateWithoutEscalation_policy_rulesInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutUserNestedInput
    teams?: teamUpdateManyWithoutCreatorNestedInput
    alert?: alertUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEscalation_policy_rulesInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUncheckedUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUncheckedUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutUserNestedInput
    teams?: teamUncheckedUpdateManyWithoutCreatorNestedInput
    alert?: alertUncheckedUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUncheckedUpdateManyWithoutUserNestedInput
    team_schedule_rotation?: team_schedule_rotationUncheckedUpdateManyWithoutUserNestedInput
  }

  export type teamUpsertWithoutEscalation_policy_rulesInput = {
    update: XOR<teamUpdateWithoutEscalation_policy_rulesInput, teamUncheckedUpdateWithoutEscalation_policy_rulesInput>
    create: XOR<teamCreateWithoutEscalation_policy_rulesInput, teamUncheckedCreateWithoutEscalation_policy_rulesInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutEscalation_policy_rulesInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutEscalation_policy_rulesInput, teamUncheckedUpdateWithoutEscalation_policy_rulesInput>
  }

  export type teamUpdateWithoutEscalation_policy_rulesInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTeamsNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutTeamNestedInput
    team_member?: team_memberUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutEscalation_policy_rulesInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_member?: team_memberUncheckedUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUncheckedUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamCreateWithoutTeam_scheduleInput = {
    id?: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    creator: UserCreateNestedOneWithoutTeamsInput
    workspace: WorkSpaceCreateNestedOneWithoutTeamInput
    team_member?: team_memberCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutTeamInput
  }

  export type teamUncheckedCreateWithoutTeam_scheduleInput = {
    id?: string
    creatorId: string
    workspaceId: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
    team_member?: team_memberUncheckedCreateNestedManyWithoutTeamInput
    monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutTeamInput
    team_escalationpolicy?: team_escalationpolicyUncheckedCreateNestedManyWithoutTeamInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutTeamInput
  }

  export type teamCreateOrConnectWithoutTeam_scheduleInput = {
    where: teamWhereUniqueInput
    create: XOR<teamCreateWithoutTeam_scheduleInput, teamUncheckedCreateWithoutTeam_scheduleInput>
  }

  export type team_schedule_rotationCreateWithoutTeam_scheduleInput = {
    id?: string
    name: string
    starts_on?: Date | string
    frequency: $Enums.Frequency
    ends_on?: Date | string | null
    custom_start_date_time?: Date | string | null
    custom_end_date_time?: Date | string | null
    restrict_time_type?: $Enums.Restriction | null
    restrict_time_start?: Date | string | null
    restrict_time_end?: Date | string | null
    user: UserCreateNestedOneWithoutTeam_schedule_rotationInput
  }

  export type team_schedule_rotationUncheckedCreateWithoutTeam_scheduleInput = {
    id?: string
    name: string
    userId: string
    starts_on?: Date | string
    frequency: $Enums.Frequency
    ends_on?: Date | string | null
    custom_start_date_time?: Date | string | null
    custom_end_date_time?: Date | string | null
    restrict_time_type?: $Enums.Restriction | null
    restrict_time_start?: Date | string | null
    restrict_time_end?: Date | string | null
  }

  export type team_schedule_rotationCreateOrConnectWithoutTeam_scheduleInput = {
    where: team_schedule_rotationWhereUniqueInput
    create: XOR<team_schedule_rotationCreateWithoutTeam_scheduleInput, team_schedule_rotationUncheckedCreateWithoutTeam_scheduleInput>
  }

  export type team_schedule_rotationCreateManyTeam_scheduleInputEnvelope = {
    data: team_schedule_rotationCreateManyTeam_scheduleInput | team_schedule_rotationCreateManyTeam_scheduleInput[]
  }

  export type team_schedule_overrideCreateWithoutTeam_scheduleInput = {
    id?: string
    name: string
    start_time: Date | string
    end_time?: Date | string | null
  }

  export type team_schedule_overrideUncheckedCreateWithoutTeam_scheduleInput = {
    id?: string
    name: string
    start_time: Date | string
    end_time?: Date | string | null
  }

  export type team_schedule_overrideCreateOrConnectWithoutTeam_scheduleInput = {
    where: team_schedule_overrideWhereUniqueInput
    create: XOR<team_schedule_overrideCreateWithoutTeam_scheduleInput, team_schedule_overrideUncheckedCreateWithoutTeam_scheduleInput>
  }

  export type team_schedule_overrideCreateManyTeam_scheduleInputEnvelope = {
    data: team_schedule_overrideCreateManyTeam_scheduleInput | team_schedule_overrideCreateManyTeam_scheduleInput[]
  }

  export type teamUpsertWithoutTeam_scheduleInput = {
    update: XOR<teamUpdateWithoutTeam_scheduleInput, teamUncheckedUpdateWithoutTeam_scheduleInput>
    create: XOR<teamCreateWithoutTeam_scheduleInput, teamUncheckedCreateWithoutTeam_scheduleInput>
    where?: teamWhereInput
  }

  export type teamUpdateToOneWithWhereWithoutTeam_scheduleInput = {
    where?: teamWhereInput
    data: XOR<teamUpdateWithoutTeam_scheduleInput, teamUncheckedUpdateWithoutTeam_scheduleInput>
  }

  export type teamUpdateWithoutTeam_scheduleInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTeamsNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutTeamNestedInput
    team_member?: team_memberUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutTeam_scheduleInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_member?: team_memberUncheckedUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUncheckedUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type team_schedule_rotationUpsertWithWhereUniqueWithoutTeam_scheduleInput = {
    where: team_schedule_rotationWhereUniqueInput
    update: XOR<team_schedule_rotationUpdateWithoutTeam_scheduleInput, team_schedule_rotationUncheckedUpdateWithoutTeam_scheduleInput>
    create: XOR<team_schedule_rotationCreateWithoutTeam_scheduleInput, team_schedule_rotationUncheckedCreateWithoutTeam_scheduleInput>
  }

  export type team_schedule_rotationUpdateWithWhereUniqueWithoutTeam_scheduleInput = {
    where: team_schedule_rotationWhereUniqueInput
    data: XOR<team_schedule_rotationUpdateWithoutTeam_scheduleInput, team_schedule_rotationUncheckedUpdateWithoutTeam_scheduleInput>
  }

  export type team_schedule_rotationUpdateManyWithWhereWithoutTeam_scheduleInput = {
    where: team_schedule_rotationScalarWhereInput
    data: XOR<team_schedule_rotationUpdateManyMutationInput, team_schedule_rotationUncheckedUpdateManyWithoutTeam_scheduleInput>
  }

  export type team_schedule_overrideUpsertWithWhereUniqueWithoutTeam_scheduleInput = {
    where: team_schedule_overrideWhereUniqueInput
    update: XOR<team_schedule_overrideUpdateWithoutTeam_scheduleInput, team_schedule_overrideUncheckedUpdateWithoutTeam_scheduleInput>
    create: XOR<team_schedule_overrideCreateWithoutTeam_scheduleInput, team_schedule_overrideUncheckedCreateWithoutTeam_scheduleInput>
  }

  export type team_schedule_overrideUpdateWithWhereUniqueWithoutTeam_scheduleInput = {
    where: team_schedule_overrideWhereUniqueInput
    data: XOR<team_schedule_overrideUpdateWithoutTeam_scheduleInput, team_schedule_overrideUncheckedUpdateWithoutTeam_scheduleInput>
  }

  export type team_schedule_overrideUpdateManyWithWhereWithoutTeam_scheduleInput = {
    where: team_schedule_overrideScalarWhereInput
    data: XOR<team_schedule_overrideUpdateManyMutationInput, team_schedule_overrideUncheckedUpdateManyWithoutTeam_scheduleInput>
  }

  export type team_schedule_overrideScalarWhereInput = {
    AND?: team_schedule_overrideScalarWhereInput | team_schedule_overrideScalarWhereInput[]
    OR?: team_schedule_overrideScalarWhereInput[]
    NOT?: team_schedule_overrideScalarWhereInput | team_schedule_overrideScalarWhereInput[]
    id?: StringFilter<"team_schedule_override"> | string
    team_scheduleId?: StringFilter<"team_schedule_override"> | string
    name?: StringFilter<"team_schedule_override"> | string
    start_time?: DateTimeFilter<"team_schedule_override"> | Date | string
    end_time?: DateTimeNullableFilter<"team_schedule_override"> | Date | string | null
  }

  export type team_scheduleCreateWithoutTeam_schedule_rotationInput = {
    id?: string
    name: string
    createdAt?: Date | string
    team: teamCreateNestedOneWithoutTeam_scheduleInput
    team_schedule_override?: team_schedule_overrideCreateNestedManyWithoutTeam_scheduleInput
  }

  export type team_scheduleUncheckedCreateWithoutTeam_schedule_rotationInput = {
    id?: string
    teamId: string
    name: string
    createdAt?: Date | string
    team_schedule_override?: team_schedule_overrideUncheckedCreateNestedManyWithoutTeam_scheduleInput
  }

  export type team_scheduleCreateOrConnectWithoutTeam_schedule_rotationInput = {
    where: team_scheduleWhereUniqueInput
    create: XOR<team_scheduleCreateWithoutTeam_schedule_rotationInput, team_scheduleUncheckedCreateWithoutTeam_schedule_rotationInput>
  }

  export type UserCreateWithoutTeam_schedule_rotationInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersCreateNestedManyWithoutUserInput
    teams?: teamCreateNestedManyWithoutCreatorInput
    alert?: alertCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesCreateNestedManyWithoutUserInput
    user_otp?: user_otpCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTeam_schedule_rotationInput = {
    id?: string
    supaId: string
    name: string
    email: string
    number?: string | null
    photo?: string | null
    is_phone_number_verified?: boolean
    Monitor_config?: Monitor_configUncheckedCreateNestedManyWithoutUserInput
    workspace?: WorkSpaceUncheckedCreateNestedManyWithoutOwnerInput
    workspace_users?: WorkSpace_usersUncheckedCreateNestedManyWithoutUserInput
    teams?: teamUncheckedCreateNestedManyWithoutCreatorInput
    alert?: alertUncheckedCreateNestedManyWithoutUserInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedCreateNestedManyWithoutUserInput
    user_otp?: user_otpUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTeam_schedule_rotationInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeam_schedule_rotationInput, UserUncheckedCreateWithoutTeam_schedule_rotationInput>
  }

  export type team_scheduleUpsertWithoutTeam_schedule_rotationInput = {
    update: XOR<team_scheduleUpdateWithoutTeam_schedule_rotationInput, team_scheduleUncheckedUpdateWithoutTeam_schedule_rotationInput>
    create: XOR<team_scheduleCreateWithoutTeam_schedule_rotationInput, team_scheduleUncheckedCreateWithoutTeam_schedule_rotationInput>
    where?: team_scheduleWhereInput
  }

  export type team_scheduleUpdateToOneWithWhereWithoutTeam_schedule_rotationInput = {
    where?: team_scheduleWhereInput
    data: XOR<team_scheduleUpdateWithoutTeam_schedule_rotationInput, team_scheduleUncheckedUpdateWithoutTeam_schedule_rotationInput>
  }

  export type team_scheduleUpdateWithoutTeam_schedule_rotationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: teamUpdateOneRequiredWithoutTeam_scheduleNestedInput
    team_schedule_override?: team_schedule_overrideUpdateManyWithoutTeam_scheduleNestedInput
  }

  export type team_scheduleUncheckedUpdateWithoutTeam_schedule_rotationInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_schedule_override?: team_schedule_overrideUncheckedUpdateManyWithoutTeam_scheduleNestedInput
  }

  export type UserUpsertWithoutTeam_schedule_rotationInput = {
    update: XOR<UserUpdateWithoutTeam_schedule_rotationInput, UserUncheckedUpdateWithoutTeam_schedule_rotationInput>
    create: XOR<UserCreateWithoutTeam_schedule_rotationInput, UserUncheckedCreateWithoutTeam_schedule_rotationInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeam_schedule_rotationInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeam_schedule_rotationInput, UserUncheckedUpdateWithoutTeam_schedule_rotationInput>
  }

  export type UserUpdateWithoutTeam_schedule_rotationInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutUserNestedInput
    teams?: teamUpdateManyWithoutCreatorNestedInput
    alert?: alertUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTeam_schedule_rotationInput = {
    supaId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    number?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    is_phone_number_verified?: BoolFieldUpdateOperationsInput | boolean
    Monitor_config?: Monitor_configUncheckedUpdateManyWithoutUserNestedInput
    workspace?: WorkSpaceUncheckedUpdateManyWithoutOwnerNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutUserNestedInput
    teams?: teamUncheckedUpdateManyWithoutCreatorNestedInput
    alert?: alertUncheckedUpdateManyWithoutUserNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutUserNestedInput
    user_otp?: user_otpUncheckedUpdateManyWithoutUserNestedInput
  }

  export type team_scheduleCreateWithoutTeam_schedule_overrideInput = {
    id?: string
    name: string
    createdAt?: Date | string
    team: teamCreateNestedOneWithoutTeam_scheduleInput
    team_schedule_rotation?: team_schedule_rotationCreateNestedManyWithoutTeam_scheduleInput
  }

  export type team_scheduleUncheckedCreateWithoutTeam_schedule_overrideInput = {
    id?: string
    teamId: string
    name: string
    createdAt?: Date | string
    team_schedule_rotation?: team_schedule_rotationUncheckedCreateNestedManyWithoutTeam_scheduleInput
  }

  export type team_scheduleCreateOrConnectWithoutTeam_schedule_overrideInput = {
    where: team_scheduleWhereUniqueInput
    create: XOR<team_scheduleCreateWithoutTeam_schedule_overrideInput, team_scheduleUncheckedCreateWithoutTeam_schedule_overrideInput>
  }

  export type team_scheduleUpsertWithoutTeam_schedule_overrideInput = {
    update: XOR<team_scheduleUpdateWithoutTeam_schedule_overrideInput, team_scheduleUncheckedUpdateWithoutTeam_schedule_overrideInput>
    create: XOR<team_scheduleCreateWithoutTeam_schedule_overrideInput, team_scheduleUncheckedCreateWithoutTeam_schedule_overrideInput>
    where?: team_scheduleWhereInput
  }

  export type team_scheduleUpdateToOneWithWhereWithoutTeam_schedule_overrideInput = {
    where?: team_scheduleWhereInput
    data: XOR<team_scheduleUpdateWithoutTeam_schedule_overrideInput, team_scheduleUncheckedUpdateWithoutTeam_schedule_overrideInput>
  }

  export type team_scheduleUpdateWithoutTeam_schedule_overrideInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team?: teamUpdateOneRequiredWithoutTeam_scheduleNestedInput
    team_schedule_rotation?: team_schedule_rotationUpdateManyWithoutTeam_scheduleNestedInput
  }

  export type team_scheduleUncheckedUpdateWithoutTeam_schedule_overrideInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_schedule_rotation?: team_schedule_rotationUncheckedUpdateManyWithoutTeam_scheduleNestedInput
  }

  export type Monitor_configCreateManyUserInput = {
    id?: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    workspaceId?: string | null
    teamId?: string | null
    createdAt?: Date | string
  }

  export type WorkSpaceCreateManyOwnerInput = {
    id?: string
    workspace_name: string
    trial_startDate?: Date | string
    trial_endDate: Date | string
    subscription_start?: Date | string | null
    subscription_end?: Date | string | null
  }

  export type WorkSpace_usersCreateManyUserInput = {
    id?: string
    workspaceId: string
    role?: $Enums.Role
    createdAt?: Date | string
  }

  export type teamCreateManyCreatorInput = {
    id?: string
    workspaceId: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
  }

  export type alertCreateManyUserInput = {
    id?: string
    acknowledged?: boolean
    monitor_configId: string
    workspaceId: string
    createdAt?: Date | string
  }

  export type escalation_policy_rulesCreateManyUserInput = {
    id?: string
    team_escalationpolicyId: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    scheudleId?: string | null
    teamId?: string | null
    is_active?: boolean
  }

  export type user_otpCreateManyUserInput = {
    id?: string
    otp: string
    invalid?: boolean
    expiresAt: number
    createdAt?: Date | string
  }

  export type team_schedule_rotationCreateManyUserInput = {
    id?: string
    team_scheduleId: string
    name: string
    starts_on?: Date | string
    frequency: $Enums.Frequency
    ends_on?: Date | string | null
    custom_start_date_time?: Date | string | null
    custom_end_date_time?: Date | string | null
    restrict_time_type?: $Enums.Restriction | null
    restrict_time_start?: Date | string | null
    restrict_time_end?: Date | string | null
  }

  export type Monitor_configUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkSpaceUpdateOneWithoutMonitor_configNestedInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUpdateOneWithoutMonitor_configNestedInput
    team?: teamUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configUncheckedUpdateWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUncheckedUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUncheckedUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configUncheckedUpdateManyWithoutUserInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkSpaceUpdateWithoutOwnerInput = {
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monitor_config?: Monitor_configUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUpdateManyWithoutWokspaceNestedInput
    team?: teamUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkSpaceUncheckedUpdateWithoutOwnerInput = {
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutWorkspaceNestedInput
    workspace_users?: WorkSpace_usersUncheckedUpdateManyWithoutWorkspaceNestedInput
    invited_users?: invited_usersUncheckedUpdateManyWithoutWokspaceNestedInput
    team?: teamUncheckedUpdateManyWithoutWorkspaceNestedInput
    team_member?: team_memberUncheckedUpdateManyWithoutWorkspaceNestedInput
    alert?: alertUncheckedUpdateManyWithoutWorkspaceNestedInput
  }

  export type WorkSpaceUncheckedUpdateManyWithoutOwnerInput = {
    workspace_name?: StringFieldUpdateOperationsInput | string
    trial_startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trial_endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscription_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WorkSpace_usersUpdateWithoutUserInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkSpaceUpdateOneRequiredWithoutWorkspace_usersNestedInput
    team_member?: team_memberUpdateManyWithoutWorkspace_userNestedInput
  }

  export type WorkSpace_usersUncheckedUpdateWithoutUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_member?: team_memberUncheckedUpdateManyWithoutWorkspace_userNestedInput
  }

  export type WorkSpace_usersUncheckedUpdateManyWithoutUserInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamUpdateWithoutCreatorInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workspace?: WorkSpaceUpdateOneRequiredWithoutTeamNestedInput
    team_member?: team_memberUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutCreatorInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_member?: team_memberUncheckedUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUncheckedUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateManyWithoutCreatorInput = {
    workspaceId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertUpdateWithoutUserInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitor_config?: Monitor_configUpdateOneRequiredWithoutAlertNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutAlertNestedInput
  }

  export type alertUncheckedUpdateWithoutUserInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    monitor_configId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertUncheckedUpdateManyWithoutUserInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    monitor_configId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escalation_policy_rulesUpdateWithoutUserInput = {
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    team_escalation_policy?: team_escalationpolicyUpdateOneRequiredWithoutEscalation_policy_rulesNestedInput
    team?: teamUpdateOneWithoutEscalation_policy_rulesNestedInput
  }

  export type escalation_policy_rulesUncheckedUpdateWithoutUserInput = {
    team_escalationpolicyId?: StringFieldUpdateOperationsInput | string
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type escalation_policy_rulesUncheckedUpdateManyWithoutUserInput = {
    team_escalationpolicyId?: StringFieldUpdateOperationsInput | string
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type user_otpUpdateWithoutUserInput = {
    otp?: StringFieldUpdateOperationsInput | string
    invalid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_otpUncheckedUpdateWithoutUserInput = {
    otp?: StringFieldUpdateOperationsInput | string
    invalid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type user_otpUncheckedUpdateManyWithoutUserInput = {
    otp?: StringFieldUpdateOperationsInput | string
    invalid?: BoolFieldUpdateOperationsInput | boolean
    expiresAt?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type team_schedule_rotationUpdateWithoutUserInput = {
    name?: StringFieldUpdateOperationsInput | string
    starts_on?: DateTimeFieldUpdateOperationsInput | Date | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    ends_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_start_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_end_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_type?: NullableEnumRestrictionFieldUpdateOperationsInput | $Enums.Restriction | null
    restrict_time_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team_schedule?: team_scheduleUpdateOneRequiredWithoutTeam_schedule_rotationNestedInput
  }

  export type team_schedule_rotationUncheckedUpdateWithoutUserInput = {
    team_scheduleId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    starts_on?: DateTimeFieldUpdateOperationsInput | Date | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    ends_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_start_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_end_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_type?: NullableEnumRestrictionFieldUpdateOperationsInput | $Enums.Restriction | null
    restrict_time_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type team_schedule_rotationUncheckedUpdateManyWithoutUserInput = {
    team_scheduleId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    starts_on?: DateTimeFieldUpdateOperationsInput | Date | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    ends_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_start_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_end_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_type?: NullableEnumRestrictionFieldUpdateOperationsInput | $Enums.Restriction | null
    restrict_time_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type alertCreateManyMonitor_configInput = {
    id?: string
    acknowledged?: boolean
    userId?: string | null
    workspaceId: string
    createdAt?: Date | string
  }

  export type alertUpdateWithoutMonitor_configInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutAlertNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutAlertNestedInput
  }

  export type alertUncheckedUpdateWithoutMonitor_configInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertUncheckedUpdateManyWithoutMonitor_configInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    workspaceId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type Monitor_configCreateManyWorkspaceInput = {
    id?: string
    userId: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    teamId?: string | null
    createdAt?: Date | string
  }

  export type WorkSpace_usersCreateManyWorkspaceInput = {
    id?: string
    userId: string
    role?: $Enums.Role
    createdAt?: Date | string
  }

  export type invited_usersCreateManyWokspaceInput = {
    id?: string
    invited_user_name: string
    invited_user_email_id: string
    invited_by: string
    role: $Enums.Role
    status: $Enums.status
    invited_on?: Date | string
  }

  export type teamCreateManyWorkspaceInput = {
    id?: string
    creatorId: string
    teamName: string
    description?: string | null
    createdAt?: Date | string
  }

  export type team_memberCreateManyWorkspaceInput = {
    id?: string
    teamId: string
    workspace_userId: string
  }

  export type alertCreateManyWorkspaceInput = {
    id?: string
    acknowledged?: boolean
    monitor_configId: string
    userId?: string | null
    createdAt?: Date | string
  }

  export type Monitor_configUpdateWithoutWorkspaceInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMonitor_configNestedInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUpdateOneWithoutMonitor_configNestedInput
    team?: teamUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configUncheckedUpdateWithoutWorkspaceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUncheckedUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUncheckedUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configUncheckedUpdateManyWithoutWorkspaceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type WorkSpace_usersUpdateWithoutWorkspaceInput = {
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutWorkspace_usersNestedInput
    team_member?: team_memberUpdateManyWithoutWorkspace_userNestedInput
  }

  export type WorkSpace_usersUncheckedUpdateWithoutWorkspaceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_member?: team_memberUncheckedUpdateManyWithoutWorkspace_userNestedInput
  }

  export type WorkSpace_usersUncheckedUpdateManyWithoutWorkspaceInput = {
    userId?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invited_usersUpdateWithoutWokspaceInput = {
    invited_user_name?: StringFieldUpdateOperationsInput | string
    invited_user_email_id?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    invited_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invited_usersUncheckedUpdateWithoutWokspaceInput = {
    invited_user_name?: StringFieldUpdateOperationsInput | string
    invited_user_email_id?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    invited_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type invited_usersUncheckedUpdateManyWithoutWokspaceInput = {
    invited_user_name?: StringFieldUpdateOperationsInput | string
    invited_user_email_id?: StringFieldUpdateOperationsInput | string
    invited_by?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    status?: EnumstatusFieldUpdateOperationsInput | $Enums.status
    invited_on?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type teamUpdateWithoutWorkspaceInput = {
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTeamsNestedInput
    team_member?: team_memberUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateWithoutWorkspaceInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_member?: team_memberUncheckedUpdateManyWithoutTeamNestedInput
    monitor_config?: Monitor_configUncheckedUpdateManyWithoutTeamNestedInput
    team_escalationpolicy?: team_escalationpolicyUncheckedUpdateManyWithoutTeamNestedInput
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutTeamNestedInput
    team_schedule?: team_scheduleUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type teamUncheckedUpdateManyWithoutWorkspaceInput = {
    creatorId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type team_memberUpdateWithoutWorkspaceInput = {
    team?: teamUpdateOneRequiredWithoutTeam_memberNestedInput
    workspace_user?: WorkSpace_usersUpdateOneRequiredWithoutTeam_memberNestedInput
  }

  export type team_memberUncheckedUpdateWithoutWorkspaceInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    workspace_userId?: StringFieldUpdateOperationsInput | string
  }

  export type team_memberUncheckedUpdateManyWithoutWorkspaceInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    workspace_userId?: StringFieldUpdateOperationsInput | string
  }

  export type alertUpdateWithoutWorkspaceInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    monitor_config?: Monitor_configUpdateOneRequiredWithoutAlertNestedInput
    user?: UserUpdateOneWithoutAlertNestedInput
  }

  export type alertUncheckedUpdateWithoutWorkspaceInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    monitor_configId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type alertUncheckedUpdateManyWithoutWorkspaceInput = {
    acknowledged?: BoolFieldUpdateOperationsInput | boolean
    monitor_configId?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type team_memberCreateManyWorkspace_userInput = {
    id?: string
    teamId: string
    workspaceId: string
  }

  export type team_memberUpdateWithoutWorkspace_userInput = {
    team?: teamUpdateOneRequiredWithoutTeam_memberNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutTeam_memberNestedInput
  }

  export type team_memberUncheckedUpdateWithoutWorkspace_userInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type team_memberUncheckedUpdateManyWithoutWorkspace_userInput = {
    teamId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type team_memberCreateManyTeamInput = {
    id?: string
    workspace_userId: string
    workspaceId: string
  }

  export type Monitor_configCreateManyTeamInput = {
    id?: string
    userId: string
    name?: string | null
    monitorType: string
    is_active?: boolean
    workspaceId?: string | null
    createdAt?: Date | string
  }

  export type team_escalationpolicyCreateManyTeamInput = {
    id?: string
    escalationplicy_name: string
    isActive?: boolean
    description?: string | null
    createdAt?: Date | string
  }

  export type escalation_policy_rulesCreateManyTeamInput = {
    id?: string
    team_escalationpolicyId: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    userId?: string | null
    scheudleId?: string | null
    is_active?: boolean
  }

  export type team_scheduleCreateManyTeamInput = {
    id?: string
    name: string
    createdAt?: Date | string
  }

  export type team_memberUpdateWithoutTeamInput = {
    workspace_user?: WorkSpace_usersUpdateOneRequiredWithoutTeam_memberNestedInput
    workspace?: WorkSpaceUpdateOneRequiredWithoutTeam_memberNestedInput
  }

  export type team_memberUncheckedUpdateWithoutTeamInput = {
    workspace_userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type team_memberUncheckedUpdateManyWithoutTeamInput = {
    workspace_userId?: StringFieldUpdateOperationsInput | string
    workspaceId?: StringFieldUpdateOperationsInput | string
  }

  export type Monitor_configUpdateWithoutTeamInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMonitor_configNestedInput
    workspace?: WorkSpaceUpdateOneWithoutMonitor_configNestedInput
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configUncheckedUpdateWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Monitor_HTTP_gPRC_config?: Monitor_HTTP_gPRC_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_SSL_config?: Monitor_SSL_configUncheckedUpdateOneWithoutMonitor_configNestedInput
    Monitor_System_components?: Monitor_System_componentsUncheckedUpdateOneWithoutMonitor_configNestedInput
    alert?: alertUncheckedUpdateManyWithoutMonitor_configNestedInput
  }

  export type Monitor_configUncheckedUpdateManyWithoutTeamInput = {
    userId?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    monitorType?: StringFieldUpdateOperationsInput | string
    is_active?: BoolFieldUpdateOperationsInput | boolean
    workspaceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type team_escalationpolicyUpdateWithoutTeamInput = {
    escalationplicy_name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    escalation_policy_rules?: escalation_policy_rulesUpdateManyWithoutTeam_escalation_policyNestedInput
  }

  export type team_escalationpolicyUncheckedUpdateWithoutTeamInput = {
    escalationplicy_name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    escalation_policy_rules?: escalation_policy_rulesUncheckedUpdateManyWithoutTeam_escalation_policyNestedInput
  }

  export type team_escalationpolicyUncheckedUpdateManyWithoutTeamInput = {
    escalationplicy_name?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escalation_policy_rulesUpdateWithoutTeamInput = {
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    team_escalation_policy?: team_escalationpolicyUpdateOneRequiredWithoutEscalation_policy_rulesNestedInput
    user?: UserUpdateOneWithoutEscalation_policy_rulesNestedInput
  }

  export type escalation_policy_rulesUncheckedUpdateWithoutTeamInput = {
    team_escalationpolicyId?: StringFieldUpdateOperationsInput | string
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type escalation_policy_rulesUncheckedUpdateManyWithoutTeamInput = {
    team_escalationpolicyId?: StringFieldUpdateOperationsInput | string
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type team_scheduleUpdateWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_schedule_rotation?: team_schedule_rotationUpdateManyWithoutTeam_scheduleNestedInput
    team_schedule_override?: team_schedule_overrideUpdateManyWithoutTeam_scheduleNestedInput
  }

  export type team_scheduleUncheckedUpdateWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    team_schedule_rotation?: team_schedule_rotationUncheckedUpdateManyWithoutTeam_scheduleNestedInput
    team_schedule_override?: team_schedule_overrideUncheckedUpdateManyWithoutTeam_scheduleNestedInput
  }

  export type team_scheduleUncheckedUpdateManyWithoutTeamInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type escalation_policy_rulesCreateManyTeam_escalation_policyInput = {
    id?: string
    alert_status: string
    minutes_after_creation: number
    notification_type: $Enums.notification_type
    userId?: string | null
    scheudleId?: string | null
    teamId?: string | null
    is_active?: boolean
  }

  export type escalation_policy_rulesUpdateWithoutTeam_escalation_policyInput = {
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    user?: UserUpdateOneWithoutEscalation_policy_rulesNestedInput
    team?: teamUpdateOneWithoutEscalation_policy_rulesNestedInput
  }

  export type escalation_policy_rulesUncheckedUpdateWithoutTeam_escalation_policyInput = {
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type escalation_policy_rulesUncheckedUpdateManyWithoutTeam_escalation_policyInput = {
    alert_status?: StringFieldUpdateOperationsInput | string
    minutes_after_creation?: IntFieldUpdateOperationsInput | number
    notification_type?: Enumnotification_typeFieldUpdateOperationsInput | $Enums.notification_type
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    scheudleId?: NullableStringFieldUpdateOperationsInput | string | null
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
  }

  export type team_schedule_rotationCreateManyTeam_scheduleInput = {
    id?: string
    name: string
    userId: string
    starts_on?: Date | string
    frequency: $Enums.Frequency
    ends_on?: Date | string | null
    custom_start_date_time?: Date | string | null
    custom_end_date_time?: Date | string | null
    restrict_time_type?: $Enums.Restriction | null
    restrict_time_start?: Date | string | null
    restrict_time_end?: Date | string | null
  }

  export type team_schedule_overrideCreateManyTeam_scheduleInput = {
    id?: string
    name: string
    start_time: Date | string
    end_time?: Date | string | null
  }

  export type team_schedule_rotationUpdateWithoutTeam_scheduleInput = {
    name?: StringFieldUpdateOperationsInput | string
    starts_on?: DateTimeFieldUpdateOperationsInput | Date | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    ends_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_start_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_end_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_type?: NullableEnumRestrictionFieldUpdateOperationsInput | $Enums.Restriction | null
    restrict_time_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTeam_schedule_rotationNestedInput
  }

  export type team_schedule_rotationUncheckedUpdateWithoutTeam_scheduleInput = {
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    starts_on?: DateTimeFieldUpdateOperationsInput | Date | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    ends_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_start_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_end_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_type?: NullableEnumRestrictionFieldUpdateOperationsInput | $Enums.Restriction | null
    restrict_time_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type team_schedule_rotationUncheckedUpdateManyWithoutTeam_scheduleInput = {
    name?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    starts_on?: DateTimeFieldUpdateOperationsInput | Date | string
    frequency?: EnumFrequencyFieldUpdateOperationsInput | $Enums.Frequency
    ends_on?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_start_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    custom_end_date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_type?: NullableEnumRestrictionFieldUpdateOperationsInput | $Enums.Restriction | null
    restrict_time_start?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrict_time_end?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type team_schedule_overrideUpdateWithoutTeam_scheduleInput = {
    name?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type team_schedule_overrideUncheckedUpdateWithoutTeam_scheduleInput = {
    name?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type team_schedule_overrideUncheckedUpdateManyWithoutTeam_scheduleInput = {
    name?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}